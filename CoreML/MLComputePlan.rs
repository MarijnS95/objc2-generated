//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A class describing the plan for executing a model.
    ///
    /// The application can use the plan to estimate the necessary cost and
    /// resources of the model before running the predictions.
    ///
    /// ```text
    /// // Load the compute plan of an ML Program model.
    /// [MLComputePlan loadContentsOfURL:modelURL configuration:configuration completionHandler:^(MLComputePlan * _Nullable computePlan, NSError * _Nullable error) {
    /// if (!computePlan) {
    /// // Handle error.
    /// return;
    /// }
    /// MLModelStructureProgram *program = computePlan.modelStructure.program;
    /// if (!program) {
    /// [NSException raise:NSInternalInconsistencyException format:
    /// "
    /// Unexpected model type."];
    /// }
    ///
    /// MLModelStructureFunction *mainFunction = program.functions["main"];
    /// if (!mainFunction) {
    /// [NSException raise:NSInternalInconsistencyException format:
    /// "
    /// Missing main function."];
    /// }
    ///
    /// NSArray
    /// <MLModelStructureProgramOperation
    /// *> *operations = mainFunction.block.operations;
    /// for (MLModelStructureProgramOperation *operation in operations) {
    /// // Get the compute device usage for the operation.
    /// MLComputeDeviceUsage *computeDeviceUsage = [computePlan computeDeviceUsageForMLProgramOperation:operation];
    /// // Get the estimated cost of executing the operation.
    /// MLComputePlanCost *estimatedCost = [computePlan estimatedCostOfMLProgramOperation:operation];
    ///
    /// }
    /// }];
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coreml/mlcomputeplan?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MLComputePlan;
);

unsafe impl NSObjectProtocol for MLComputePlan {}

impl MLComputePlan {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(all(feature = "MLModelConfiguration", feature = "block2"))]
        /// Construct the compute plan of a model asynchronously given the location of its on-disk representation.
        ///
        ///
        /// Parameter `url`: The location of its on-disk representation (.mlmodelc directory).
        ///
        /// Parameter `configuration`: The model configuration.
        ///
        /// Parameter `handler`: When the compute plan is constructed successfully or unsuccessfully, the completion handler is invoked with a valid MLComputePlan instance or NSError object.
        #[unsafe(method(loadContentsOfURL:configuration:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadContentsOfURL_configuration_completionHandler(
            url: &NSURL,
            configuration: &MLModelConfiguration,
            handler: &block2::DynBlock<dyn Fn(*mut MLComputePlan, *mut NSError)>,
        );

        #[cfg(all(
            feature = "MLModelAsset",
            feature = "MLModelConfiguration",
            feature = "block2"
        ))]
        /// Construct the compute plan of a model asynchronously given the model asset.
        ///
        ///
        /// Parameter `asset`: The model asset.
        ///
        /// Parameter `configuration`: The model configuration.
        ///
        /// Parameter `handler`: When the compute plan is constructed successfully or unsuccessfully, the completion handler is invoked with a valid MLComputePlan instance or NSError object.
        #[unsafe(method(loadModelAsset:configuration:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadModelAsset_configuration_completionHandler(
            asset: &MLModelAsset,
            configuration: &MLModelConfiguration,
            handler: &block2::DynBlock<dyn Fn(*mut MLComputePlan, *mut NSError)>,
        );

        #[cfg(all(
            feature = "MLComputePlanCost",
            feature = "MLModelStructureProgramOperation"
        ))]
        /// Returns the estimated cost of executing an ML Program operation.
        ///
        ///
        /// Parameter `operation`: An ML Program operation.
        ///
        /// Returns: The estimated cost of executing the operation or nil if the cost couldn't be estimated.
        #[unsafe(method(estimatedCostOfMLProgramOperation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn estimatedCostOfMLProgramOperation(
            &self,
            operation: &MLModelStructureProgramOperation,
        ) -> Option<Retained<MLComputePlanCost>>;

        #[cfg(all(
            feature = "MLComputePlanDeviceUsage",
            feature = "MLModelStructureNeuralNetworkLayer"
        ))]
        /// Returns the anticipated compute devices that would be used for executing a NeuralNetwork layer.
        ///
        ///
        /// Parameter `layer`: A NeuralNetwork layer.
        ///
        /// Returns: The anticipated compute devices that would be used for executing the layer or `nil` if the usage couldn't be determined.
        #[unsafe(method(computeDeviceUsageForNeuralNetworkLayer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn computeDeviceUsageForNeuralNetworkLayer(
            &self,
            layer: &MLModelStructureNeuralNetworkLayer,
        ) -> Option<Retained<MLComputePlanDeviceUsage>>;

        #[cfg(all(
            feature = "MLComputePlanDeviceUsage",
            feature = "MLModelStructureProgramOperation"
        ))]
        /// Returns The anticipated compute devices that would be used for executing an ML Program operation.
        ///
        ///
        /// Parameter `operation`: An ML Program operation.
        ///
        /// Returns: The anticipated compute devices that would be used for executing the operation or `nil`if the usage couldn't be determined.
        #[unsafe(method(computeDeviceUsageForMLProgramOperation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn computeDeviceUsageForMLProgramOperation(
            &self,
            operation: &MLModelStructureProgramOperation,
        ) -> Option<Retained<MLComputePlanDeviceUsage>>;

        #[cfg(feature = "MLModelStructure")]
        /// The model structure.
        #[unsafe(method(modelStructure))]
        #[unsafe(method_family = none)]
        pub unsafe fn modelStructure(&self) -> Retained<MLModelStructure>;
    );
}
