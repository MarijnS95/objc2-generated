//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcswitchpositioninput?language=objc)
    pub unsafe trait GCSwitchPositionInput: NSObjectProtocol {
        #[cfg(all(feature = "GCPhysicalInputElement", feature = "block2"))]
        /// Set this block if you want to be notified when the value on the switch changes.
        ///
        ///
        /// Parameter `input`: the element that has been modified.
        ///
        /// See: value
        #[method(positionDidChangeHandler)]
        unsafe fn positionDidChangeHandler(
            &self,
        ) -> *mut block2::Block<
            dyn Fn(
                NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                NonNull<ProtocolObject<dyn GCSwitchPositionInput>>,
                NSInteger,
            ),
        >;

        #[cfg(all(feature = "GCPhysicalInputElement", feature = "block2"))]
        /// Setter for [`positionDidChangeHandler`][Self::positionDidChangeHandler].
        #[method(setPositionDidChangeHandler:)]
        unsafe fn setPositionDidChangeHandler(
            &self,
            position_did_change_handler: Option<
                &block2::Block<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                        NonNull<ProtocolObject<dyn GCSwitchPositionInput>>,
                        NSInteger,
                    ),
                >,
            >,
        );

        /// The switch's position.
        ///
        ///
        /// See: valueDidChangeHandler
        #[method(position)]
        unsafe fn position(&self) -> NSInteger;

        /// The (inclusive) bounds of possible position values for the switch.
        #[method(positionRange)]
        unsafe fn positionRange(&self) -> NSRange;

        /// `YES`if the switch input can only transition to positions that are adjacent
        /// to the current position.
        #[method(isSequential)]
        unsafe fn isSequential(&self) -> bool;

        /// Check if the position input value can "roll over" when reaching either of its
        /// bounds.
        ///
        /// This will always be
        /// `YES`for non-sequential switch inputs.
        #[method(canWrap)]
        unsafe fn canWrap(&self) -> bool;

        /// The timestamp of the last value.
        ///
        /// This time interval is not relative to any specific point in time.  You can
        /// subtract a previous timestamp from the returned timestamp to determine the time
        /// (in seconds) between changes to the value.
        #[method(lastPositionTimestamp)]
        unsafe fn lastPositionTimestamp(&self) -> NSTimeInterval;

        /// The interval (in seconds) between the timestamp of the last event and the
        /// current time.
        ///
        /// This should be treated as a lower bound of the event latency.  It may not
        /// include (wired or wireless) transmission latency, or latency accrued on
        /// the device before the event was transmitted to the host.
        #[method(lastPositionLatency)]
        unsafe fn lastPositionLatency(&self) -> NSTimeInterval;

        #[cfg(feature = "GCPhysicalInputSource")]
        /// An object describing the physical action(s) the user performs to manipulate
        /// this input.
        #[method_id(@__retain_semantics Other sources)]
        unsafe fn sources(&self) -> Retained<NSSet<ProtocolObject<dyn GCPhysicalInputSource>>>;
    }

    unsafe impl ProtocolType for dyn GCSwitchPositionInput {}
);
