//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Set this block if you want to be notified when a value on a element changed. If multiple elements have changed this block will be called
/// for each element that changed. As elements in a collection, such as the axis in a dpad, tend to change at the same time and thus
/// will only call this once with the collection as the element.
///
///
/// Parameter `gamepad`: this gamepad that is being used to map the raw input data into logical values on controller elements such as the dpad or the buttons.
///
/// Parameter `element`: the element that has been modified.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcextendedgamepadvaluechangedhandler?language=objc)
#[cfg(all(
    feature = "GCControllerElement",
    feature = "GCPhysicalInputProfile",
    feature = "block2"
))]
pub type GCExtendedGamepadValueChangedHandler =
    *mut block2::Block<dyn Fn(NonNull<GCExtendedGamepad>, NonNull<GCControllerElement>)>;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad?language=objc)
    #[unsafe(super(GCPhysicalInputProfile, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "GCPhysicalInputProfile")]
    pub struct GCExtendedGamepad;
);

#[cfg(feature = "GCPhysicalInputProfile")]
unsafe impl NSObjectProtocol for GCExtendedGamepad {}

extern_methods!(
    #[cfg(feature = "GCPhysicalInputProfile")]
    unsafe impl GCExtendedGamepad {
        #[cfg(feature = "GCController")]
        #[method(controller)]
        #[unsafe(method_family = none)]
        pub unsafe fn controller(&self) -> Option<Retained<GCController>>;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        #[method(valueChangedHandler)]
        #[unsafe(method_family = none)]
        pub unsafe fn valueChangedHandler(&self) -> GCExtendedGamepadValueChangedHandler;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        /// Setter for [`valueChangedHandler`][Self::valueChangedHandler].
        #[method(setValueChangedHandler:)]
        #[unsafe(method_family = none)]
        pub unsafe fn setValueChangedHandler(
            &self,
            value_changed_handler: GCExtendedGamepadValueChangedHandler,
        );

        #[cfg(feature = "GCExtendedGamepadSnapshot")]
        /// Polls the state vector of the controller and saves it to a snapshot. The snapshot is stored in a device independent
        /// format that can be serialized and used at a later date. This is useful for features such as quality assurance,
        /// save game or replay functionality among many.
        ///
        /// If your application is heavily multithreaded this may also be useful to guarantee atomicity of input handling as
        /// a snapshot will not change based on user input once it is taken.
        #[deprecated = "GCExtendedGamepadSnapshot has been deprecated, use [GCController capture] instead"]
        #[method(saveSnapshot)]
        #[unsafe(method_family = none)]
        pub unsafe fn saveSnapshot(&self) -> Retained<GCExtendedGamepadSnapshot>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        /// Required to be analog in the Extended profile. All the elements of this directional input are thus analog.
        #[method(dpad)]
        #[unsafe(method_family = none)]
        pub unsafe fn dpad(&self) -> Retained<GCControllerDirectionPad>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// All face buttons are required to be analog in the Extended profile. These must be arranged
        /// in the diamond pattern given below:
        ///
        /// Y
        /// /
        /// \
        /// X   B
        /// \
        /// /
        /// A
        #[method(buttonA)]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonA(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[method(buttonB)]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonB(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[method(buttonX)]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonX(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[method(buttonY)]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonY(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button menu is the primary menu button, and should be used to enter the main menu and pause the game.
        #[method(buttonMenu)]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonMenu(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button options is the secondary menu button. It should be used to enter a secondary menu, such as graphics and sound configuration, and pause the game.
        #[method(buttonOptions)]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonOptions(&self) -> Option<Retained<GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button home is a special menu button. If the system does not consume button home events, they will be passed to your application and should be used to enter a secondary menu, and pause the game.
        #[method(buttonHome)]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonHome(&self) -> Option<Retained<GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        /// A thumbstick is a 2-axis control that is physically required to be analog. All the elements of this directional input are thus analog.
        #[method(leftThumbstick)]
        #[unsafe(method_family = none)]
        pub unsafe fn leftThumbstick(&self) -> Retained<GCControllerDirectionPad>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        /// A thumbstick is a 2-axis control that is physically required to be analog. All the elements of this directional input are thus analog.
        #[method(rightThumbstick)]
        #[unsafe(method_family = none)]
        pub unsafe fn rightThumbstick(&self) -> Retained<GCControllerDirectionPad>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Shoulder buttons are required to be analog inputs.
        #[method(leftShoulder)]
        #[unsafe(method_family = none)]
        pub unsafe fn leftShoulder(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Shoulder buttons are required to be analog inputs.
        #[method(rightShoulder)]
        #[unsafe(method_family = none)]
        pub unsafe fn rightShoulder(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Triggers are required to be analog inputs. Common uses would be acceleration and decelleration in a driving game for example.
        #[method(leftTrigger)]
        #[unsafe(method_family = none)]
        pub unsafe fn leftTrigger(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[method(rightTrigger)]
        #[unsafe(method_family = none)]
        pub unsafe fn rightTrigger(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// A thumbstick may also have a clickable component, which is treated as a non-analog button.
        #[method(leftThumbstickButton)]
        #[unsafe(method_family = none)]
        pub unsafe fn leftThumbstickButton(&self) -> Option<Retained<GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[method(rightThumbstickButton)]
        #[unsafe(method_family = none)]
        pub unsafe fn rightThumbstickButton(&self) -> Option<Retained<GCControllerButtonInput>>;

        /// Sets the state vector of the extended gamepad to a copy of the input extended gamepad's state vector.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: GCController.snapshot
        #[method(setStateFromExtendedGamepad:)]
        #[unsafe(method_family = none)]
        pub unsafe fn setStateFromExtendedGamepad(&self, extended_gamepad: &GCExtendedGamepad);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "GCPhysicalInputProfile")]
    unsafe impl GCExtendedGamepad {
        #[method(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
