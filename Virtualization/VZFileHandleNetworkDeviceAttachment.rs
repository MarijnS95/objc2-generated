//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Network device attachment sending raw network packets over a file handle.
    ///
    /// The file handle attachment transmits the raw packets/frames between the virtual network interface and a file handle.
    /// The data transmitted through this attachment is at the level of the data link layer.
    ///
    /// The file handle must hold a connected datagram socket.
    ///
    ///
    /// See: VZNetworkDeviceConfiguration
    ///
    /// See: VZVirtioNetworkDeviceConfiguration
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/virtualization/vzfilehandlenetworkdeviceattachment?language=objc)
    #[unsafe(super(VZNetworkDeviceAttachment, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "VZNetworkDeviceAttachment")]
    pub struct VZFileHandleNetworkDeviceAttachment;
);

#[cfg(feature = "VZNetworkDeviceAttachment")]
unsafe impl NSObjectProtocol for VZFileHandleNetworkDeviceAttachment {}

extern_methods!(
    #[cfg(feature = "VZNetworkDeviceAttachment")]
    unsafe impl VZFileHandleNetworkDeviceAttachment {
        /// Initialize the attachment with a file handle.
        ///
        /// Parameter `fileHandle`: File handle holding a connected datagram socket.
        #[unsafe(method(initWithFileHandle:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFileHandle(
            this: Allocated<Self>,
            file_handle: &NSFileHandle,
        ) -> Retained<Self>;

        /// The file handle associated with this attachment.
        #[unsafe(method(fileHandle))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileHandle(&self) -> Retained<NSFileHandle>;

        /// The maximum transmission unit (MTU) associated with this attachment.
        ///
        /// The client side of the associated datagram socket must be properly configured with the appropriate values for
        /// `SO_SNDBUF`, and `SO_RCVBUF`, which can be set using the `setsockopt` system call. The value of `SO_RCVBUF` is
        /// expected to be at least double the value of `SO_SNDBUF`, and for optimal performance, the value of `SO_RCVBUF`
        /// is recommended to be four times the value of `SO_SNDBUF`.
        ///
        /// The default MTU is 1500.
        /// The maximum MTU allowed is 65535, and the minimum MTU allowed is 1500. An invalid MTU value will result in an invalid
        /// virtual machine configuration.
        #[unsafe(method(maximumTransmissionUnit))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumTransmissionUnit(&self) -> NSInteger;

        /// Setter for [`maximumTransmissionUnit`][Self::maximumTransmissionUnit].
        #[unsafe(method(setMaximumTransmissionUnit:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumTransmissionUnit(&self, maximum_transmission_unit: NSInteger);
    }
);

extern_methods!(
    /// Methods declared on superclass `VZNetworkDeviceAttachment`
    #[cfg(feature = "VZNetworkDeviceAttachment")]
    unsafe impl VZFileHandleNetworkDeviceAttachment {
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);
