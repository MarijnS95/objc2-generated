//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Directory share for multiple directories.
    ///
    /// This directory share exposes multiple directories from the host file system to the guest.
    ///
    /// See: VZDirectorySharingDeviceConfiguration
    ///
    /// See: VZSharedDirectory
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/virtualization/vzmultipledirectoryshare?language=objc)
    #[unsafe(super(VZDirectoryShare, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "VZDirectoryShare")]
    pub struct VZMultipleDirectoryShare;
);

#[cfg(feature = "VZDirectoryShare")]
unsafe impl NSObjectProtocol for VZMultipleDirectoryShare {}

extern_methods!(
    #[cfg(feature = "VZDirectoryShare")]
    unsafe impl VZMultipleDirectoryShare {
        /// Initialize the directory share with an empty set of directories.
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "VZSharedDirectory")]
        /// Initialize the directory share with a set of directories on the host.
        ///
        /// Parameter `directories`: Directories on the host to expose to the guest by name.
        ///
        /// The dictionary string keys will be the name for the directory. The keys must be valid names or an exception will be raised.
        ///
        /// See: +[VZMultipleDirectoryShare validateName:error:]
        #[method_id(@__method_family Init initWithDirectories:)]
        pub unsafe fn initWithDirectories(
            this: Allocated<Self>,
            directories: &NSDictionary<NSString, VZSharedDirectory>,
        ) -> Retained<Self>;

        #[cfg(feature = "VZSharedDirectory")]
        /// The directories on the host to expose to the guest.
        ///
        /// The dictionary string keys will be the name for the directory. The keys must be valid names or an exception will be raised.
        ///
        /// See: +[VZMultipleDirectoryShare validateName:error:]
        #[method_id(@__method_family Other directories)]
        pub unsafe fn directories(&self) -> Retained<NSDictionary<NSString, VZSharedDirectory>>;

        /// Check if a name is a valid directory name.
        ///
        /// Parameter `name`: The name to validate.
        ///
        /// Parameter `error`: If not nil, assigned with an error describing why the name is not valid.
        ///
        /// The name must not be empty, have characters unsafe for file systems, be longer than NAME_MAX, or other restrictions.
        ///
        /// See: +[VZMultipleDirectoryShare canonicalizedNameFromName:]
        #[method(validateName:error:_)]
        pub unsafe fn validateName_error(name: &NSString) -> Result<(), Retained<NSError>>;

        /// Canonicalize a string to be a valid directory name.
        ///
        /// Parameter `name`: The name to canonicalize.
        ///
        /// This returns nil when it cannot produce a valid name. When not nil, the result is a valid directory name.
        ///
        /// See: +[VZMultipleDirectoryShare validateName:error:]
        #[method_id(@__method_family Other canonicalizedNameFromName:)]
        pub unsafe fn canonicalizedNameFromName(name: &NSString) -> Option<Retained<NSString>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `VZDirectoryShare`
    #[cfg(feature = "VZDirectoryShare")]
    unsafe impl VZMultipleDirectoryShare {
        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
