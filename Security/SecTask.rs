//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

/// CFType used for representing a task
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/sectask?language=objc)
#[repr(C)]
pub struct SecTask {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__SecTask"]
    unsafe impl SecTask {}
);

unsafe impl ConcreteType for SecTask {
    /// Returns the type ID for CF instances of SecTask.
    ///
    /// Returns: A CFTypeID for SecTask
    #[doc(alias = "SecTaskGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecTaskGetTypeID() -> CFTypeID;
        }
        unsafe { SecTaskGetTypeID() }
    }
}

/// Create a SecTask object for the current task.
///
/// Returns: The newly created SecTask object or NULL on error.  The caller must
/// CFRelease the returned object.
/// #ifndef LEFT
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCreateFromSelf(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<SecTask>> {
    extern "C-unwind" {
        fn SecTaskCreateFromSelf(allocator: Option<&CFAllocator>) -> *mut SecTask;
    }
    let ret = unsafe { SecTaskCreateFromSelf(allocator) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns the value of a single entitlement for the represented
/// task.
///
/// Parameter `task`: A previously created SecTask object
///
/// Parameter `entitlement`: The name of the entitlement to be fetched
///
/// Parameter `error`: On a NULL return, this may be contain a CFError describing
/// the problem.  This argument may be NULL if the caller is not interested in
/// detailed errors.
///
/// Returns: The value of the specified entitlement for the process or NULL if
/// the entitlement value could not be retrieved.  The type of the returned
/// value will depend on the entitlement specified.  The caller must release
/// the returned object.
///
/// A NULL return may indicate an error, or it may indicate that
/// the entitlement is simply not present.  In the latter case, no CFError is
/// returned.
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCopyValueForEntitlement(
    task: &SecTask,
    entitlement: &CFString,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn SecTaskCopyValueForEntitlement(
            task: &SecTask,
            entitlement: &CFString,
            error: *mut *mut CFError,
        ) -> *mut CFType;
    }
    let ret = unsafe { SecTaskCopyValueForEntitlement(task, entitlement, error) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns the values of multiple entitlements for the represented
/// task.
///
/// Parameter `task`: A previously created SecTask object
///
/// Parameter `entitlements`: An array of entitlement names to be fetched
///
/// Parameter `error`: On a NULL return, this will contain a CFError describing
/// the problem.  This argument may be NULL if the caller is not interested in
/// detailed errors.  If a requested entitlement is not present for the
/// returned dictionary, the entitlement is not set on the task.  The caller
/// must CFRelease the returned value
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCopyValuesForEntitlements(
    task: &SecTask,
    entitlements: &CFArray,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn SecTaskCopyValuesForEntitlements(
            task: &SecTask,
            entitlements: &CFArray,
            error: *mut *mut CFError,
        ) -> *mut CFDictionary;
    }
    let ret = unsafe { SecTaskCopyValuesForEntitlements(task, entitlements, error) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Return the value of the codesigning identifier.
///
/// Parameter `task`: A previously created SecTask object
///
/// Parameter `error`: On a NULL return, this will contain a CFError describing
/// the problem.  This argument may be NULL if the caller is not interested in
/// detailed errors. The caller must CFRelease the returned value
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCopySigningIdentifier(
    task: &SecTask,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SecTaskCopySigningIdentifier(task: &SecTask, error: *mut *mut CFError) -> *mut CFString;
    }
    let ret = unsafe { SecTaskCopySigningIdentifier(task, error) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Return the code sign status flags
    ///
    /// Parameter `task`: A previously created SecTask object
    pub fn SecTaskGetCodeSignStatus(task: &SecTask) -> u32;
}
