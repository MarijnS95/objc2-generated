//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// An enumeration of container state values.
///
/// This enumeration represents values for a container's state engine.
/// Containers start in the ``notReady`` state.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fscontainerstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSContainerState(pub NSInteger);
impl FSContainerState {
    /// The container isn't ready.
    #[doc(alias = "FSContainerStateNotReady")]
    pub const NotReady: Self = Self(0);
    /// The container is blocked from transitioning from the not-ready state to the ready state by a potentially-recoverable error.
    ///
    /// This state implies that the error has a resolution that would allow the container to become ready, such as correcting an incorrect password.
    #[doc(alias = "FSContainerStateBlocked")]
    pub const Blocked: Self = Self(1);
    /// The container is ready, but inactive.
    #[doc(alias = "FSContainerStateReady")]
    pub const Ready: Self = Self(2);
    /// The container is active, and one or more volumes are active.
    #[doc(alias = "FSContainerStateActive")]
    pub const Active: Self = Self(3);
}

unsafe impl Encode for FSContainerState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for FSContainerState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A type that represents a container's status.
    ///
    /// This type contains two properties:
    ///
    /// * The ``state`` value that indicates the state of the container, such as ``FSContainerState/ready`` or ``FSContainerState/blocked``.
    /// * The ``status`` is an error (optional in Swift, nullable in Objective-C) that provides further information about the state, such as why the container is blocked.
    ///
    /// Examples of statuses that require intervention include errors that indicate the container isn't ready (POSIX `EAGAIN` or `ENOTCONN`), the container needs authentication (`ENEEDAUTH`), or that authentication failed (`EAUTH`).
    /// The status can also be an informative error, such as the FSKit error ``FSErrorStatusOperationInProgress``, possibly with the variant information of ``FSKitErrorVariantCheckStatus`` or ``FSKitErrorVariantFormatStatus``.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fscontainerstatus?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSContainerStatus;
);

extern_conformance!(
    unsafe impl NSCopying for FSContainerStatus {}
);

unsafe impl CopyingHelper for FSContainerStatus {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for FSContainerStatus {}
);

impl FSContainerStatus {
    extern_methods!(
        /// A value that represents the container state, such as ready, active, or blocked.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> FSContainerState;

        /// An optional error that provides further information about the state.
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> Option<Retained<NSError>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// A status that represents an active container with no error.
        ///
        /// This value is a ``FSContainerStatus`` with a ``state`` that is ``active``, and has a ``status`` that is `nil`.
        #[unsafe(method(active))]
        #[unsafe(method_family = none)]
        pub unsafe fn active() -> Retained<FSContainerStatus>;

        /// Returns a active container status instance with the provided error status.
        ///
        /// - Parameter errorStatus: The error status, if any, for the new instance.
        #[unsafe(method(activeWithStatus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn activeWithStatus(error_status: &NSError) -> Retained<Self>;

        /// Returns a blocked container status instance with the provided error status.
        ///
        /// - Parameter errorStatus: The error status, if any, for the new instance.
        #[unsafe(method(blockedWithStatus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn blockedWithStatus(error_status: &NSError) -> Retained<Self>;

        /// Returns a not-ready container status instance with the provided error status.
        ///
        /// - Parameter errorStatus: The error status, if any, for the new instance.
        #[unsafe(method(notReadyWithStatus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn notReadyWithStatus(error_status: &NSError) -> Retained<Self>;

        /// A status that represents a ready container with no error.
        ///
        /// This value is a ``FSContainerStatus`` with a ``state`` that is ``ready``, and a ``status`` that is `nil`.
        #[unsafe(method(ready))]
        #[unsafe(method_family = none)]
        pub unsafe fn ready() -> Retained<FSContainerStatus>;

        /// Returns a ready container status instance with the provided error status.
        ///
        /// - Parameter errorStatus: The error status, if any, for the new instance.
        #[unsafe(method(readyWithStatus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readyWithStatus(error_status: &NSError) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSContainerStatus {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A type that identifies a container.
    ///
    /// The identifier is either a UUID or a UUID with additional differentiating bytes.
    /// Some network protocols evaluate access based on a user ID when connecting.
    /// In this situation, when a file server receives multiple client connections with different user IDs, the server provides different file hierarchies to each.
    /// For such systems, represent the container identifier as the UUID associated with the server, followed by four or eight bytes to differentiate connections.
    ///
    /// > Important: Don't subclass this class.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fscontaineridentifier?language=objc)
    #[unsafe(super(FSEntityIdentifier, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "FSEntityIdentifier")]
    pub struct FSContainerIdentifier;
);

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSCoding for FSContainerIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSCopying for FSContainerIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
unsafe impl CopyingHelper for FSContainerIdentifier {
    type Result = Self;
}

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSObjectProtocol for FSContainerIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSSecureCoding for FSContainerIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
impl FSContainerIdentifier {
    extern_methods!(
        #[cfg(feature = "FSVolume")]
        /// The volume identifier associated with the container.
        ///
        /// For unary file systems, the volume identifier is the same as the container identifier.
        #[unsafe(method(volumeIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn volumeIdentifier(&self) -> Retained<FSVolumeIdentifier>;
    );
}

/// Methods declared on superclass `FSEntityIdentifier`.
#[cfg(feature = "FSEntityIdentifier")]
impl FSContainerIdentifier {
    extern_methods!(
        /// Creates an entity identifier with a random UUID.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates an entity identifier with the given UUID.
        ///
        /// - Parameter uuid: The UUID to use for this identifier.
        #[unsafe(method(initWithUUID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUUID(this: Allocated<Self>, uuid: &NSUUID) -> Retained<Self>;

        /// Creates an entity identifier with the given UUID and qualifier data as a 64-bit unsigned integer.
        /// - Parameters:
        /// - uuid: The UUID to use for this identifier.
        /// - qualifier: The data to distinguish entities that otherwise share the same UUID.
        #[unsafe(method(initWithUUID:qualifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUUID_qualifier(
            this: Allocated<Self>,
            uuid: &NSUUID,
            qualifier: u64,
        ) -> Retained<Self>;

        /// Creates an entity identifier with the given UUID and qualifier data.
        ///
        /// - Parameters:
        /// - uuid: The UUID to use for this identifier.
        /// - qualifierData: The data to distinguish entities that otherwise share the same UUID.
        #[unsafe(method(initWithUUID:data:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUUID_data(
            this: Allocated<Self>,
            uuid: &NSUUID,
            qualifier_data: &NSData,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "FSEntityIdentifier")]
impl FSContainerIdentifier {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
