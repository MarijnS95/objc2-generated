//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// A constant identifying the type of a JSValue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jstype?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct JSType(pub c_uint);
impl JSType {
    #[doc(alias = "kJSTypeUndefined")]
    pub const Undefined: Self = Self(0);
    #[doc(alias = "kJSTypeNull")]
    pub const Null: Self = Self(1);
    #[doc(alias = "kJSTypeBoolean")]
    pub const Boolean: Self = Self(2);
    #[doc(alias = "kJSTypeNumber")]
    pub const Number: Self = Self(3);
    #[doc(alias = "kJSTypeString")]
    pub const String: Self = Self(4);
    #[doc(alias = "kJSTypeObject")]
    pub const Object: Self = Self(5);
    #[doc(alias = "kJSTypeSymbol")]
    pub const Symbol: Self = Self(6);
    #[doc(alias = "kJSTypeBigInt")]
    pub const BigInt: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A constant identifying the Typed Array type of a JSObjectRef.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jstypedarraytype?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct JSTypedArrayType(pub c_uint);
impl JSTypedArrayType {
    #[doc(alias = "kJSTypedArrayTypeInt8Array")]
    pub const Int8Array: Self = Self(0);
    #[doc(alias = "kJSTypedArrayTypeInt16Array")]
    pub const Int16Array: Self = Self(1);
    #[doc(alias = "kJSTypedArrayTypeInt32Array")]
    pub const Int32Array: Self = Self(2);
    #[doc(alias = "kJSTypedArrayTypeUint8Array")]
    pub const Uint8Array: Self = Self(3);
    #[doc(alias = "kJSTypedArrayTypeUint8ClampedArray")]
    pub const Uint8ClampedArray: Self = Self(4);
    #[doc(alias = "kJSTypedArrayTypeUint16Array")]
    pub const Uint16Array: Self = Self(5);
    #[doc(alias = "kJSTypedArrayTypeUint32Array")]
    pub const Uint32Array: Self = Self(6);
    #[doc(alias = "kJSTypedArrayTypeFloat32Array")]
    pub const Float32Array: Self = Self(7);
    #[doc(alias = "kJSTypedArrayTypeFloat64Array")]
    pub const Float64Array: Self = Self(8);
    #[doc(alias = "kJSTypedArrayTypeArrayBuffer")]
    pub const ArrayBuffer: Self = Self(9);
    #[doc(alias = "kJSTypedArrayTypeNone")]
    pub const None: Self = Self(10);
    #[doc(alias = "kJSTypedArrayTypeBigInt64Array")]
    pub const BigInt64Array: Self = Self(11);
    #[doc(alias = "kJSTypedArrayTypeBigUint64Array")]
    pub const BigUint64Array: Self = Self(12);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSTypedArrayType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSTypedArrayType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A constant identifying the type of JavaScript relation condition.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jsrelationcondition?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct JSRelationCondition(pub u32);
impl JSRelationCondition {
    #[doc(alias = "kJSRelationConditionUndefined")]
    pub const Undefined: Self = Self(0);
    #[doc(alias = "kJSRelationConditionEqual")]
    pub const Equal: Self = Self(1);
    #[doc(alias = "kJSRelationConditionGreaterThan")]
    pub const GreaterThan: Self = Self(2);
    #[doc(alias = "kJSRelationConditionLessThan")]
    pub const LessThan: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSRelationCondition {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSRelationCondition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Returns a JavaScript value's type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue whose type you want to obtain.
    ///
    /// Returns: A value of type JSType that identifies value's type.
    #[cfg(feature = "JSBase")]
    pub fn JSValueGetType(ctx: JSContextRef, value: JSValueRef) -> JSType;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the undefined type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the undefined type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the null type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the null type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the boolean type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the boolean type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the number type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the number type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the string type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the string type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the symbol type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the symbol type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsSymbol(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the BigInt type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the BigInt type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsBigInt(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value's type is the object type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the object type, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value is an object with a given class in its class chain.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Parameter `jsClass`: The JSClass to test against.
    ///
    /// Returns: true if value is an object and has jsClass in its class chain, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsObjectOfClass(
        ctx: JSContextRef,
        value: JSValueRef,
        js_class: JSClassRef,
    ) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value is an array.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value is an array, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value is a date.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value is a date, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Returns a JavaScript value's Typed Array type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue whose Typed Array type to return.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of type JSTypedArrayType that identifies value's Typed Array type, or kJSTypedArrayTypeNone if the value is not a Typed Array object.
    #[cfg(feature = "JSBase")]
    pub fn JSValueGetTypedArrayType(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType;
}

extern "C-unwind" {
    /// Tests whether two JavaScript values are equal, as compared by the JS == operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `a`: The first value to test.
    ///
    /// Parameter `b`: The second value to test.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: true if the two values are equal, false if they are not equal or an exception is thrown.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsEqual(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}

extern "C-unwind" {
    /// Tests whether two JavaScript values are strict equal, as compared by the JS === operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `a`: The first value to test.
    ///
    /// Parameter `b`: The second value to test.
    ///
    /// Returns: true if the two values are strict equal, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Tests whether a JavaScript value is an object constructed by a given constructor, as compared by the JS instanceof operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Parameter `constructor`: The constructor to test against.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: true if value is an object constructed by constructor, as compared by the JS instanceof operator, otherwise false.
    #[cfg(feature = "JSBase")]
    pub fn JSValueIsInstanceOfConstructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool;
}

extern "C-unwind" {
    /// Compares two JSValues.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The JSValue as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// The result is computed by comparing the results of JavaScript's `==`, `
    /// <
    /// `, and `>` operators. If either `left` or `right` is (or would coerce to) `NaN` in JavaScript, then the result is kJSRelationConditionUndefined.
    #[cfg(feature = "JSBase")]
    pub fn JSValueCompare(
        ctx: JSContextRef,
        left: JSValueRef,
        right: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    /// Compares a JSValue with a signed 64-bit integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The int64_t as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    #[cfg(feature = "JSBase")]
    pub fn JSValueCompareInt64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: i64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    /// Compares a JSValue with an unsigned 64-bit integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The uint64_t as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    #[cfg(feature = "JSBase")]
    pub fn JSValueCompareUInt64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: u64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    /// Compares a JSValue with a double.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The double as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to a double according to the rules specified by the JavaScript language then compared with `right`.
    #[cfg(feature = "JSBase")]
    pub fn JSValueCompareDouble(
        ctx: JSContextRef,
        left: JSValueRef,
        right: c_double,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    /// Creates a JavaScript value of the undefined type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Returns: The unique undefined value.
    #[cfg(feature = "JSBase")]
    pub fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript value of the null type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Returns: The unique null value.
    #[cfg(feature = "JSBase")]
    pub fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript value of the boolean type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `boolean`: The bool to assign to the newly created JSValue.
    ///
    /// Returns: A JSValue of the boolean type, representing the value of boolean.
    #[cfg(feature = "JSBase")]
    pub fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript value of the number type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `number`: The double to assign to the newly created JSValue.
    ///
    /// Returns: A JSValue of the number type, representing the value of number.
    #[cfg(feature = "JSBase")]
    pub fn JSValueMakeNumber(ctx: JSContextRef, number: c_double) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript value of the string type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSString to assign to the newly created JSValue. The
    /// newly created JSValue retains string, and releases it upon garbage collection.
    ///
    /// Returns: A JSValue of the string type, representing the value of string.
    #[cfg(feature = "JSBase")]
    pub fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript value of the symbol type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `description`: A description of the newly created symbol value.
    ///
    /// Returns: A unique JSValue of the symbol type, whose description matches the one provided.
    #[cfg(feature = "JSBase")]
    pub fn JSValueMakeSymbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with a double.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The value to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the value, or NULL if an exception is thrown.
    ///
    /// If the value is not an integer, an exception is thrown.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithDouble(
        ctx: JSContextRef,
        value: c_double,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with a 64-bit signed integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `integer`: The 64-bit signed integer to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the integer, or NULL if an exception is thrown.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithInt64(
        ctx: JSContextRef,
        integer: i64,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with a 64-bit unsigned integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `integer`: The 64-bit unsigned integer to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the integer, or NULL if an exception is thrown.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithUInt64(
        ctx: JSContextRef,
        integer: u64,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with an integer represented in string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSStringRef representation of an integer.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the string, or NULL if an exception is thrown.
    ///
    /// This is equivalent to calling the `BigInt` constructor from JavaScript with a string argument.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithString(
        ctx: JSContextRef,
        string: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript value from a JSON formatted string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSString containing the JSON string to be parsed.
    ///
    /// Returns: A JSValue containing the parsed value, or NULL if the input is invalid.
    #[cfg(feature = "JSBase")]
    pub fn JSValueMakeFromJSONString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript string containing the JSON serialized representation of a JS value.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The value to serialize.
    ///
    /// Parameter `indent`: The number of spaces to indent when nesting.  If 0, the resulting JSON will not contains newlines.  The size of the indent is clamped to 10 spaces.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A JSString with the result of serialization, or NULL if an exception is thrown.
    #[cfg(feature = "JSBase")]
    pub fn JSValueCreateJSONString(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}

extern "C-unwind" {
    /// Converts a JavaScript value to boolean and returns the resulting boolean.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Returns: The boolean result of conversion.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    /// Converts a JavaScript value to number and returns the resulting number.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: The numeric result of conversion, or NaN if an exception is thrown.
    ///
    /// The result is equivalent to `Number(value)` in JavaScript.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToNumber(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> c_double;
}

extern "C-unwind" {
    /// Converts a JSValue to a singed 32-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: An int32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int32_t.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToInt32(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef) -> i32;
}

extern "C-unwind" {
    /// Converts a JSValue to an unsigned 32-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A uint32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint32_t.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToUInt32(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> u32;
}

extern "C-unwind" {
    /// Converts a JSValue to a singed 64-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: An int64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int64_t.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToInt64(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef) -> i64;
}

extern "C-unwind" {
    /// Converts a JSValue to an unsigned 64-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A uint64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint64_t.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToUInt64(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> u64;
}

extern "C-unwind" {
    /// Converts a JavaScript value to string and copies the result into a JavaScript string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A JSString with the result of conversion, or NULL if an exception is thrown. Ownership follows the Create Rule.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToStringCopy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}

extern "C-unwind" {
    /// Converts a JavaScript value to object and returns the resulting object.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: The JSObject result of conversion, or NULL if an exception is thrown.
    #[cfg(feature = "JSBase")]
    pub fn JSValueToObject(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}

extern "C-unwind" {
    /// Protects a JavaScript value from garbage collection.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to protect.
    ///
    /// Use this method when you want to store a JSValue in a global or on the heap, where the garbage collector will not be able to discover your reference to it.
    ///
    /// A value may be protected multiple times and must be unprotected an equal number of times before becoming eligible for garbage collection.
    #[cfg(feature = "JSBase")]
    pub fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);
}

extern "C-unwind" {
    /// Unprotects a JavaScript value from garbage collection.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to unprotect.
    ///
    /// A value may be protected multiple times and must be unprotected an
    /// equal number of times before becoming eligible for garbage collection.
    #[cfg(feature = "JSBase")]
    pub fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
}
