//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-io-kit")]
use objc2_io_kit::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostinteresthandler?language=objc)
#[cfg(feature = "block2")]
pub type IOUSBHostInterestHandler =
    *mut block2::Block<dyn Fn(NonNull<IOUSBHostObject>, u32, *mut c_void)>;

extern_class!(
    /// The Abstract class IOUSBHostDevice and IOUSBHostInterface derive from.
    ///
    /// Defines common methods that are shared between IOUSBHostDevice and IOUSBHostInterface including instance
    /// management.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostobject?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOUSBHostObject;
);

unsafe impl NSObjectProtocol for IOUSBHostObject {}

impl IOUSBHostObject {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Removes underlying allocations of the IOUSBHostObject object along with user client
        ///
        /// When the IOUSBHostObject is no longer needed, destroy must be called. This will destroy
        /// the connection with the user client and de-register interest on the service. If the object
        /// is free'd destroy will be called automatically. Calling destroy multiple times has no effect.
        #[unsafe(method(destroy))]
        #[unsafe(method_family = none)]
        pub unsafe fn destroy(&self);

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Removes underlying allocations of the IOUSBHostObject object along with user client
        ///
        /// Extends
        /// <code>
        /// destroy
        /// </code>
        /// to take an options to modify the destroy behavior.  Currently only the
        /// <code>
        /// IOUSBHostObjectDestroyOptionsDeviceSurrender
        /// </code>
        /// is defined to support surrendering ownersip of
        /// the kernel service.  To be used when accepting the
        /// <code>
        /// kUSBHostMessageDeviceIsRequestingClose
        /// </code>
        /// message.
        #[unsafe(method(destroyWithOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn destroyWithOptions(&self, options: IOUSBHostObjectDestroyOptions);

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve the IOUSBHostObject's io_service_t.
        #[unsafe(method(ioService))]
        #[unsafe(method_family = none)]
        pub unsafe fn ioService(&self) -> io_service_t;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on the default control endpoint
        ///
        /// This method will send a synchronous request on the default control endpoint, and
        /// will not return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `bytesTransferred`: Optional NSUInteger reference which will be updated with the byte
        /// count of the completed data phase.
        ///
        /// Parameter `completionTimeout`: Timeout of the request. If 0, the request will never timeout. By
        /// default this value is IOUSBHostDefaultControlCompletionTimeout.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(sendDeviceRequest:data:bytesTransferred:completionTimeout:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDeviceRequest_data_bytesTransferred_completionTimeout_error(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
            completion_timeout: NSTimeInterval,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on the default control endpoint
        ///
        /// This method will send a synchronous request on the default control endpoint, and
        /// will not return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `bytesTransferred`: Optional NSUInteger reference which will be updated with the byte
        /// count of the completed data phase.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(sendDeviceRequest:data:bytesTransferred:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDeviceRequest_data_bytesTransferred_error(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on the default control endpoint
        ///
        /// This method will send a synchronous request on the default control endpoint, and
        /// will not return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(sendDeviceRequest:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDeviceRequest_error(
            &self,
            request: IOUSBDeviceRequest,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on the default control endpoint
        ///
        /// This method will enqueue an asynchronous request on the default control endpoint.
        /// If successful, the provided completionHandler will be called to report the status
        /// of the completed IO.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `completionTimeout`: Timeout of the request. If 0, the request will never timeout. By
        /// default this value is IOUSBHostDefaultControlCompletionTimeout
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(enqueueDeviceRequest:data:completionTimeout:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueDeviceRequest_data_completionTimeout_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            completion_timeout: NSTimeInterval,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on the default control endpoint
        ///
        /// This method will enqueue an asynchronous request on the default control endpoint.
        /// If successful, the provided completionHandler will be called to report the status
        /// of the completed IO.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(enqueueDeviceRequest:data:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueDeviceRequest_data_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on the default control endpoint
        ///
        /// This method will enqueue an asynchronous request on the default control endpoint.
        /// If successful, the provided completionHandler will be called to report the status
        /// of the completed IO.
        /// default this value is IOUSBHostDefaultControlCompletionTimeout
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(enqueueDeviceRequest:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueDeviceRequest_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Abort device requests
        ///
        /// This method will abort any requests made via the
        ///
        /// ```text
        ///  sendDeviceRequest
        /// ```
        ///
        /// and
        ///
        /// ```text
        ///  enqueueDeviceRequest
        /// ```
        ///
        /// methods.
        ///
        /// Parameter `option`: IOUSBHostAbortOption by default IOUSBHostAbortOptionSynchronous is used
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortDeviceRequestsWithOption:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortDeviceRequestsWithOption_error(
            &self,
            option: IOUSBHostAbortOption,
        ) -> Result<(), Retained<NSError>>;

        /// Abort device requests
        ///
        /// This method will abort any requests made via the
        ///
        /// ```text
        ///  sendDeviceRequest
        /// ```
        ///
        /// and
        ///
        /// ```text
        ///  enqueueDeviceRequest
        /// ```
        ///
        /// methods.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortDeviceRequestsWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortDeviceRequestsWithError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Return the device descriptor
        ///
        /// This method uses descriptorWithType to retrieve the device descriptor.
        ///
        /// Returns: Pointer to the device descriptor.
        #[unsafe(method(deviceDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceDescriptor(&self) -> *const IOUSBDeviceDescriptor;

        #[cfg(feature = "objc2-io-kit")]
        /// Return the capability descriptors of the device
        ///
        /// This method uses descriptorWithType to return the device's BOS descriptors
        ///
        /// Returns: Pointer to the BOS descriptor if found, otherwise nil.
        #[unsafe(method(capabilityDescriptors))]
        #[unsafe(method_family = none)]
        pub unsafe fn capabilityDescriptors(&self) -> *const IOUSBBOSDescriptor;

        /// Returns the string from a string descriptor
        ///
        /// This method uses descriptorWithType to retrieve the string descriptor.
        ///
        /// Parameter `index`: Descriptor index value.  Low byte of
        /// <code>
        /// wValue
        /// </code>
        /// of the
        /// SET_DESCRIPTOR control request (USB 2.0 9.4.8).
        ///
        /// Parameter `languageID`: Descriptor language ID.
        /// <code>
        /// wIndex
        /// </code>
        /// of the SET_DESCRIPTOR
        /// control request (USB 2.0 9.4.8). By default this value is kLanguageIDEnglishUS
        ///
        /// Returns: NSString reference to string from descriptor, an IOReturn error code will be reported on
        /// failure.
        #[unsafe(method(stringWithIndex:languageID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithIndex_languageID_error(
            &self,
            index: NSUInteger,
            language_id: NSUInteger,
        ) -> Result<Retained<NSString>, Retained<NSError>>;

        /// Returns the string from a string descriptor
        ///
        /// This method uses descriptorWithType to retrieve the string descriptor.
        ///
        /// Parameter `index`: Descriptor index value.  Low byte of
        /// <code>
        /// wValue
        /// </code>
        /// of the
        /// SET_DESCRIPTOR control request (USB 2.0 9.4.8).
        ///
        /// Returns: NSString reference to string from descriptor, an IOReturn error code will be reported on
        /// failure.
        #[unsafe(method(stringWithIndex:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithIndex_error(
            &self,
            index: NSUInteger,
        ) -> Result<Retained<NSString>, Retained<NSError>>;

        /// Retrieve the current address of the device.
        #[unsafe(method(deviceAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceAddress(&self) -> NSUInteger;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Return the current frame number of the USB controller
        ///
        /// This method will return the current frame number of the USB controller,
        /// omitting micro frame.  This is most useful for scheduling future isochronous
        /// requests.
        ///
        /// Parameter `time`: If not nil, this will be updated with the current system time
        ///
        /// Returns: The current frame number
        #[unsafe(method(frameNumberWithTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn frameNumberWithTime(&self, time: *mut IOUSBHostTime) -> u64;

        /// Allocate a buffer to be used for I/O
        ///
        /// This method will allocate and map an IOBufferMemoryDescriptor optimized for use
        /// by the underlying controller hardware. A buffer allocated by this method will not
        /// be bounced to perform DMA operations.
        /// Because the NSMutableData is backed by kernel memory, the length and capacity are
        /// not mutable. Any changes to the length or capacity will cause an exception to be
        /// thrown.
        ///
        /// Parameter `capacity`: Size of the buffer to allocate
        ///
        /// Returns: NSMutableData of memory mapped to user space of an IOBufferMemoryDescriptor if successful,
        /// otherwise nil. An IOReturn error code will be reported on failure. The result is
        /// to be released by the caller
        #[unsafe(method(ioDataWithCapacity:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn ioDataWithCapacity_error(
            &self,
            capacity: NSUInteger,
        ) -> Result<Retained<NSMutableData>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOUSBHostObject {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
