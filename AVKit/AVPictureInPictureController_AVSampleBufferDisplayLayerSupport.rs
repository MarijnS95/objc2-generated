//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-av-foundation")]
use objc2_av_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;

use crate::*;

#[cfg(feature = "AVPictureInPictureController")]
impl AVPictureInPictureController {
    extern_methods!(
        /// Informs Picture in Picture controller that it should request an updated playback state from its sampleBufferPlaybackDelegate.
        ///
        /// This should always be called whenever playback is paused or unpaused, or the underlying content duration changes.
        #[unsafe(method(invalidatePlaybackState))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidatePlaybackState(&self);
    );
}

extern_protocol!(
    /// A protocol for controlling playback from an AVSampleBufferDisplayLayer in Picture in Picture.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avkit/avpictureinpicturesamplebufferplaybackdelegate?language=objc)
    pub unsafe trait AVPictureInPictureSampleBufferPlaybackDelegate:
        NSObjectProtocol
    {
        #[cfg(feature = "AVPictureInPictureController")]
        /// Parameter `pictureInPictureController`: The Picture in Picture controller.
        ///
        /// Parameter `playing`: Whether the content should play or pause.
        ///
        /// Informs delegate that the user initiated a request to play or pause the content.
        #[unsafe(method(pictureInPictureController:setPlaying:))]
        #[unsafe(method_family = none)]
        unsafe fn pictureInPictureController_setPlaying(
            &self,
            picture_in_picture_controller: &AVPictureInPictureController,
            playing: bool,
        );

        #[cfg(all(feature = "AVPictureInPictureController", feature = "objc2-core-media"))]
        /// Parameter `pictureInPictureController`: The Picture in Picture controller.
        ///
        /// Allows delegate to inform Picture in Picture controller of the current playable time range. May be called multiple times during playback. Time ranges with finite duration should always contain the current time of the sample buffer display layer's timebase.
        ///
        /// Clients should return a time range with a duration of kCMTimeInfinity to indicate live content. When there is no content to play, they should return kCMTimeRangeInvalid. This method will be called whenever -[AVPictureInPictureController invalidatePlaybackState] is called and at other times as needed by the system.
        ///
        /// Returns: A CMTimeRange indicating the content's time range.
        #[unsafe(method(pictureInPictureControllerTimeRangeForPlayback:))]
        #[unsafe(method_family = none)]
        unsafe fn pictureInPictureControllerTimeRangeForPlayback(
            &self,
            picture_in_picture_controller: &AVPictureInPictureController,
        ) -> CMTimeRange;

        #[cfg(feature = "AVPictureInPictureController")]
        /// Parameter `pictureInPictureController`: The Picture in Picture controller.
        ///
        /// Allows delegate to indicate whether the playback UI should reflect a playing or paused state, regardless of what the current playback rate might be. May be called multiple times during playback.
        ///
        /// This method will be called whenever -[AVPictureInPictureController invalidatePlaybackState] is called and at other times as needed by the system.
        ///
        /// Returns: A boolean value indicating whether or not the playback UI should indicate playback has been paused or is playing.
        #[unsafe(method(pictureInPictureControllerIsPlaybackPaused:))]
        #[unsafe(method_family = none)]
        unsafe fn pictureInPictureControllerIsPlaybackPaused(
            &self,
            picture_in_picture_controller: &AVPictureInPictureController,
        ) -> bool;

        #[cfg(all(feature = "AVPictureInPictureController", feature = "objc2-core-media"))]
        /// Parameter `pictureInPictureController`: The Picture in Picture controller.
        ///
        /// Parameter `newRenderSize`: The rendered size, in pixels, of Picture in Picture content.
        ///
        /// This method is called when the system Picture in Picture window changes size. Delegate take the new render size and AVPictureInPictureController.isPictureInPictureActive into account when choosing media variants in order to avoid uncessary decoding overhead.
        #[unsafe(method(pictureInPictureController:didTransitionToRenderSize:))]
        #[unsafe(method_family = none)]
        unsafe fn pictureInPictureController_didTransitionToRenderSize(
            &self,
            picture_in_picture_controller: &AVPictureInPictureController,
            new_render_size: CMVideoDimensions,
        );

        #[cfg(all(
            feature = "AVPictureInPictureController",
            feature = "block2",
            feature = "objc2-core-media"
        ))]
        /// Parameter `pictureInPictureController`: The Picture in Picture controller.
        ///
        /// Parameter `skipInterval`: The interval by which to skip playback.
        ///
        /// Parameter `completionHandler`: A closure that must be invoked to indicate that the skip operation has completed.
        ///
        /// Informs delegate that the user has requested skipping forward or backward by the time indicated by the interval.
        ///
        /// Clients may choose to seek by a different interval for efficiency reasons (for example, seeking to a keyframe) or if the requested interval falls outside of the playable timeline. Clients must invoke the completion handler to indicate the seek operation has finished or failed. By the time the completion handler has been invoked, the timebase should reflect the current time and playback rate. Failure to invoke this completion handler is an application error and will result in playback UI permanently stuck in a “seeking” state.
        #[unsafe(method(pictureInPictureController:skipByInterval:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn pictureInPictureController_skipByInterval_completionHandler(
            &self,
            picture_in_picture_controller: &AVPictureInPictureController,
            skip_interval: CMTime,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "AVPictureInPictureController")]
        /// Parameter `pictureInPictureController`: The Picture in Picture controller.
        ///
        /// Allows the delegate to indicate whether background audio playback should always be prohibited.
        ///
        /// If implemented, this optional method will be called once for each invocation of invalidatePlaybackState to allow the delegate to indicate whether or not audio playback should be prohibited when the picture in picture window is in the background.
        ///
        /// Note that background in this context has a seperate meaning from application background used in UIKit. Here, background defines the state of the picture in picture window itself rather than the application.
        ///
        /// Returns: A boolean value indicating whether or not background audio playback is always prohibited.
        #[optional]
        #[unsafe(method(pictureInPictureControllerShouldProhibitBackgroundAudioPlayback:))]
        #[unsafe(method_family = none)]
        unsafe fn pictureInPictureControllerShouldProhibitBackgroundAudioPlayback(
            &self,
            picture_in_picture_controller: &AVPictureInPictureController,
        ) -> bool;
    }
);

/// AVSampleBufferDisplayLayerSupport.
#[cfg(feature = "AVPictureInPictureController")]
impl AVPictureInPictureControllerContentSource {
    extern_methods!(
        #[cfg(feature = "objc2-av-foundation")]
        #[cfg(not(target_os = "watchos"))]
        /// Parameter `sampleBufferDisplayLayer`: The sample buffer display layer to be shown in Picture in Picture.
        ///
        /// Parameter `playbackDelegate`: The playback delegate for controlling sample buffer display layer's playback in Picture in Picture.
        ///
        /// Use this initializer for a content source with a sample buffer display layer and playback delegate.
        #[unsafe(method(initWithSampleBufferDisplayLayer:playbackDelegate:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSampleBufferDisplayLayer_playbackDelegate(
            this: Allocated<Self>,
            sample_buffer_display_layer: &AVSampleBufferDisplayLayer,
            playback_delegate: &ProtocolObject<dyn AVPictureInPictureSampleBufferPlaybackDelegate>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-av-foundation")]
        #[cfg(not(target_os = "watchos"))]
        /// The receiver's sample buffer display layer.
        #[unsafe(method(sampleBufferDisplayLayer))]
        #[unsafe(method_family = none)]
        pub unsafe fn sampleBufferDisplayLayer(
            &self,
        ) -> Option<Retained<AVSampleBufferDisplayLayer>>;

        /// The receiver's sample buffer playback delegate.
        #[unsafe(method(sampleBufferPlaybackDelegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn sampleBufferPlaybackDelegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn AVPictureInPictureSampleBufferPlaybackDelegate>>>;
    );
}
