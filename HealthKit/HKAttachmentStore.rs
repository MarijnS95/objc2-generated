//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
use objc2_uniform_type_identifiers::*;

use crate::*;

extern_class!(
    /// The HKAttachmentStore class provides an interface for accessing and storing HKAttachment objects.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/healthkit/hkattachmentstore?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct HKAttachmentStore;
);

unsafe impl NSObjectProtocol for HKAttachmentStore {}

extern_methods!(
    unsafe impl HKAttachmentStore {
        #[cfg(feature = "HKHealthStore")]
        /// The designated initializer to create an HKAttachmentStore.
        ///
        /// Parameter `healthStore`: Specifies the HKHealthStore object to use.
        #[method_id(@__method_family Init initWithHealthStore:)]
        pub unsafe fn initWithHealthStore(
            this: Allocated<Self>,
            health_store: &HKHealthStore,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "HKAttachment",
            feature = "HKObject",
            feature = "block2",
            feature = "objc2-uniform-type-identifiers"
        ))]
        /// Creates a new HKAttachment using the passed in NSURL and attaches it to the specified HKObject.
        ///
        /// Parameter `object`: The object for which to add the HKAttachment.
        ///
        /// Parameter `name`: The name of the attachment.
        ///
        /// Parameter `contentType`: The content type of the attachment.
        ///
        /// Parameter `URL`: The NSURL to use to create the attachment.
        ///
        /// Parameter `metadata`: Extra information describing the attachment.
        ///
        /// Parameter `completion`: Called with an HKAttachment instance once the file was successfully saved and attached,
        /// otherwise called with an error.
        #[method(addAttachmentToObject:name:contentType:URL:metadata:completion:)]
        pub unsafe fn addAttachmentToObject_name_contentType_URL_metadata_completion(
            &self,
            object: &HKObject,
            name: &NSString,
            content_type: &UTType,
            url: &NSURL,
            metadata: Option<&NSDictionary<NSString, AnyObject>>,
            completion: &block2::Block<dyn Fn(*mut HKAttachment, *mut NSError)>,
        );

        #[cfg(all(feature = "HKAttachment", feature = "HKObject", feature = "block2"))]
        /// Removes the given HKAttachment from the specified HKObject.
        ///
        /// Parameter `attachment`: The HKAttachment to be removed.
        ///
        /// Parameter `object`: The object from which to remove the attachment.
        ///
        /// Parameter `completion`: Called once the remove operation finishes.
        #[method(removeAttachment:fromObject:completion:)]
        pub unsafe fn removeAttachment_fromObject_completion(
            &self,
            attachment: &HKAttachment,
            object: &HKObject,
            completion: &block2::Block<dyn Fn(Bool, *mut NSError)>,
        );

        #[cfg(all(feature = "HKAttachment", feature = "HKObject", feature = "block2"))]
        /// Retrieves a list of attachments for a given object.
        ///
        /// Parameter `object`: The object for which to retrieve attachments.
        ///
        /// Parameter `completion`: Called with a list of attachments or an error.
        #[method(getAttachmentsForObject:completion:)]
        pub unsafe fn getAttachmentsForObject_completion(
            &self,
            object: &HKObject,
            completion: &block2::Block<dyn Fn(*mut NSArray<HKAttachment>, *mut NSError)>,
        );

        #[cfg(all(feature = "HKAttachment", feature = "block2"))]
        /// Retrieves the NSData for the given HKAttachment.
        ///
        /// Prefer
        /// `streamDataForAttachment:completion:`for large files that support incremental reading to limit your app's peak memory usage.
        /// The attachment's data may not always be available locally, and could be stored in iCloud.
        ///
        /// Parameter `attachment`: The attachment object to read data from.
        ///
        /// Parameter `completion`: Called with an NSData or an error.
        ///
        /// Returns: An NSProgress object to use for tracking the progress of downloading the attachment's data from iCloud.
        #[method_id(@__method_family Other getDataForAttachment:completion:)]
        pub unsafe fn getDataForAttachment_completion(
            &self,
            attachment: &HKAttachment,
            completion: &block2::Block<dyn Fn(*mut NSData, *mut NSError)>,
        ) -> Retained<NSProgress>;

        #[cfg(all(feature = "HKAttachment", feature = "block2"))]
        /// Streams the given HKAttachment's data as ordered NSData chunks.
        ///
        /// The dataHandler's done parameter is set to YES when all chunks have been streamed.
        /// The attachment's data may not always be available locally, and could be stored in iCloud.
        ///
        /// Parameter `attachment`: The attachment object to read data from.
        ///
        /// Parameter `dataHandler`: Called with an NSData chunk or an error. When done is YES, the operation has completed.
        ///
        /// Returns: An NSProgress object to use for tracking the progress of downloading the attachment's data from iCloud.
        #[method_id(@__method_family Other streamDataForAttachment:dataHandler:)]
        pub unsafe fn streamDataForAttachment_dataHandler(
            &self,
            attachment: &HKAttachment,
            data_handler: &block2::Block<dyn Fn(*mut NSData, *mut NSError, Bool)>,
        ) -> Retained<NSProgress>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl HKAttachmentStore {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
