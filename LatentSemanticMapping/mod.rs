// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::unportable_markdown)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "LatentSemanticMapping", kind = "framework")]
extern "C" {}

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapoutofstate?language=objc)
pub const kLSMMapOutOfState: c_int = -6640;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapnosuchcategory?language=objc)
pub const kLSMMapNoSuchCategory: c_int = -6641;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapwriteerror?language=objc)
pub const kLSMMapWriteError: c_int = -6642;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapbadpath?language=objc)
pub const kLSMMapBadPath: c_int = -6643;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapbadcluster?language=objc)
pub const kLSMMapBadCluster: c_int = -6644;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapoverflow?language=objc)
pub const kLSMMapOverflow: c_int = -6645;

/// An opaque Core Foundation type representing an LSM map (mutable).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmmap?language=objc)
#[repr(C)]
pub struct LSMMap {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl LSMMap {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__LSMMap"> for LSMMap {}
);

unsafe impl ConcreteType for LSMMap {
    /// Returns the Core Foundation type identifier for LSM maps.
    #[doc(alias = "LSMMapGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn LSMMapGetTypeID() -> CFTypeID;
        }
        unsafe { LSMMapGetTypeID() }
    }
}

/// An opaque Core Foundation type representing an input text (mutable).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmtext?language=objc)
#[repr(C)]
pub struct LSMText {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl LSMText {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__LSMText"> for LSMText {}
);

unsafe impl ConcreteType for LSMText {
    /// Returns the Core Foundation type identifier for LSM texts.
    #[doc(alias = "LSMTextGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn LSMTextGetTypeID() -> CFTypeID;
        }
        unsafe { LSMTextGetTypeID() }
    }
}

/// An opaque Core Foundation type representing the result of a lookup (immutable).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmresult?language=objc)
#[repr(C)]
pub struct LSMResult {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl LSMResult {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__LSMResult"> for LSMResult {}
);

unsafe impl ConcreteType for LSMResult {
    /// Returns the Core Foundation type identifier for LSM results.
    #[doc(alias = "LSMResultGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn LSMResultGetTypeID() -> CFTypeID;
        }
        unsafe { LSMResultGetTypeID() }
    }
}

/// An integral type representing a category.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmcategory?language=objc)
pub type LSMCategory = u32;

/// Creates a new LSM map. Call CFRelease to dispose.
#[inline]
pub unsafe extern "C-unwind" fn LSMMapCreate(
    alloc: Option<&CFAllocator>,
    flags: CFOptionFlags,
) -> CFRetained<LSMMap> {
    extern "C-unwind" {
        fn LSMMapCreate(
            alloc: Option<&CFAllocator>,
            flags: CFOptionFlags,
        ) -> Option<NonNull<LSMMap>>;
    }
    let ret = unsafe { LSMMapCreate(alloc, flags) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmappairs?language=objc)
pub const kLSMMapPairs: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmaptriplets?language=objc)
pub const kLSMMapTriplets: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmaphashtext?language=objc)
pub const kLSMMapHashText: c_uint = 256;

extern "C-unwind" {
    /// Set a dictionary of properties for the map. LSM makes its own copy
    /// of the properties, there's no need to retain them past this call.
    pub fn LSMMapSetProperties(mapref: &LSMMap, properties: &CFDictionary);
}

/// Get a dictionary of properties for the map. LSM retains ownership of
/// this dictionary, do not release it.
#[inline]
pub unsafe extern "C-unwind" fn LSMMapGetProperties(mapref: &LSMMap) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn LSMMapGetProperties(mapref: &LSMMap) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { LSMMapGetProperties(mapref) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

extern "C-unwind" {
    /// Puts the map into training mode, preparing it for the addition of more
    /// categories and/or texts. This function will be somewhat expensive, as it
    /// requires substantial data structure reorganization.
    pub fn LSMMapStartTraining(mapref: &LSMMap) -> OSStatus;
}

extern "C-unwind" {
    /// Adds another category and returns its category identifier.
    pub fn LSMMapAddCategory(mapref: &LSMMap) -> LSMCategory;
}

extern "C-unwind" {
    /// Returns the number of categories in the map.
    pub fn LSMMapGetCategoryCount(mapref: &LSMMap) -> CFIndex;
}

extern "C-unwind" {
    /// The specified words will be omitted from all classification efforts.
    /// Needs to be called before any other texts are created.
    /// The textref is no longer needed after this call.
    pub fn LSMMapSetStopWords(mapref: &LSMMap, textref: &LSMText) -> OSStatus;
}

extern "C-unwind" {
    /// Adds a training text to the given category.
    /// The textref is no longer needed after this call.
    pub fn LSMMapAddText(mapref: &LSMMap, textref: &LSMText, category: LSMCategory) -> OSStatus;
}

extern "C-unwind" {
    /// Adds a training text to the given category with a weight different from 1.
    /// The weight may be negative, but global counts will be pinned to 0.
    /// The textref is no longer needed after this call.
    pub fn LSMMapAddTextWithWeight(
        mapref: &LSMMap,
        textref: &LSMText,
        category: LSMCategory,
        weight: c_float,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Compiles the map into executable form and puts it into mapping mode,
    /// preparing it for the classification of texts. This function is
    /// computationally expensive.
    pub fn LSMMapCompile(mapref: &LSMMap) -> OSStatus;
}

/// Compute a set of clusters grouping similar categories or words.
/// If subset is non-NULL, only perform clustering on the categories
/// or words listed.
#[inline]
pub unsafe extern "C-unwind" fn LSMMapCreateClusters(
    alloc: Option<&CFAllocator>,
    mapref: &LSMMap,
    subset: Option<&CFArray>,
    num_clusters: CFIndex,
    flags: CFOptionFlags,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSMMapCreateClusters(
            alloc: Option<&CFAllocator>,
            mapref: &LSMMap,
            subset: Option<&CFArray>,
            num_clusters: CFIndex,
            flags: CFOptionFlags,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSMMapCreateClusters(alloc, mapref, subset, num_clusters, flags) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclustercategories?language=objc)
pub const kLSMClusterCategories: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclusterwords?language=objc)
pub const kLSMClusterWords: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclustertokens?language=objc)
pub const kLSMClusterTokens: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclusterkmeans?language=objc)
pub const kLSMClusterKMeans: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclusteragglomerative?language=objc)
pub const kLSMClusterAgglomerative: c_uint = 4;

extern "C-unwind" {
    /// Group categories or words (tokens) into the specified sets of clusters.
    pub fn LSMMapApplyClusters(mapref: &LSMMap, clusters: &CFArray) -> OSStatus;
}

/// Returns, in decreasing order of likelihood, the categories or words
/// that best match when a text is mapped into a map.
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCreate(
    alloc: Option<&CFAllocator>,
    mapref: &LSMMap,
    textref: &LSMText,
    num_results: CFIndex,
    flags: CFOptionFlags,
) -> CFRetained<LSMResult> {
    extern "C-unwind" {
        fn LSMResultCreate(
            alloc: Option<&CFAllocator>,
            mapref: &LSMMap,
            textref: &LSMText,
            num_results: CFIndex,
            flags: CFOptionFlags,
        ) -> Option<NonNull<LSMResult>>;
    }
    let ret = unsafe { LSMResultCreate(alloc, mapref, textref, num_results, flags) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmresultbestwords?language=objc)
pub const kLSMResultBestWords: c_uint = 1;

extern "C-unwind" {
    /// Returns the number of results.
    pub fn LSMResultGetCount(result: &LSMResult) -> CFIndex;
}

extern "C-unwind" {
    /// Returns the category of the n-th best (zero based) result.
    pub fn LSMResultGetCategory(result: &LSMResult, n: CFIndex) -> LSMCategory;
}

extern "C-unwind" {
    /// Returns the likelihood of the n-th best (zero based) result.
    /// A nan score often indicates that the category does not contain
    /// any token.
    pub fn LSMResultGetScore(result: &LSMResult, n: CFIndex) -> c_float;
}

/// Returns the word for the n-th best (zero based) result.
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyWord(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn LSMResultCopyWord(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { LSMResultCopyWord(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns the token for the n-th best (zero based) result.
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyToken(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn LSMResultCopyToken(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { LSMResultCopyToken(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns the cluster of words for the n-th best (zero based) result.
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyWordCluster(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSMResultCopyWordCluster(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSMResultCopyWordCluster(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns the cluster of tokens for the n-th best (zero based) result.
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyTokenCluster(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSMResultCopyTokenCluster(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSMResultCopyTokenCluster(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Compiles the map if necessary and then stores it into the given file.
    pub fn LSMMapWriteToURL(mapref: &LSMMap, file: &CFURL, flags: CFOptionFlags) -> OSStatus;
}

/// Loads a map from a given file.
#[inline]
pub unsafe extern "C-unwind" fn LSMMapCreateFromURL(
    alloc: Option<&CFAllocator>,
    file: &CFURL,
    flags: CFOptionFlags,
) -> Option<CFRetained<LSMMap>> {
    extern "C-unwind" {
        fn LSMMapCreateFromURL(
            alloc: Option<&CFAllocator>,
            file: &CFURL,
            flags: CFOptionFlags,
        ) -> Option<NonNull<LSMMap>>;
    }
    let ret = unsafe { LSMMapCreateFromURL(alloc, file, flags) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapdiscardcounts?language=objc)
pub const kLSMMapDiscardCounts: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmaploadmutable?language=objc)
pub const kLSMMapLoadMutable: c_uint = 2;

extern "C-unwind" {
    /// Writes information about a map and/or text to a stream in text form
    pub fn LSMMapWriteToStream(
        mapref: &LSMMap,
        textref: Option<&LSMText>,
        stream: &CFWriteStream,
        options: CFOptionFlags,
    ) -> OSStatus;
}

/// Creates a new text.
#[inline]
pub unsafe extern "C-unwind" fn LSMTextCreate(
    alloc: Option<&CFAllocator>,
    mapref: &LSMMap,
) -> CFRetained<LSMText> {
    extern "C-unwind" {
        fn LSMTextCreate(alloc: Option<&CFAllocator>, mapref: &LSMMap) -> Option<NonNull<LSMText>>;
    }
    let ret = unsafe { LSMTextCreate(alloc, mapref) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Adds a word to the text. The order of words is significant if the map
    /// uses pairs or triplets, and the count of words is always significant.
    pub fn LSMTextAddWord(textref: &LSMText, word: &CFString) -> OSStatus;
}

extern "C-unwind" {
    /// Breaks a string into words using the locale provided and adds the words
    /// to the text.
    pub fn LSMTextAddWords(
        textref: &LSMText,
        words: &CFString,
        locale: Option<&CFLocale>,
        flags: CFOptionFlags,
    ) -> OSStatus;
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmtextpreservecase?language=objc)
pub const kLSMTextPreserveCase: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmtextpreserveacronyms?language=objc)
pub const kLSMTextPreserveAcronyms: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmtextapplyspamheuristics?language=objc)
pub const kLSMTextApplySpamHeuristics: c_uint = 4;

extern "C-unwind" {
    /// Adds an arbitrary binary token to the text. The order of tokens is
    /// significant if the map uses pairs or triplets, and the count of
    /// tokens is always significant.
    pub fn LSMTextAddToken(textref: &LSMText, token: &CFData) -> OSStatus;
}
