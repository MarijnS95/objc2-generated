//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Possible invitee responses
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkinviterecipientresponse?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GKInviteRecipientResponse(pub NSInteger);
impl GKInviteRecipientResponse {
    #[doc(alias = "GKInviteRecipientResponseAccepted")]
    pub const InviteRecipientResponseAccepted: Self = Self(0);
    #[doc(alias = "GKInviteRecipientResponseDeclined")]
    pub const InviteRecipientResponseDeclined: Self = Self(1);
    #[doc(alias = "GKInviteRecipientResponseFailed")]
    pub const InviteRecipientResponseFailed: Self = Self(2);
    #[doc(alias = "GKInviteRecipientResponseIncompatible")]
    pub const InviteRecipientResponseIncompatible: Self = Self(3);
    #[doc(alias = "GKInviteRecipientResponseUnableToConnect")]
    pub const InviteRecipientResponseUnableToConnect: Self = Self(4);
    #[doc(alias = "GKInviteRecipientResponseNoAnswer")]
    pub const InviteRecipientResponseNoAnswer: Self = Self(5);
    #[doc(alias = "GKInviteeResponseAccepted")]
    pub const InviteeResponseAccepted: Self =
        Self(GKInviteRecipientResponse::InviteRecipientResponseAccepted.0);
    #[doc(alias = "GKInviteeResponseDeclined")]
    pub const InviteeResponseDeclined: Self =
        Self(GKInviteRecipientResponse::InviteRecipientResponseDeclined.0);
    #[doc(alias = "GKInviteeResponseFailed")]
    pub const InviteeResponseFailed: Self =
        Self(GKInviteRecipientResponse::InviteRecipientResponseFailed.0);
    #[doc(alias = "GKInviteeResponseIncompatible")]
    pub const InviteeResponseIncompatible: Self =
        Self(GKInviteRecipientResponse::InviteRecipientResponseIncompatible.0);
    #[doc(alias = "GKInviteeResponseUnableToConnect")]
    pub const InviteeResponseUnableToConnect: Self =
        Self(GKInviteRecipientResponse::InviteRecipientResponseUnableToConnect.0);
    #[doc(alias = "GKInviteeResponseNoAnswer")]
    pub const InviteeResponseNoAnswer: Self =
        Self(GKInviteRecipientResponse::InviteRecipientResponseNoAnswer.0);
}

unsafe impl Encode for GKInviteRecipientResponse {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for GKInviteRecipientResponse {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkinviteeresponse?language=objc)
pub type GKInviteeResponse = GKInviteRecipientResponse;

/// [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkmatchtype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GKMatchType(pub NSUInteger);
impl GKMatchType {
    #[doc(alias = "GKMatchTypePeerToPeer")]
    pub const PeerToPeer: Self = Self(0);
    #[doc(alias = "GKMatchTypeHosted")]
    pub const Hosted: Self = Self(1);
    #[doc(alias = "GKMatchTypeTurnBased")]
    pub const TurnBased: Self = Self(2);
}

unsafe impl Encode for GKMatchType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for GKMatchType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// GKMatchRequest represents the parameters needed to create the match.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkmatchrequest?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatchRequest;
);

unsafe impl NSObjectProtocol for GKMatchRequest {}

extern_methods!(
    unsafe impl GKMatchRequest {
        /// Minimum number of players for the match
        #[method(minPlayers)]
        pub unsafe fn minPlayers(&self) -> NSUInteger;

        /// Setter for [`minPlayers`][Self::minPlayers].
        #[method(setMinPlayers:)]
        pub unsafe fn setMinPlayers(&self, min_players: NSUInteger);

        /// Maximum number of players for the match
        #[method(maxPlayers)]
        pub unsafe fn maxPlayers(&self) -> NSUInteger;

        /// Setter for [`maxPlayers`][Self::maxPlayers].
        #[method(setMaxPlayers:)]
        pub unsafe fn setMaxPlayers(&self, max_players: NSUInteger);

        /// The player group identifier. Matchmaking will only take place between players in the same group.
        #[method(playerGroup)]
        pub unsafe fn playerGroup(&self) -> NSUInteger;

        /// Setter for [`playerGroup`][Self::playerGroup].
        #[method(setPlayerGroup:)]
        pub unsafe fn setPlayerGroup(&self, player_group: NSUInteger);

        /// optional mask that specifies the role that the local player would like to play in the game.  If this value is 0, it will be set to 0xFFFFFFFF (the default), and this property will be ignored. If the value is nonzero, then automatching uses the value as a mask that restricts the role the player can play in the group. Automatching with player attributes matches new players into the game so that the bitwise OR of the masks of all the players in the resulting match equals 0xFFFFFFFF.
        #[method(playerAttributes)]
        pub unsafe fn playerAttributes(&self) -> u32;

        /// Setter for [`playerAttributes`][Self::playerAttributes].
        #[method(setPlayerAttributes:)]
        pub unsafe fn setPlayerAttributes(&self, player_attributes: u32);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Array of GKPlayers to invite, or nil if none. This array can also include local guest players.
        #[method_id(recipients)]
        #[unsafe(method_family = none)]
        pub unsafe fn recipients(&self) -> Option<Retained<NSArray<GKPlayer>>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Setter for [`recipients`][Self::recipients].
        #[method(setRecipients:)]
        pub unsafe fn setRecipients(&self, recipients: Option<&NSArray<GKPlayer>>);

        /// Message sent to invited players, may be modified if using GKMatchmakerViewController
        /// Will return nil if the player is underage or restricted.
        #[method_id(inviteMessage)]
        #[unsafe(method_family = none)]
        pub unsafe fn inviteMessage(&self) -> Option<Retained<NSString>>;

        /// Setter for [`inviteMessage`][Self::inviteMessage].
        #[method(setInviteMessage:)]
        pub unsafe fn setInviteMessage(&self, invite_message: Option<&NSString>);

        /// Default number of players to use during matchmaking. If not set we will default to the number that the player previously set for this game, or maxPlayers.
        #[method(defaultNumberOfPlayers)]
        pub unsafe fn defaultNumberOfPlayers(&self) -> NSUInteger;

        /// Setter for [`defaultNumberOfPlayers`][Self::defaultNumberOfPlayers].
        #[method(setDefaultNumberOfPlayers:)]
        pub unsafe fn setDefaultNumberOfPlayers(&self, default_number_of_players: NSUInteger);

        /// Whether or not a match will be created only using automatch.  If YES, then a player will not be able to
        /// invite anyone (including contacts, friends, and nearby players) to the match, but rely on automatching to
        /// find players for the match.  Default is NO.
        #[deprecated]
        #[method(restrictToAutomatch)]
        pub unsafe fn restrictToAutomatch(&self) -> bool;

        /// Setter for [`restrictToAutomatch`][Self::restrictToAutomatch].
        #[deprecated]
        #[method(setRestrictToAutomatch:)]
        pub unsafe fn setRestrictToAutomatch(&self, restrict_to_automatch: bool);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// An recipientResponseHandler can be set in order to receive responses from programmatically invited players.
        #[method(recipientResponseHandler)]
        pub unsafe fn recipientResponseHandler(
            &self,
        ) -> *mut block2::Block<dyn Fn(NonNull<GKPlayer>, GKInviteRecipientResponse)>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Setter for [`recipientResponseHandler`][Self::recipientResponseHandler].
        #[method(setRecipientResponseHandler:)]
        pub unsafe fn setRecipientResponseHandler(
            &self,
            recipient_response_handler: Option<
                &block2::Block<dyn Fn(NonNull<GKPlayer>, GKInviteRecipientResponse)>,
            >,
        );

        #[cfg(feature = "block2")]
        #[deprecated]
        #[method(inviteeResponseHandler)]
        pub unsafe fn inviteeResponseHandler(
            &self,
        ) -> *mut block2::Block<dyn Fn(NonNull<NSString>, GKInviteeResponse)>;

        #[cfg(feature = "block2")]
        /// Setter for [`inviteeResponseHandler`][Self::inviteeResponseHandler].
        #[deprecated]
        #[method(setInviteeResponseHandler:)]
        pub unsafe fn setInviteeResponseHandler(
            &self,
            invitee_response_handler: Option<
                &block2::Block<dyn Fn(NonNull<NSString>, GKInviteeResponse)>,
            >,
        );

        /// To determine the maximum allowed players for each type of match supported.
        #[method(maxPlayersAllowedForMatchOfType:)]
        pub unsafe fn maxPlayersAllowedForMatchOfType(match_type: GKMatchType) -> NSUInteger;

        #[deprecated]
        #[method_id(playersToInvite)]
        #[unsafe(method_family = none)]
        pub unsafe fn playersToInvite(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`playersToInvite`][Self::playersToInvite].
        #[deprecated]
        #[method(setPlayersToInvite:)]
        pub unsafe fn setPlayersToInvite(&self, players_to_invite: Option<&NSArray<NSString>>);

        /// The name of the queue, if rule-based matchmaking is used.
        #[method_id(queueName)]
        #[unsafe(method_family = none)]
        pub unsafe fn queueName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`queueName`][Self::queueName].
        #[method(setQueueName:)]
        pub unsafe fn setQueueName(&self, queue_name: Option<&NSString>);

        #[cfg(feature = "GKDefines")]
        /// The match properties, if rule-based matchmaking is used.
        #[method_id(properties)]
        #[unsafe(method_family = none)]
        pub unsafe fn properties(&self) -> Option<Retained<GKMatchProperties>>;

        #[cfg(feature = "GKDefines")]
        /// Setter for [`properties`][Self::properties].
        #[method(setProperties:)]
        pub unsafe fn setProperties(&self, properties: Option<&GKMatchProperties>);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        /// The recipient specific match properties, if rule-based matchmaking is used when inviting players.
        #[method_id(recipientProperties)]
        #[unsafe(method_family = none)]
        pub unsafe fn recipientProperties(
            &self,
        ) -> Option<Retained<NSDictionary<GKPlayer, GKMatchProperties>>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        /// Setter for [`recipientProperties`][Self::recipientProperties].
        #[method(setRecipientProperties:)]
        pub unsafe fn setRecipientProperties(
            &self,
            recipient_properties: Option<&NSDictionary<GKPlayer, GKMatchProperties>>,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl GKMatchRequest {
        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// GKInvite represents an accepted game invite, it is used to create a GKMatchmakerViewController
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkinvite?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKInvite;
);

unsafe impl NSObjectProtocol for GKInvite {}

extern_methods!(
    unsafe impl GKInvite {
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[method_id(sender)]
        #[unsafe(method_family = none)]
        pub unsafe fn sender(&self) -> Retained<GKPlayer>;

        #[method(isHosted)]
        pub unsafe fn isHosted(&self) -> bool;

        /// player group from inviter's match request
        #[method(playerGroup)]
        pub unsafe fn playerGroup(&self) -> NSUInteger;

        /// player attributes from inviter's match request
        #[method(playerAttributes)]
        pub unsafe fn playerAttributes(&self) -> u32;

        /// * This property is obsolete. **
        #[deprecated]
        #[method_id(inviter)]
        #[unsafe(method_family = none)]
        pub unsafe fn inviter(&self) -> Retained<NSString>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl GKInvite {
        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// GKInviteEventListener uses the GKLocalPlayerListener mechanism on GKLocalPlayer to listen to the two kinds of invite events that a game must respond to
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkinviteeventlistener?language=objc)
    pub unsafe trait GKInviteEventListener {
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// player:didAcceptInvite: gets called when another player accepts the invite from the local player
        #[optional]
        #[method(player:didAcceptInvite:)]
        unsafe fn player_didAcceptInvite(&self, player: &GKPlayer, invite: &GKInvite);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// didRequestMatchWithRecipients: gets called when the player chooses to play with another player from Game Center and it launches the game to start matchmaking
        #[optional]
        #[method(player:didRequestMatchWithRecipients:)]
        unsafe fn player_didRequestMatchWithRecipients(
            &self,
            player: &GKPlayer,
            recipient_players: &NSArray<GKPlayer>,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[optional]
        #[method(player:didRequestMatchWithPlayers:)]
        unsafe fn player_didRequestMatchWithPlayers(
            &self,
            player: &GKPlayer,
            player_i_ds_to_invite: &NSArray<NSString>,
        );
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkmatchedplayers?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatchedPlayers;
);

unsafe impl NSObjectProtocol for GKMatchedPlayers {}

extern_methods!(
    unsafe impl GKMatchedPlayers {
        #[cfg(feature = "GKDefines")]
        #[method_id(properties)]
        #[unsafe(method_family = none)]
        pub unsafe fn properties(&self) -> Option<Retained<GKMatchProperties>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[method_id(players)]
        #[unsafe(method_family = none)]
        pub unsafe fn players(&self) -> Retained<NSArray<GKPlayer>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        #[method_id(playerProperties)]
        #[unsafe(method_family = none)]
        pub unsafe fn playerProperties(
            &self,
        ) -> Option<Retained<NSDictionary<GKPlayer, GKMatchProperties>>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl GKMatchedPlayers {
        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// GKMatchmaker is a singleton object to manage match creation from invites and automatching.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkmatchmaker?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatchmaker;
);

unsafe impl NSObjectProtocol for GKMatchmaker {}

extern_methods!(
    unsafe impl GKMatchmaker {
        /// The shared matchmaker
        #[method_id(sharedMatchmaker)]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedMatchmaker() -> Retained<GKMatchmaker>;

        #[cfg(all(feature = "GKMatch", feature = "block2"))]
        /// Get a match for an accepted invite
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Invite cancelled
        #[method(matchForInvite:completionHandler:)]
        pub unsafe fn matchForInvite_completionHandler(
            &self,
            invite: &GKInvite,
            completion_handler: Option<&block2::Block<dyn Fn(*mut GKMatch, *mut NSError)>>,
        );

        #[cfg(all(feature = "GKMatch", feature = "block2"))]
        /// Automatching or invites to find a peer-to-peer match for the specified request. Error will be nil on success:
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Unauthenticated player
        /// 3. Timeout
        /// Note that the players property on the returned GKMatch instance will only contain connected players. It will initially be empty as players are connecting. Implement the GKMatchDelegate method match:player:didChangeConnectionState: to listen for updates to the GKMatch instance's players property.
        #[method(findMatchForRequest:withCompletionHandler:)]
        pub unsafe fn findMatchForRequest_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: Option<&block2::Block<dyn Fn(*mut GKMatch, *mut NSError)>>,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Automatching or invites for host-client match request. This returns a list of player identifiers to be included in the match. Determination and communication with the host is not part of this API.
        /// When inviting, no player identifiers will be returned. Player responses will be reported via the inviteeResponseHandler.
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Unauthenticated player
        /// 3. Timeout
        #[method(findPlayersForHostedRequest:withCompletionHandler:)]
        pub unsafe fn findPlayersForHostedRequest_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: Option<
                &block2::Block<dyn Fn(*mut NSArray<GKPlayer>, *mut NSError)>,
            >,
        );

        #[cfg(feature = "block2")]
        /// Automatching or invites for host-client rule-based match request.
        #[method(findMatchedPlayers:withCompletionHandler:)]
        pub unsafe fn findMatchedPlayers_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: &block2::Block<dyn Fn(*mut GKMatchedPlayers, *mut NSError)>,
        );

        #[cfg(all(feature = "GKMatch", feature = "block2"))]
        /// Automatching or invites to add additional players to a peer-to-peer match for the specified request. Error will be nil on success:
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Timeout
        #[method(addPlayersToMatch:matchRequest:completionHandler:)]
        pub unsafe fn addPlayersToMatch_matchRequest_completionHandler(
            &self,
            r#match: &GKMatch,
            match_request: &GKMatchRequest,
            completion_handler: Option<&block2::Block<dyn Fn(*mut NSError)>>,
        );

        /// Cancel matchmaking and any pending invites
        #[method(cancel)]
        pub unsafe fn cancel(&self);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Cancel a pending invitation to a player
        #[method(cancelPendingInviteToPlayer:)]
        pub unsafe fn cancelPendingInviteToPlayer(&self, player: &GKPlayer);

        #[cfg(feature = "GKMatch")]
        /// Call this when finished with all programmatic P2P invites/matchmaking, for compatability with connected players using GKMatchmakerViewController.
        #[method(finishMatchmakingForMatch:)]
        pub unsafe fn finishMatchmakingForMatch(&self, r#match: &GKMatch);

        #[cfg(feature = "block2")]
        /// Query the server for recent activity in the specified player group. A larger value indicates that a given group has seen more recent activity. Error will be nil on success.
        /// Possible reasons for error:
        /// 1. Communications failure
        #[method(queryPlayerGroupActivity:withCompletionHandler:)]
        pub unsafe fn queryPlayerGroupActivity_withCompletionHandler(
            &self,
            player_group: NSUInteger,
            completion_handler: Option<&block2::Block<dyn Fn(NSInteger, *mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// Query the server for recent activity for all the player groups of that game. Error will be nil on success.
        /// Possible reasons for error:
        /// 1. Communications failure
        #[method(queryActivityWithCompletionHandler:)]
        pub unsafe fn queryActivityWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::Block<dyn Fn(NSInteger, *mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// Query the server for recent activity for the specified queue.
        #[method(queryQueueActivity:withCompletionHandler:)]
        pub unsafe fn queryQueueActivity_withCompletionHandler(
            &self,
            queue_name: &NSString,
            completion_handler: Option<&block2::Block<dyn Fn(NSInteger, *mut NSError)>>,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Start browsing for nearby players that can be invited to a match. The reachableHandler will be called for each player found with a compatible game. It may be called more than once for the same player if that player ever becomes unreachable (e.g. moves out of range). You should call stopBrowsingForNearbyPlayers when finished browsing.
        #[method(startBrowsingForNearbyPlayersWithHandler:)]
        pub unsafe fn startBrowsingForNearbyPlayersWithHandler(
            &self,
            reachable_handler: Option<&block2::Block<dyn Fn(NonNull<GKPlayer>, Bool)>>,
        );

        /// Stop browsing for nearby players.
        #[method(stopBrowsingForNearbyPlayers)]
        pub unsafe fn stopBrowsingForNearbyPlayers(&self);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Activate  a  group activity by Game Center for your game, which allows people in the FaceTime call to join the local player's game. The handler will be called for each player who joined from the activity.
        #[method(startGroupActivityWithPlayerHandler:)]
        pub unsafe fn startGroupActivityWithPlayerHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<GKPlayer>)>,
        );

        /// End the group activity created by Game Center for your game, which was activated by the local player.
        #[method(stopGroupActivity)]
        pub unsafe fn stopGroupActivity(&self);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl GKMatchmaker {
        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_methods!(
    /// GKDeprecated
    unsafe impl GKMatchmaker {
        #[cfg(feature = "block2")]
        #[deprecated = "Use registerListener on GKLocalPlayer to register an object that implements the GKInviteEventListener instead."]
        #[method(inviteHandler)]
        pub unsafe fn inviteHandler(
            &self,
        ) -> *mut block2::Block<dyn Fn(NonNull<GKInvite>, *mut NSArray)>;

        #[cfg(feature = "block2")]
        /// Setter for [`inviteHandler`][Self::inviteHandler].
        #[deprecated = "Use registerListener on GKLocalPlayer to register an object that implements the GKInviteEventListener instead."]
        #[method(setInviteHandler:)]
        pub unsafe fn setInviteHandler(
            &self,
            invite_handler: Option<&block2::Block<dyn Fn(NonNull<GKInvite>, *mut NSArray)>>,
        );
    }
);

extern_methods!(
    /// Obsoleted
    unsafe impl GKMatchmaker {
        #[cfg(feature = "block2")]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[method(startBrowsingForNearbyPlayersWithReachableHandler:)]
        pub unsafe fn startBrowsingForNearbyPlayersWithReachableHandler(
            &self,
            reachable_handler: Option<&block2::Block<dyn Fn(NonNull<NSString>, Bool)>>,
        );

        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[method(cancelInviteToPlayer:)]
        pub unsafe fn cancelInviteToPlayer(&self, player_id: &NSString);

        #[cfg(feature = "block2")]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[method(findPlayersForHostedMatchRequest:withCompletionHandler:)]
        pub unsafe fn findPlayersForHostedMatchRequest_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: Option<
                &block2::Block<dyn Fn(*mut NSArray<NSString>, *mut NSError)>,
            >,
        );
    }
);
