//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// The OSStatus errors returned from the CMTagCollection routines.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmtagcollectionerror?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CMTagCollectionError(pub OSStatus);
impl CMTagCollectionError {
    #[doc(alias = "kCMTagCollectionError_ParamErr")]
    pub const ParamErr: Self = Self(-15740);
    #[doc(alias = "kCMTagCollectionError_AllocationFailed")]
    pub const AllocationFailed: Self = Self(-15741);
    #[doc(alias = "kCMTagCollectionError_InternalError")]
    pub const InternalError: Self = Self(-15742);
    #[doc(alias = "kCMTagCollectionError_InvalidTag")]
    pub const InvalidTag: Self = Self(-15743);
    #[doc(alias = "kCMTagCollectionError_InvalidTagCollectionDictionary")]
    pub const InvalidTagCollectionDictionary: Self = Self(-15744);
    #[doc(alias = "kCMTagCollectionError_InvalidTagCollectionData")]
    pub const InvalidTagCollectionData: Self = Self(-15745);
    #[doc(alias = "kCMTagCollectionError_TagNotFound")]
    pub const TagNotFound: Self = Self(-15746);
    #[doc(alias = "kCMTagCollectionError_InvalidTagCollectionDataVersion")]
    pub const InvalidTagCollectionDataVersion: Self = Self(-15747);
    #[doc(alias = "kCMTagCollectionError_ExhaustedBufferSize")]
    pub const ExhaustedBufferSize: Self = Self(-15748);
    #[doc(alias = "kCMTagCollectionError_NotYetImplemented")]
    pub const NotYetImplemented: Self = Self(-15749);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTagCollectionError {
    const ENCODING: Encoding = OSStatus::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTagCollectionError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A reference to a CMTagCollection, a CF object that adheres to retain/release semantics. This value type represents an unordered collection of zero or more CMTags. This type is roughly analogous to CFSetRef in that it is unordered and has operations for Boolean set math. It is however optimized for the storage of CMTag structures.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmtagcollection?language=objc)
#[repr(C)]
pub struct CMTagCollection {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "OpaqueCMTagCollection"]
    unsafe impl CMTagCollection {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmmutabletagcollection?language=objc)
#[repr(C)]
pub struct CMMutableTagCollection {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "OpaqueCMTagCollection"]
    unsafe impl CMMutableTagCollection: CMTagCollection {}
);

unsafe impl ConcreteType for CMTagCollection {
    /// Obtains the CoreFoundation type ID for the CMTagCollection type.
    ///
    /// Obtains the CoreFoundation type ID for the CMTagCollection type.
    ///
    /// Returns: Returns the CFTypeID corresponding to CMTagCollection.
    #[doc(alias = "CMTagCollectionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMTagCollectionGetTypeID() -> CFTypeID;
        }
        unsafe { CMTagCollectionGetTypeID() }
    }
}

/// A callback function that can be used to iterate over a CMTagCollection. The callback is passed a CMTag and a potentially NULL context reference that can be used to implement some operation for each tag.
///
/// Parameter `tag`: The CMTag to evaluate.
///
/// Parameter `context`: A valid pointer or NULL used by the callback implementation.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmtagcollectionapplierfunction?language=objc)
#[cfg(feature = "CMTag")]
pub type CMTagCollectionApplierFunction = Option<unsafe extern "C-unwind" fn(CMTag, *mut c_void)>;

/// A callback function that can be used to implement a filtering operation during iteration over a CMTagCollection. For each CMTag that satisfies the predicate, the callback should return true. Otherwise, it should return false.  The callback is passed a CMTag and a potentially NULL context reference that can be used to implement some operation for each tag.
///
/// Parameter `tag`: The CMTag to evaluate.
///
/// Parameter `context`: A valid pointer or NULL used by the callback implementation.
///
/// Returns: A Boolean indicating if the tag passed the callback test.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmtagcollectiontagfilterfunction?language=objc)
#[cfg(feature = "CMTag")]
pub type CMTagCollectionTagFilterFunction =
    Option<unsafe extern "C-unwind" fn(CMTag, *mut c_void) -> Boolean>;

extern "C-unwind" {
    /// Creates a CMTagCollectionRef described by a number of parameters.
    ///
    /// This can be used to construct a CMTagCollectionRef from zero or more CMTags.
    ///
    /// Parameter `allocator`: CFAllocator to use to create the collection and internal data structures.
    ///
    /// Parameter `tags`: Zero or more CMTag structs to copy into the collection. May pass NULL if tagCount is also zero (0).
    ///
    /// Parameter `tagCount`: Number of tags in the 'tags' array.
    ///
    /// Parameter `newCollectionOut`: Address of a location to return the newly created CMTagCollectionRef.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus with error or noErr if successful.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionCreate(
        allocator: Option<&CFAllocator>,
        tags: *const CMTag,
        tag_count: CMItemCount,
        new_collection_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a CMMutableTagCollectionRef.
    ///
    /// This can be used to construct a mutable CMTagCollectionRef with a capacity limit or without a capacity limit. A capacity greater than zero indicates a maximum number of CMTags the collection can contain. The actual number of tags may be less than this value depending upon how many tags have been added to the collection.
    /// If capacity is 0, the mutable collection can contain any number of tags.
    ///
    /// Parameter `allocator`: CFAllocator to use to create the collection and internal data structures.
    ///
    /// Parameter `capacity`: Capacity limit set to zero to indicate no limit or a value greater than zero for a limit.
    ///
    /// Parameter `newMutableCollectionOut`: Address of a location to return the newly created CMMutabbleTagCollectionRef.  The client is responsible for releasing the returned CMMutableTagCollection.
    ///
    /// Returns: OSStatus with error, or noErr if successful.
    pub fn CMTagCollectionCreateMutable(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        new_mutable_collection_out: NonNull<*mut CMMutableTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a duplicate CMTagCollectionRef.
    ///
    /// This can be used to construct a CMTagCollectionRef that contains all the same tags as another collection.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef used to create the copy.
    ///
    /// Parameter `allocator`: CFAllocator used to create the copy.
    ///
    /// Parameter `newCollectionCopyOut`: Address of a location to return the newly created CMTagCollectionRef.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus with error or noErr if successful.
    pub fn CMTagCollectionCreateCopy(
        tag_collection: &CMTagCollection,
        allocator: Option<&CFAllocator>,
        new_collection_copy_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a duplicate mutable CMTagCollectionRef.
    ///
    /// This can be used to construct a CMMutableTagCollectionRef that contains all the same tags as another collection.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef used to create the copy.
    ///
    /// Parameter `allocator`: CFAllocator used to create the copy.
    ///
    /// Parameter `newMutableCollectionCopyOut`: Address of a location to return the newly created CMMutableTagCollectionRef.  The client is responsible for releasing the returned CMMutableTagCollection.
    ///
    /// Returns: OSStatus with error or noErr if successful.
    pub fn CMTagCollectionCreateMutableCopy(
        tag_collection: &CMTagCollection,
        allocator: Option<&CFAllocator>,
        new_mutable_collection_copy_out: NonNull<*mut CMMutableTagCollection>,
    ) -> OSStatus;
}

/// Creates a CFString with a description of a CMTagCollection.
///
/// This can be used from within CFShow on a CMTagCollection object. It is also useful from other client debugging code.  The caller owns the returned CFString, and is responsible for releasing it.  Descriptions are not localized so are likely suitable only for debugging.
///
/// Parameter `allocator`: CFAllocator to use in creating the description string.
///
/// Parameter `tagCollection`: CMTagCollectionRef to describe.
///
/// Returns: The created CFString description.
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionCopyDescription(
    allocator: Option<&CFAllocator>,
    tag_collection: Option<&CMTagCollection>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CMTagCollectionCopyDescription(
            allocator: Option<&CFAllocator>,
            tag_collection: Option<&CMTagCollection>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CMTagCollectionCopyDescription(allocator, tag_collection) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Returns the number of CMTags held in the CMTagCollectionRef.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to evaluate for the tag count.
    ///
    /// Returns: CMItemCount holding the count.
    #[cfg(feature = "CMBase")]
    pub fn CMTagCollectionGetCount(tag_collection: &CMTagCollection) -> CMItemCount;
}

/// Checks if the tag collection contains a specific tag.
///
/// Parameter `tagCollection`: CMTagCollection to check.
///
/// Parameter `tag`: CMTag to find.
///
/// Returns: Returns true if the indicated CMTag is contained within the CMTagCollection, false otherwise.
#[cfg(feature = "CMTag")]
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionContainsTag(
    tag_collection: &CMTagCollection,
    tag: CMTag,
) -> bool {
    extern "C-unwind" {
        fn CMTagCollectionContainsTag(tag_collection: &CMTagCollection, tag: CMTag) -> Boolean;
    }
    let ret = unsafe { CMTagCollectionContainsTag(tag_collection, tag) };
    ret != 0
}

/// Checks if all the tags in a tag collection are present in another tag collection.
///
/// Tests if a collection of tags specified by a CMTagCollection are contained within another tag collection in its entirety. Partial containment will report false. Complete containment will report true.
///
/// Parameter `tagCollection`: CMTagCollectionRef used to check.
///
/// Parameter `containedTagCollection`: CMTagCollectionRef whose contents should be checked for containment in tagCollection.
///
/// Returns: Returns true if all CMTags in a collection are contained within the specified CMTagCollection, false otherwise.
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionContainsTagsOfCollection(
    tag_collection: &CMTagCollection,
    contained_tag_collection: &CMTagCollection,
) -> bool {
    extern "C-unwind" {
        fn CMTagCollectionContainsTagsOfCollection(
            tag_collection: &CMTagCollection,
            contained_tag_collection: &CMTagCollection,
        ) -> Boolean;
    }
    let ret = unsafe {
        CMTagCollectionContainsTagsOfCollection(tag_collection, contained_tag_collection)
    };
    ret != 0
}

/// Checks if all the specified tags are contained in a tag collection.
///
/// Tests if the tags specified by a buffer of CMTags are contained within another tag collection in its entirety. Partial containment will report false. Complete containment will report true.
///
/// Parameter `tagCollection`: CMTagCollectionRef to check.
///
/// Parameter `containedTags`: The non-NULL address to a CMTag array whose CMTags should be checked for containment in tagCollection.
///
/// Parameter `containedTagCount`: The number of CMTag elements in the buffer containedTags. Zero is allowed but will report true.
///
/// Returns: Returns true if all CMTags in a buffer of CMTags are contained within the CMTagCollection, false otherwise.
#[cfg(all(feature = "CMBase", feature = "CMTag"))]
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionContainsSpecifiedTags(
    tag_collection: &CMTagCollection,
    contained_tags: NonNull<CMTag>,
    contained_tag_count: CMItemCount,
) -> bool {
    extern "C-unwind" {
        fn CMTagCollectionContainsSpecifiedTags(
            tag_collection: &CMTagCollection,
            contained_tags: NonNull<CMTag>,
            contained_tag_count: CMItemCount,
        ) -> Boolean;
    }
    let ret = unsafe {
        CMTagCollectionContainsSpecifiedTags(tag_collection, contained_tags, contained_tag_count)
    };
    ret != 0
}

/// Tests if a CMTagCategory is used by any CMTags within the tag container.
///
/// Parameter `tagCollection`: CMTagCollectionRef to check.
///
/// Parameter `category`: CMTagCategory whose value should be checked for containment in tagCollection.
///
/// Returns: Returns true if tagCollection contains at least one CMTag with the specified category, false otherwise.
#[cfg(feature = "CMTag")]
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionContainsCategory(
    tag_collection: &CMTagCollection,
    category: CMTagCategory,
) -> bool {
    extern "C-unwind" {
        fn CMTagCollectionContainsCategory(
            tag_collection: &CMTagCollection,
            category: CMTagCategory,
        ) -> Boolean;
    }
    let ret = unsafe { CMTagCollectionContainsCategory(tag_collection, category) };
    ret != 0
}

extern "C-unwind" {
    /// Counts an returns the number of tags in the tag collection matching the specified category.
    ///
    /// Returns the count of tags having the specified category. It will return 0 if there are no tags.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to evaluate.
    ///
    /// Parameter `category`: CMTagCategory to check for.
    ///
    /// Returns: Returns the count of tags having the specified category.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionGetCountOfCategory(
        tag_collection: &CMTagCollection,
        category: CMTagCategory,
    ) -> CMItemCount;
}

extern "C-unwind" {
    /// Retrieve all CMTags and copy into a supplied buffer.
    ///
    /// The function retrieves a specified number of CMTags from the CMTagCollectionRef and copies them to a supplied buffer. The routine populates a provided sized buffer with each CMTag in the collection. If the provided buffer is smaller than needed to retrieve all tags, the routine will fill the buffer, return the number actually copied and return kCMTagCollectionError_ExhaustedBufferSize. If the provided buffer is larger than the number of CMTags in the collection to retrieve, the routine will fill the buffer with the number of available CMTags, return the number copied and fill the remainder of the buffer with kCMTagInvalid while returning noErr.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to iterate.
    ///
    /// Parameter `tagBuffer`: A non-NULL address of a buffer to fill with CMTags with CMTagCategory 'category'.
    ///
    /// Parameter `tagBufferCount`: The number of CMTags the buffer 'tagBuffer' can hold.
    ///
    /// Parameter `numberOfTagsCopied`: The address of a CMItemCount that is filled with the number of tags retrieved, may be NULL.
    ///
    /// Returns: OSStatus with an error or noErr if successful.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionGetTags(
        tag_collection: &CMTagCollection,
        tag_buffer: NonNull<CMTag>,
        tag_buffer_count: CMItemCount,
        number_of_tags_copied: *mut CMItemCount,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Retrieve CMTags having a specified CMTagCategory and copy to a supplied buffer.
    ///
    /// Populates a provided buffer with each CMTag in the collection that has the specified CMTagCategory. If the provided buffer is smaller than needed, the routine will fill the buffer, return the number of CMTags actually copied and return kCMTagCollectionError_ExhaustedBufferSize. If the provided buffer is larger than needed, it will fill the buffer with the number of available CMTags, return the number copied and fill the remainder of the buffer with kCMTagInvalid.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to iterate.
    ///
    /// Parameter `category`: CMTagCategory to match.
    ///
    /// Parameter `tagBuffer`: A non-NULL address of a buffer to fill with CMTags with CMTagCategory 'category'.
    ///
    /// Parameter `tagBufferCount`: The number of CMTags the buffer 'tagBuffer' can hold.
    ///
    /// Parameter `numberOfTagsCopied`: The address of a CMItemCount that is filled with the number of tags retrieved, may be NULL.
    ///
    /// Returns: OSStatus with an error or noErr if successful.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionGetTagsWithCategory(
        tag_collection: &CMTagCollection,
        category: CMTagCategory,
        tag_buffer: NonNull<CMTag>,
        tag_buffer_count: CMItemCount,
        number_of_tags_copied: *mut CMItemCount,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Count the number of tags satisfying a callback.
    ///
    /// Iterates over the CMTags of the tag collection calling the supplied callback and incrementing a counter for each tag satisfying the callback. Returns this counter value upon completing iteration.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to iterate.
    ///
    /// Parameter `filterApplier`: The CMTagCollectionTagFilterFunction callback to call with each tag.
    ///
    /// Parameter `context`: A void * or NULL to pass to applier.
    ///
    /// Returns: CMItemCount indicating the number of CMTags satisfying 'filterApplier'.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionCountTagsWithFilterFunction(
        tag_collection: &CMTagCollection,
        filter_applier: CMTagCollectionTagFilterFunction,
        context: *mut c_void,
    ) -> CMItemCount;
}

extern "C-unwind" {
    /// Retrieve CMTags satisfying a callback function and copy them to a supplied buffer.
    ///
    /// Applies a CMTagCollectionTagFilterFunction predicate and populates a provided buffer with each CMTag that for each tag when the filter returns true.  If the provided buffer is smaller than the number of tags the predicate satisfies, the routine will fill the buffer, return the copy CMTags actually copied and return kCMTagCollectionError_ExhaustedBufferSize. If the provided buffer is larger than needed, it will fill the buffer with the number of available CMTags, fill the remainder of the buffer with kCMTagInvalid and return a result of noErr.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to iterate.
    ///
    /// Parameter `tagBuffer`: A non-NULL address of a buffer to fill with CMTags with CMTagCategory 'category'.
    ///
    /// Parameter `tagBufferCount`: The number of CMTags the buffer 'tagBuffer' can hold.
    ///
    /// Parameter `numberOfTagsCopied`: The address of a CMItemCount that is filled with the number of tags retrieved, may be NULL.
    ///
    /// Parameter `filter`: The CMTagCollectionTagFilterFunction callback to call with each tag.
    ///
    /// Parameter `context`: A void * or NULL to pass to filter.
    ///
    /// Returns: OSStatus with an error or noErr if successful.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionGetTagsWithFilterFunction(
        tag_collection: &CMTagCollection,
        tag_buffer: NonNull<CMTag>,
        tag_buffer_count: CMItemCount,
        number_of_tags_copied: *mut CMItemCount,
        filter: CMTagCollectionTagFilterFunction,
        context: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Copies all tags belonging to a specified list of CMTagCategory from one tag collection to a newly created tag collection.
    ///
    /// This routine copies all tags belonging to a specified list of CMTagCategory from one tag collection to a newly created tag collection.
    ///
    /// Parameter `allocator`: CFAllocatorRef to use in allocations of the operation.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef from which to copy tags.
    ///
    /// Parameter `categories`: A non-NULL address of a buffer containing a list of CMTagCategory.
    ///
    /// Parameter `categoriesCount`: The number of CMTagCategory the buffer 'categories' is holding.
    ///
    /// Parameter `collectionWithTagsOfCategories`: The address of a CMTagCollectionRef that contains all tags copied from 'tagCollection'.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionCopyTagsOfCategories(
        allocator: Option<&CFAllocator>,
        tag_collection: &CMTagCollection,
        categories: NonNull<CMTagCategory>,
        categories_count: CMItemCount,
        collection_with_tags_of_categories: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Iterate over a tag collection calling the provided callback.
    ///
    /// Iterates over the CMTags of the tag collection executing the callback with each tag.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to iterate.
    ///
    /// Parameter `applier`: The CMTagCollectionApplierFunction callback to call with each tag.
    ///
    /// Parameter `context`: A void * or NULL to pass to applier.
    #[cfg(feature = "CMTag")]
    pub fn CMTagCollectionApply(
        tag_collection: &CMTagCollection,
        applier: CMTagCollectionApplierFunction,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    /// Iterate over a tag collection until the callback is satisfied.
    ///
    /// Function iterates over the CMTags of the tag collection until the function returns true and then returns the CMTag at that position. Once the callback is satisfied by returning true, CMTagCollectionApplyUntil() stops iteration and returns the CMTag that evaluated to true. If no CMTags satisfy the callback, the value kCMTagInvalid will be returned.
    ///
    /// Parameter `tagCollection`: CMTagCollectionRef to iterate.
    ///
    /// Parameter `applier`: The CMTagCollectionTagFilterFunction callback to call with each tag.
    ///
    /// Parameter `context`: A void * or NULL to pass to applier.
    ///
    /// Returns: CMTag having the value of the first tag the callback returned true for or kCMTagInvalid if none was found.
    #[cfg(feature = "CMTag")]
    pub fn CMTagCollectionApplyUntil(
        tag_collection: &CMTagCollection,
        applier: CMTagCollectionTagFilterFunction,
        context: *mut c_void,
    ) -> CMTag;
}

/// Reports if the tag collection contains no tags.
///
/// This is a convenience name for set like use but is the same as the expression: CMTagCollectionIsEmptyGetCount() == 0.
///
/// Parameter `tagCollection`: CMTagCollectionRef to iterate.
///
/// Returns: True if there are no tags, false otherwise.
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionIsEmpty(tag_collection: &CMTagCollection) -> bool {
    extern "C-unwind" {
        fn CMTagCollectionIsEmpty(tag_collection: &CMTagCollection) -> Boolean;
    }
    let ret = unsafe { CMTagCollectionIsEmpty(tag_collection) };
    ret != 0
}

extern "C-unwind" {
    /// Calculates the intersection of two tag collections to produce a new tag collection.
    ///
    /// This routine creates an intersection of two tag collection by finding common tags among two source tag collections and produces a new tag collection containing those common tags.
    ///
    /// Parameter `tagCollection1`: CMTagCollectionRef to use in the intersection operation.
    ///
    /// Parameter `tagCollection2`: CMTagCollectionRef to use in the intersection operation.
    ///
    /// Parameter `tagCollectionOut`: The address of a CMTagCollectionRef that contains all tags that are common to 'tagCollection1' and 'tagCollection2'.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    pub fn CMTagCollectionCreateIntersection(
        tag_collection1: Option<&CMTagCollection>,
        tag_collection2: Option<&CMTagCollection>,
        tag_collection_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Calculates the union of two tag collections to produce a new tag collection.
    ///
    /// This routine creates an union of two tag collection by adding all tags from two tag collections and produces a new tag collection containing all the tags. Duplicate tags will not be added twice.  Note that if no tags are common among the source tag collections, the new tag collection will contain as many tags as the sum of the number of tags in each source tag collection. If two source tag collections contain the same tags, the resulting tag collection will have the same number of tags as each source tag collection.
    ///
    /// Parameter `tagCollection1`: CMTagCollectionRef to use in the union operation.
    ///
    /// Parameter `tagCollection2`: CMTagCollectionRef to use in the union operation.
    ///
    /// Parameter `tagCollectionOut`: The address of a CMTagCollectionRef that contains all tags that are common to 'tagCollection1' and 'tagCollection2'.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    pub fn CMTagCollectionCreateUnion(
        tag_collection1: Option<&CMTagCollection>,
        tag_collection2: Option<&CMTagCollection>,
        tag_collection_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Calculates the difference of two tag collections to produce a new tag collection.
    ///
    /// This routine creates the difference by considering a first source tag collection and removing all tags found in the first tag collection to produce a new tag collection containing only the tags not in the second tag collection.  Note that if the second tag collection has no tags found in the first tag collection, the produced tag collection will have the same tags as the first tag collection. If the second tag collection is empty, the produced tag collection will also have the same tags as the first tag collection.  If the second tag collection contains all the tags found in the source tag collection, the produced tag collection will be empty.  The order of parameters is important. Given two tag collections 'A' and 'B', the calculaton of 'A' - 'B' is not the same as 'B' - 'A'.
    ///
    /// Parameter `tagCollectionMinuend`: CMTagCollectionRef from which to remove tags.
    ///
    /// Parameter `tagCollectionSubtrahend`: CMTagCollectionRef to consult to determine tags to remove from 'tagCollectionMinuend'.
    ///
    /// Parameter `tagCollectionOut`: The address of a CMTagCollectionRef that contains tags from a first tag collection without tags found in a second tag collection.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    pub fn CMTagCollectionCreateDifference(
        tag_collection_minuend: Option<&CMTagCollection>,
        tag_collection_subtrahend: Option<&CMTagCollection>,
        tag_collection_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Calculates the exclusive OR of two tag collections to produce a new tag collection.
    ///
    /// This routine determines tags that are in only one of two source tag collections and adds only those to produce a new tag collection. If both source tag collections have no tags in common, the produced tag collection will contain a union of both source tag collections. If both source tag collections have the same tags, the produced tag collection will be empty.
    ///
    /// Parameter `tagCollection1`: CMTagCollectionRef to use in the xor operation.
    ///
    /// Parameter `tagCollection2`: CMTagCollectionRef to use in the xor operation.
    ///
    /// Parameter `tagCollectionOut`: The address of a CMTagCollectionRef that contains the xor of the tags from the two tag collections.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    pub fn CMTagCollectionCreateExclusiveOr(
        tag_collection1: Option<&CMTagCollection>,
        tag_collection2: Option<&CMTagCollection>,
        tag_collection_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds a tag to a mutable tag collection guaranteeing it is only added once.
    ///
    /// This routine adds a CMTag to a CMMutableTagCollection. If the CMTag already exists in the tag collection, the tag is not added again. If the tag doesn't exist in the tag collection, the tag collection is updated to contain the tag. Note that there is no ordering for tags within a tag collection.
    ///
    /// Parameter `tagCollection`: CMMutableTagCollectionRef to which to add a tag.
    ///
    /// Parameter `tagToAdd`: A CMTag to add to the tag collection.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.  Returns noErr if the tag was already in the collection.
    #[cfg(feature = "CMTag")]
    pub fn CMTagCollectionAddTag(
        tag_collection: &CMMutableTagCollection,
        tag_to_add: CMTag,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Removes one tag from a mutable tag collection.
    ///
    /// This routine removes a CMTag if present from a CMMutableTagCollection. If the CMTag exists in the tag collection, the tag collection is updated to no longer contain the tag. If the tag doesn't exist in the tag collection, the tag collection is left unchanged.  The OSStatus will return kCMTagCollectionError_TagNotFound if the tag does not exist in the collection or if the tag collection is empty.
    ///
    /// Parameter `tagCollection`: CMMutableTagCollectionRef from which to remove a tag.
    ///
    /// Parameter `tagToRemove`: A CMTag to match to the tag collection.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    #[cfg(feature = "CMTag")]
    pub fn CMTagCollectionRemoveTag(
        tag_collection: &CMMutableTagCollection,
        tag_to_remove: CMTag,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Removes all tags from a mutable tag collection.
    ///
    /// This routine removes all CMTags from a CMMutableTagCollection producing an empty collection.
    ///
    /// Parameter `tagCollection`: CMMutableTagCollectionRef from which to remove all tags.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    pub fn CMTagCollectionRemoveAllTags(tag_collection: &CMMutableTagCollection) -> OSStatus;
}

extern "C-unwind" {
    /// Removes all tags having a specified category from a mutable tag collection.
    ///
    /// This routine removes all CMTags having a specified CMTagCategory from a CMMutableTagCollection perhaps producing an empty collection.
    ///
    /// Parameter `tagCollection`: CMMutableTagCollectionRef from which to remove all tags.
    ///
    /// Parameter `category`: CMTagCategory to match.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    #[cfg(feature = "CMTag")]
    pub fn CMTagCollectionRemoveAllTagsOfCategory(
        tag_collection: &CMMutableTagCollection,
        category: CMTagCategory,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Add all tags from one tag collection to a mutable tag collection.  Tags already existing in tagCollection will not be added.
    ///
    /// Parameter `tagCollection`: CMMutableTagCollectionRef to which to add tags.
    ///
    /// Parameter `collectionWithTagsToAdd`: CMTagCollectionRef from which to copy all tags.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    pub fn CMTagCollectionAddTagsFromCollection(
        tag_collection: &CMMutableTagCollection,
        collection_with_tags_to_add: &CMTagCollection,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds all tags specified in a C array to a mutable tag collection.  Tags already existing in tagCollection will not be added.
    ///
    /// Parameter `tagCollection`: CMMutableTagCollectionRef to which to add tags.
    ///
    /// Parameter `tags`: The address of a buffer of CMTags.
    ///
    /// Parameter `tagCount`: CMItemCount of the number of tags in 'tags' array.
    ///
    /// Returns: OSStatus indicating if the operation succeeded.
    #[cfg(all(feature = "CMBase", feature = "CMTag"))]
    pub fn CMTagCollectionAddTagsFromArray(
        tag_collection: &CMMutableTagCollection,
        tags: NonNull<CMTag>,
        tag_count: CMItemCount,
    ) -> OSStatus;
}

/// Returns a CFDictionary representation of a CMTagCollection.
///
/// This is useful when putting CMTagCollections in CF container types.
///
/// Parameter `tagCollection`: CMTagCollection to serialize as a CFDictionary.
///
/// Parameter `allocator`: CFAllocator with which to create a dictionary. Pass kCFAllocatorDefault to use the default allocator.
///
/// Returns: A CFDictionaryRef holding the serialized contents of the CMTagCollection.  The client is responsible for releasing the returned CFDictionary.
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionCopyAsDictionary(
    tag_collection: &CMTagCollection,
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CMTagCollectionCopyAsDictionary(
            tag_collection: &CMTagCollection,
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CMTagCollectionCopyAsDictionary(tag_collection, allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Reconstitutes a CMTagCollection from a CFDictionary previously created by CMTagCollectionCopyAsDictionary.
    ///
    /// This is useful when getting CMTagCollection from CF container types.  If the CFDictionary does not have the requisite keyed values, newCollectionOut will contain NULL.
    ///
    /// Parameter `dict`: A CFDictionary from which to create a CMTagCollection.
    ///
    /// Parameter `allocator`: CFAllocator to use in allocation CMTagCollectionRef
    ///
    /// Parameter `newCollectionOut`: Address of an CMTagCollectionRef to return the newly created tag collection.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus with error or noErr if successful.
    pub fn CMTagCollectionCreateFromDictionary(
        dict: &CFDictionary,
        allocator: Option<&CFAllocator>,
        new_collection_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

/// Returns a CFDataRef version of a CMTagCollection.
///
/// This is useful when putting CMTagCollections in CF container types.
///
/// Parameter `tagCollection`: CMTagCollection to serialize as a CFData.
///
/// Parameter `allocator`: CFAllocator with which to create a CFData. Pass kCFAllocatorDefault to use the default allocator.
///
/// Returns: A CFDataRef holding the serialized contents of the CMTagCollection.  The client is responsible for releasing the returned CFData.
#[inline]
pub unsafe extern "C-unwind" fn CMTagCollectionCopyAsData(
    tag_collection: &CMTagCollection,
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CMTagCollectionCopyAsData(
            tag_collection: &CMTagCollection,
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CMTagCollectionCopyAsData(tag_collection, allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Reconstitutes a CMTagCollection from a CFData previously created by CMTagCollectionCopyAsData.
    ///
    /// This is useful when getting CMTagCollection from CF container types.  If the CFData does not
    /// have the requisite keyed values, newCollectionOut will contain NULL.
    ///
    /// Parameter `data`: A CFData from which to create a CMTagCollection.
    ///
    /// Parameter `allocator`: CFAllocator to use in allocation CMTagCollectionRef.  Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `newCollectionOut`: Address of an CMTagCollectionRef to return the newly created tag collection.  The client is responsible for releasing the returned CMTagCollection.
    ///
    /// Returns: OSStatus with error or noErr if successful.
    pub fn CMTagCollectionCreateFromData(
        data: &CFData,
        allocator: Option<&CFAllocator>,
        new_collection_out: NonNull<*const CMTagCollection>,
    ) -> OSStatus;
}

extern "C" {
    /// CFDictionary key for a CFArray of serialized CMTag dictionaries of a CMTagCollection as used with CMTagCollectionCopyAsDictionary
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtagcollectiontagsarraykey?language=objc)
    pub static kCMTagCollectionTagsArrayKey: &'static CFString;
}
