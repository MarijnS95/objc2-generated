//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcproxycreating?language=objc)
    pub unsafe trait NSXPCProxyCreating {
        #[unsafe(method_family(none))]
        #[method_id(remoteObjectProxy)]
        unsafe fn remoteObjectProxy(&self) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[unsafe(method_family(none))]
        #[method_id(remoteObjectProxyWithErrorHandler:)]
        unsafe fn remoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[optional]
        #[unsafe(method_family(none))]
        #[method_id(synchronousRemoteObjectProxyWithErrorHandler:)]
        unsafe fn synchronousRemoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcconnectionoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSXPCConnectionOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSXPCConnectionOptions: NSUInteger {
        #[doc(alias = "NSXPCConnectionPrivileged")]
        const Privileged = 1<<12;
    }
}

unsafe impl Encode for NSXPCConnectionOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSXPCConnectionOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcconnection?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCConnection;
);

unsafe impl NSObjectProtocol for NSXPCConnection {}

unsafe impl NSXPCProxyCreating for NSXPCConnection {}

extern_methods!(
    unsafe impl NSXPCConnection {
        #[cfg(feature = "NSString")]
        #[unsafe(method_family(init))]
        #[method_id(initWithServiceName:)]
        pub unsafe fn initWithServiceName(
            this: Allocated<Self>,
            service_name: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[unsafe(method_family(none))]
        #[method_id(serviceName)]
        pub unsafe fn serviceName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method_family(init))]
        #[method_id(initWithMachServiceName:options:)]
        pub unsafe fn initWithMachServiceName_options(
            this: Allocated<Self>,
            name: &NSString,
            options: NSXPCConnectionOptions,
        ) -> Retained<Self>;

        #[unsafe(method_family(init))]
        #[method_id(initWithListenerEndpoint:)]
        pub unsafe fn initWithListenerEndpoint(
            this: Allocated<Self>,
            endpoint: &NSXPCListenerEndpoint,
        ) -> Retained<Self>;

        #[unsafe(method_family(none))]
        #[method_id(endpoint)]
        pub unsafe fn endpoint(&self) -> Retained<NSXPCListenerEndpoint>;

        #[unsafe(method_family(none))]
        #[method_id(exportedInterface)]
        pub unsafe fn exportedInterface(&self) -> Option<Retained<NSXPCInterface>>;

        /// Setter for [`exportedInterface`][Self::exportedInterface].
        #[method(setExportedInterface:)]
        pub unsafe fn setExportedInterface(&self, exported_interface: Option<&NSXPCInterface>);

        #[unsafe(method_family(none))]
        #[method_id(exportedObject)]
        pub unsafe fn exportedObject(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`exportedObject`][Self::exportedObject].
        #[method(setExportedObject:)]
        pub unsafe fn setExportedObject(&self, exported_object: Option<&AnyObject>);

        #[unsafe(method_family(none))]
        #[method_id(remoteObjectInterface)]
        pub unsafe fn remoteObjectInterface(&self) -> Option<Retained<NSXPCInterface>>;

        /// Setter for [`remoteObjectInterface`][Self::remoteObjectInterface].
        #[method(setRemoteObjectInterface:)]
        pub unsafe fn setRemoteObjectInterface(
            &self,
            remote_object_interface: Option<&NSXPCInterface>,
        );

        #[unsafe(method_family(none))]
        #[method_id(remoteObjectProxy)]
        pub unsafe fn remoteObjectProxy(&self) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[unsafe(method_family(none))]
        #[method_id(remoteObjectProxyWithErrorHandler:)]
        pub unsafe fn remoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[unsafe(method_family(none))]
        #[method_id(synchronousRemoteObjectProxyWithErrorHandler:)]
        pub unsafe fn synchronousRemoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;

        #[cfg(feature = "block2")]
        #[method(interruptionHandler)]
        pub unsafe fn interruptionHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`interruptionHandler`][Self::interruptionHandler].
        #[method(setInterruptionHandler:)]
        pub unsafe fn setInterruptionHandler(
            &self,
            interruption_handler: Option<&block2::Block<dyn Fn()>>,
        );

        #[cfg(feature = "block2")]
        #[method(invalidationHandler)]
        pub unsafe fn invalidationHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`invalidationHandler`][Self::invalidationHandler].
        #[method(setInvalidationHandler:)]
        pub unsafe fn setInvalidationHandler(
            &self,
            invalidation_handler: Option<&block2::Block<dyn Fn()>>,
        );

        #[method(resume)]
        pub unsafe fn resume(&self);

        #[method(suspend)]
        pub unsafe fn suspend(&self);

        #[method(activate)]
        pub unsafe fn activate(&self);

        #[method(invalidate)]
        pub unsafe fn invalidate(&self);

        #[cfg(feature = "libc")]
        #[method(processIdentifier)]
        pub unsafe fn processIdentifier(&self) -> libc::pid_t;

        #[cfg(feature = "libc")]
        #[method(effectiveUserIdentifier)]
        pub unsafe fn effectiveUserIdentifier(&self) -> libc::uid_t;

        #[cfg(feature = "libc")]
        #[method(effectiveGroupIdentifier)]
        pub unsafe fn effectiveGroupIdentifier(&self) -> libc::gid_t;

        #[unsafe(method_family(none))]
        #[method_id(currentConnection)]
        pub unsafe fn currentConnection() -> Option<Retained<NSXPCConnection>>;

        #[cfg(feature = "block2")]
        #[method(scheduleSendBarrierBlock:)]
        pub unsafe fn scheduleSendBarrierBlock(&self, block: &block2::Block<dyn Fn()>);

        #[cfg(feature = "NSString")]
        /// Sets the code signing requirement for this connection. If the requirement is malformed, an exception is thrown. If new messages do not match the requirement, the connection is invalidated. It is recommended to set this before calling `resume`, as it is an XPC error to call it more than once.
        /// See https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html for more information on the format.
        #[method(setCodeSigningRequirement:)]
        pub unsafe fn setCodeSigningRequirement(&self, requirement: &NSString);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCConnection {
        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpclistener?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCListener;
);

unsafe impl NSObjectProtocol for NSXPCListener {}

extern_methods!(
    unsafe impl NSXPCListener {
        #[unsafe(method_family(none))]
        #[method_id(serviceListener)]
        pub unsafe fn serviceListener() -> Retained<NSXPCListener>;

        #[unsafe(method_family(none))]
        #[method_id(anonymousListener)]
        pub unsafe fn anonymousListener() -> Retained<NSXPCListener>;

        #[cfg(feature = "NSString")]
        #[unsafe(method_family(init))]
        #[method_id(initWithMachServiceName:)]
        pub unsafe fn initWithMachServiceName(
            this: Allocated<Self>,
            name: &NSString,
        ) -> Retained<Self>;

        #[unsafe(method_family(none))]
        #[method_id(delegate)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSXPCListenerDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSXPCListenerDelegate>>,
        );

        #[unsafe(method_family(none))]
        #[method_id(endpoint)]
        pub unsafe fn endpoint(&self) -> Retained<NSXPCListenerEndpoint>;

        #[method(resume)]
        pub unsafe fn resume(&self);

        #[method(suspend)]
        pub unsafe fn suspend(&self);

        #[method(activate)]
        pub unsafe fn activate(&self);

        #[method(invalidate)]
        pub unsafe fn invalidate(&self);

        #[cfg(feature = "NSString")]
        /// Sets the code signing requirement for new connections. If the requirement is malformed, an exception is thrown. If new peer connections do not match the requirement, the incoming connection is automatically rejected before consulting the delegate.
        /// This method will only work on `anonymousListener` or `initWithMachServiceName` listener instances. Use on other types of listeners will result in an assertion failure.
        /// See https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html for more information on the format.
        #[method(setConnectionCodeSigningRequirement:)]
        pub unsafe fn setConnectionCodeSigningRequirement(&self, requirement: &NSString);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCListener {
        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpclistenerdelegate?language=objc)
    pub unsafe trait NSXPCListenerDelegate: NSObjectProtocol {
        #[optional]
        #[method(listener:shouldAcceptNewConnection:)]
        unsafe fn listener_shouldAcceptNewConnection(
            &self,
            listener: &NSXPCListener,
            new_connection: &NSXPCConnection,
        ) -> bool;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcinterface?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCInterface;
);

unsafe impl NSObjectProtocol for NSXPCInterface {}

extern_methods!(
    unsafe impl NSXPCInterface {
        #[unsafe(method_family(none))]
        #[method_id(interfaceWithProtocol:)]
        pub unsafe fn interfaceWithProtocol(protocol: &AnyProtocol) -> Retained<NSXPCInterface>;

        #[unsafe(method_family(none))]
        #[method_id(protocol)]
        pub unsafe fn protocol(&self) -> Retained<AnyProtocol>;

        /// Setter for [`protocol`][Self::protocol].
        #[method(setProtocol:)]
        pub unsafe fn setProtocol(&self, protocol: &AnyProtocol);

        #[cfg(feature = "NSSet")]
        #[method(setClasses:forSelector:argumentIndex:ofReply:)]
        pub unsafe fn setClasses_forSelector_argumentIndex_ofReply(
            &self,
            classes: &NSSet<AnyClass>,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        );

        #[cfg(feature = "NSSet")]
        #[unsafe(method_family(none))]
        #[method_id(classesForSelector:argumentIndex:ofReply:)]
        pub unsafe fn classesForSelector_argumentIndex_ofReply(
            &self,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        ) -> Retained<NSSet<AnyClass>>;

        #[method(setInterface:forSelector:argumentIndex:ofReply:)]
        pub unsafe fn setInterface_forSelector_argumentIndex_ofReply(
            &self,
            ifc: &NSXPCInterface,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        );

        #[unsafe(method_family(none))]
        #[method_id(interfaceForSelector:argumentIndex:ofReply:)]
        pub unsafe fn interfaceForSelector_argumentIndex_ofReply(
            &self,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        ) -> Option<Retained<NSXPCInterface>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCInterface {
        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpclistenerendpoint?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCListenerEndpoint;
);

unsafe impl Send for NSXPCListenerEndpoint {}

unsafe impl Sync for NSXPCListenerEndpoint {}

#[cfg(feature = "NSObject")]
unsafe impl NSCoding for NSXPCListenerEndpoint {}

unsafe impl NSObjectProtocol for NSXPCListenerEndpoint {}

#[cfg(feature = "NSObject")]
unsafe impl NSSecureCoding for NSXPCListenerEndpoint {}

extern_methods!(
    unsafe impl NSXPCListenerEndpoint {}
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCListenerEndpoint {
        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpccoder?language=objc)
    #[unsafe(super(NSCoder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSCoder")]
    pub struct NSXPCCoder;
);

#[cfg(feature = "NSCoder")]
unsafe impl NSObjectProtocol for NSXPCCoder {}

extern_methods!(
    #[cfg(feature = "NSCoder")]
    unsafe impl NSXPCCoder {
        #[unsafe(method_family(none))]
        #[method_id(userInfo)]
        pub unsafe fn userInfo(&self) -> Option<Retained<ProtocolObject<dyn NSObjectProtocol>>>;

        /// Setter for [`userInfo`][Self::userInfo].
        #[method(setUserInfo:)]
        pub unsafe fn setUserInfo(&self, user_info: Option<&ProtocolObject<dyn NSObjectProtocol>>);

        #[unsafe(method_family(none))]
        #[method_id(connection)]
        pub unsafe fn connection(&self) -> Option<Retained<NSXPCConnection>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "NSCoder")]
    unsafe impl NSXPCCoder {
        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
