//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcproxycreating?language=objc)
    pub unsafe trait NSXPCProxyCreating {
        #[method_id(@__retain_semantics Other remoteObjectProxy)]
        unsafe fn remoteObjectProxy(&self) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[method_id(@__retain_semantics Other remoteObjectProxyWithErrorHandler:)]
        unsafe fn remoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[optional]
        #[method_id(@__retain_semantics Other synchronousRemoteObjectProxyWithErrorHandler:)]
        unsafe fn synchronousRemoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;
    }

    unsafe impl ProtocolType for dyn NSXPCProxyCreating {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcconnectionoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSXPCConnectionOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSXPCConnectionOptions: NSUInteger {
        const NSXPCConnectionPrivileged = 1<<12;
    }
}

unsafe impl Encode for NSXPCConnectionOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSXPCConnectionOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcconnection?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCConnection;
);

unsafe impl NSObjectProtocol for NSXPCConnection {}

unsafe impl NSXPCProxyCreating for NSXPCConnection {}

extern_methods!(
    unsafe impl NSXPCConnection {
        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Init initWithServiceName:)]
        pub unsafe fn initWithServiceName(
            this: Allocated<Self>,
            service_name: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Other serviceName)]
        pub unsafe fn serviceName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Init initWithMachServiceName:options:)]
        pub unsafe fn initWithMachServiceName_options(
            this: Allocated<Self>,
            name: &NSString,
            options: NSXPCConnectionOptions,
        ) -> Retained<Self>;

        #[method_id(@__retain_semantics Init initWithListenerEndpoint:)]
        pub unsafe fn initWithListenerEndpoint(
            this: Allocated<Self>,
            endpoint: &NSXPCListenerEndpoint,
        ) -> Retained<Self>;

        #[method_id(@__retain_semantics Other endpoint)]
        pub unsafe fn endpoint(&self) -> Retained<NSXPCListenerEndpoint>;

        #[method_id(@__retain_semantics Other exportedInterface)]
        pub unsafe fn exportedInterface(&self) -> Option<Retained<NSXPCInterface>>;

        /// Setter for [`exportedInterface`][Self::exportedInterface].
        #[method(setExportedInterface:)]
        pub unsafe fn setExportedInterface(&self, exported_interface: Option<&NSXPCInterface>);

        #[method_id(@__retain_semantics Other exportedObject)]
        pub unsafe fn exportedObject(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`exportedObject`][Self::exportedObject].
        #[method(setExportedObject:)]
        pub unsafe fn setExportedObject(&self, exported_object: Option<&AnyObject>);

        #[method_id(@__retain_semantics Other remoteObjectInterface)]
        pub unsafe fn remoteObjectInterface(&self) -> Option<Retained<NSXPCInterface>>;

        /// Setter for [`remoteObjectInterface`][Self::remoteObjectInterface].
        #[method(setRemoteObjectInterface:)]
        pub unsafe fn setRemoteObjectInterface(
            &self,
            remote_object_interface: Option<&NSXPCInterface>,
        );

        #[method_id(@__retain_semantics Other remoteObjectProxy)]
        pub unsafe fn remoteObjectProxy(&self) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[method_id(@__retain_semantics Other remoteObjectProxyWithErrorHandler:)]
        pub unsafe fn remoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        #[method_id(@__retain_semantics Other synchronousRemoteObjectProxyWithErrorHandler:)]
        pub unsafe fn synchronousRemoteObjectProxyWithErrorHandler(
            &self,
            handler: &block2::Block<dyn Fn(NonNull<NSError>)>,
        ) -> Retained<AnyObject>;

        #[cfg(feature = "block2")]
        #[method(interruptionHandler)]
        pub unsafe fn interruptionHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`interruptionHandler`][Self::interruptionHandler].
        #[method(setInterruptionHandler:)]
        pub unsafe fn setInterruptionHandler(
            &self,
            interruption_handler: Option<&block2::Block<dyn Fn()>>,
        );

        #[cfg(feature = "block2")]
        #[method(invalidationHandler)]
        pub unsafe fn invalidationHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`invalidationHandler`][Self::invalidationHandler].
        #[method(setInvalidationHandler:)]
        pub unsafe fn setInvalidationHandler(
            &self,
            invalidation_handler: Option<&block2::Block<dyn Fn()>>,
        );

        #[method(resume)]
        pub unsafe fn resume(&self);

        #[method(suspend)]
        pub unsafe fn suspend(&self);

        #[method(activate)]
        pub unsafe fn activate(&self);

        #[method(invalidate)]
        pub unsafe fn invalidate(&self);

        #[cfg(feature = "libc")]
        #[method(processIdentifier)]
        pub unsafe fn processIdentifier(&self) -> libc::pid_t;

        #[cfg(feature = "libc")]
        #[method(effectiveUserIdentifier)]
        pub unsafe fn effectiveUserIdentifier(&self) -> libc::uid_t;

        #[cfg(feature = "libc")]
        #[method(effectiveGroupIdentifier)]
        pub unsafe fn effectiveGroupIdentifier(&self) -> libc::gid_t;

        #[method_id(@__retain_semantics Other currentConnection)]
        pub unsafe fn currentConnection() -> Option<Retained<NSXPCConnection>>;

        #[cfg(feature = "block2")]
        #[method(scheduleSendBarrierBlock:)]
        pub unsafe fn scheduleSendBarrierBlock(&self, block: &block2::Block<dyn Fn()>);

        #[cfg(feature = "NSString")]
        /// Sets the code signing requirement for this connection. If the requirement is malformed, an exception is thrown. If new messages do not match the requirement, the connection is invalidated. It is recommended to set this before calling `resume`, as it is an XPC error to call it more than once.
        /// See https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html for more information on the format.
        #[method(setCodeSigningRequirement:)]
        pub unsafe fn setCodeSigningRequirement(&self, requirement: &NSString);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCConnection {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpclistener?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCListener;
);

unsafe impl NSObjectProtocol for NSXPCListener {}

extern_methods!(
    unsafe impl NSXPCListener {
        #[method_id(@__retain_semantics Other serviceListener)]
        pub unsafe fn serviceListener() -> Retained<NSXPCListener>;

        #[method_id(@__retain_semantics Other anonymousListener)]
        pub unsafe fn anonymousListener() -> Retained<NSXPCListener>;

        #[cfg(feature = "NSString")]
        #[method_id(@__retain_semantics Init initWithMachServiceName:)]
        pub unsafe fn initWithMachServiceName(
            this: Allocated<Self>,
            name: &NSString,
        ) -> Retained<Self>;

        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSXPCListenerDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSXPCListenerDelegate>>,
        );

        #[method_id(@__retain_semantics Other endpoint)]
        pub unsafe fn endpoint(&self) -> Retained<NSXPCListenerEndpoint>;

        #[method(resume)]
        pub unsafe fn resume(&self);

        #[method(suspend)]
        pub unsafe fn suspend(&self);

        #[method(activate)]
        pub unsafe fn activate(&self);

        #[method(invalidate)]
        pub unsafe fn invalidate(&self);

        #[cfg(feature = "NSString")]
        /// Sets the code signing requirement for new connections. If the requirement is malformed, an exception is thrown. If new peer connections do not match the requirement, the incoming connection is automatically rejected before consulting the delegate.
        /// This method will only work on `anonymousListener` or `initWithMachServiceName` listener instances. Use on other types of listeners will result in an assertion failure.
        /// See https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html for more information on the format.
        #[method(setConnectionCodeSigningRequirement:)]
        pub unsafe fn setConnectionCodeSigningRequirement(&self, requirement: &NSString);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCListener {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpclistenerdelegate?language=objc)
    pub unsafe trait NSXPCListenerDelegate: NSObjectProtocol {
        #[optional]
        #[method(listener:shouldAcceptNewConnection:)]
        unsafe fn listener_shouldAcceptNewConnection(
            &self,
            listener: &NSXPCListener,
            new_connection: &NSXPCConnection,
        ) -> bool;
    }

    unsafe impl ProtocolType for dyn NSXPCListenerDelegate {}
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpcinterface?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCInterface;
);

unsafe impl NSObjectProtocol for NSXPCInterface {}

extern_methods!(
    unsafe impl NSXPCInterface {
        #[method_id(@__retain_semantics Other interfaceWithProtocol:)]
        pub unsafe fn interfaceWithProtocol(protocol: &AnyProtocol) -> Retained<NSXPCInterface>;

        #[method_id(@__retain_semantics Other protocol)]
        pub unsafe fn protocol(&self) -> Retained<AnyProtocol>;

        /// Setter for [`protocol`][Self::protocol].
        #[method(setProtocol:)]
        pub unsafe fn setProtocol(&self, protocol: &AnyProtocol);

        #[cfg(feature = "NSSet")]
        #[method(setClasses:forSelector:argumentIndex:ofReply:)]
        pub unsafe fn setClasses_forSelector_argumentIndex_ofReply(
            &self,
            classes: &NSSet<AnyClass>,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        );

        #[cfg(feature = "NSSet")]
        #[method_id(@__retain_semantics Other classesForSelector:argumentIndex:ofReply:)]
        pub unsafe fn classesForSelector_argumentIndex_ofReply(
            &self,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        ) -> Retained<NSSet<AnyClass>>;

        #[method(setInterface:forSelector:argumentIndex:ofReply:)]
        pub unsafe fn setInterface_forSelector_argumentIndex_ofReply(
            &self,
            ifc: &NSXPCInterface,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        );

        #[method_id(@__retain_semantics Other interfaceForSelector:argumentIndex:ofReply:)]
        pub unsafe fn interfaceForSelector_argumentIndex_ofReply(
            &self,
            sel: Sel,
            arg: NSUInteger,
            of_reply: bool,
        ) -> Option<Retained<NSXPCInterface>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCInterface {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpclistenerendpoint?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSXPCListenerEndpoint;
);

unsafe impl Send for NSXPCListenerEndpoint {}

unsafe impl Sync for NSXPCListenerEndpoint {}

#[cfg(feature = "NSObject")]
unsafe impl NSCoding for NSXPCListenerEndpoint {}

unsafe impl NSObjectProtocol for NSXPCListenerEndpoint {}

#[cfg(feature = "NSObject")]
unsafe impl NSSecureCoding for NSXPCListenerEndpoint {}

extern_methods!(
    unsafe impl NSXPCListenerEndpoint {}
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NSXPCListenerEndpoint {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/foundation/nsxpccoder?language=objc)
    #[unsafe(super(NSCoder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSCoder")]
    pub struct NSXPCCoder;
);

#[cfg(feature = "NSCoder")]
unsafe impl NSObjectProtocol for NSXPCCoder {}

extern_methods!(
    #[cfg(feature = "NSCoder")]
    unsafe impl NSXPCCoder {
        #[method_id(@__retain_semantics Other userInfo)]
        pub unsafe fn userInfo(&self) -> Option<Retained<ProtocolObject<dyn NSObjectProtocol>>>;

        /// Setter for [`userInfo`][Self::userInfo].
        #[method(setUserInfo:)]
        pub unsafe fn setUserInfo(&self, user_info: Option<&ProtocolObject<dyn NSObjectProtocol>>);

        #[method_id(@__retain_semantics Other connection)]
        pub unsafe fn connection(&self) -> Option<Retained<NSXPCConnection>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "NSCoder")]
    unsafe impl NSXPCCoder {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
