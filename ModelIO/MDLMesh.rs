//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// convenience object to quickly access vertex attribute data
    ///
    /// created by MDLMesh's vertexAttributeData selector
    /// Setting values on this object has no effect on the
    /// underlying objects.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlvertexattributedata?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLVertexAttributeData;
);

unsafe impl NSObjectProtocol for MDLVertexAttributeData {}

extern_methods!(
    unsafe impl MDLVertexAttributeData {
        #[cfg(feature = "MDLMeshBuffer")]
        #[method_id(map)]
        #[unsafe(method_family = none)]
        pub unsafe fn map(&self) -> Retained<MDLMeshBufferMap>;

        #[cfg(feature = "MDLMeshBuffer")]
        /// Setter for [`map`][Self::map].
        #[method(setMap:)]
        pub unsafe fn setMap(&self, map: &MDLMeshBufferMap);

        #[method(dataStart)]
        pub unsafe fn dataStart(&self) -> NonNull<c_void>;

        /// Setter for [`dataStart`][Self::dataStart].
        #[method(setDataStart:)]
        pub unsafe fn setDataStart(&self, data_start: NonNull<c_void>);

        #[method(stride)]
        pub unsafe fn stride(&self) -> NSUInteger;

        /// Setter for [`stride`][Self::stride].
        #[method(setStride:)]
        pub unsafe fn setStride(&self, stride: NSUInteger);

        #[cfg(feature = "MDLVertexDescriptor")]
        #[method(format)]
        pub unsafe fn format(&self) -> MDLVertexFormat;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Setter for [`format`][Self::format].
        #[method(setFormat:)]
        pub unsafe fn setFormat(&self, format: MDLVertexFormat);

        #[method(bufferSize)]
        pub unsafe fn bufferSize(&self) -> NSUInteger;

        /// Setter for [`bufferSize`][Self::bufferSize].
        #[method(setBufferSize:)]
        pub unsafe fn setBufferSize(&self, buffer_size: NSUInteger);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MDLVertexAttributeData {
        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// A vertex buffer with info to interpret vertex data
    ///
    /// Includes a collection of submeshs which have indexbuffer and
    /// material information
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmesh?language=objc)
    #[unsafe(super(MDLObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MDLObject")]
    pub struct MDLMesh;
);

#[cfg(all(feature = "MDLObject", feature = "MDLTypes"))]
unsafe impl MDLNamed for MDLMesh {}

#[cfg(feature = "MDLObject")]
unsafe impl NSObjectProtocol for MDLMesh {}

extern_methods!(
    #[cfg(feature = "MDLObject")]
    unsafe impl MDLMesh {
        #[cfg(feature = "MDLMeshBuffer")]
        /// Initialize a mesh with an allocator
        ///
        /// Returns: An empty mesh
        #[method_id(initWithBufferAllocator:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBufferAllocator(
            this: Allocated<Self>,
            buffer_allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "MDLMeshBuffer",
            feature = "MDLSubmesh",
            feature = "MDLVertexDescriptor"
        ))]
        /// Initialize object with a vertex buffer and a collection of submeshes
        ///
        /// Returns: Initialized mesh or nil if descriptor's layout array does not describe
        /// a single buffer
        ///
        /// Parameter `vertexBuffer`: MDLMeshBuffer object containing all vertex data for the mesh
        ///
        /// Parameter `vertexCount`: Number of vertices in the vertexBuffer
        ///
        /// Parameter `descriptor`: VertexDescriptor specifying how to interpret vertex data
        ///
        /// Parameter `submeshes`: Array of submeshes with index buffers referencing vertex data
        /// and/or materials to be applied to mesh
        #[method_id(initWithVertexBuffer:vertexCount:descriptor:submeshes:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithVertexBuffer_vertexCount_descriptor_submeshes(
            this: Allocated<Self>,
            vertex_buffer: &ProtocolObject<dyn MDLMeshBuffer>,
            vertex_count: NSUInteger,
            descriptor: &MDLVertexDescriptor,
            submeshes: &NSArray<MDLSubmesh>,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "MDLMeshBuffer",
            feature = "MDLSubmesh",
            feature = "MDLVertexDescriptor"
        ))]
        /// Initialize object with an array of vertex buffers (Structure of
        /// Arrays) and a collection of submeshes
        ///
        /// Returns: Initialized mesh or nil if descriptor's layout array is incompatible
        /// with vertexBuffers array
        ///
        /// Parameter `vertexCount`: Number of vertices in vertexBuffers
        ///
        /// Parameter `descriptor`: VertexDescriptor specifying how to interpret vertex data
        ///
        /// Parameter `submeshes`: Array of submeshes with index buffers referencing vertex data
        /// and/or materials to be applied to mesh
        ///
        /// Allows initialization with the layout of the vertexBuffers in a
        /// structure-of-arrays form, in other words, non-interleaved vertex attributes
        #[method_id(initWithVertexBuffers:vertexCount:descriptor:submeshes:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithVertexBuffers_vertexCount_descriptor_submeshes(
            this: Allocated<Self>,
            vertex_buffers: &NSArray<ProtocolObject<dyn MDLMeshBuffer>>,
            vertex_count: NSUInteger,
            descriptor: &MDLVertexDescriptor,
            submeshes: &NSArray<MDLSubmesh>,
        ) -> Retained<Self>;

        /// convenience selector to get quick access to vertex attribute data
        ///
        /// the vertex buffer will remain mapped until the MDLVertexAttributeData
        /// is freed.
        #[method_id(vertexAttributeDataForAttributeNamed:)]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexAttributeDataForAttributeNamed(
            &self,
            name: &NSString,
        ) -> Option<Retained<MDLVertexAttributeData>>;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// convenience selector to get quick access to vertex attribute data
        /// reformatted to the requested format if necessary.
        ///
        /// If the desired format has less elements than the source attribute
        /// elements, excess elements will be discarded. If the desired format
        /// has more elements than the source attribute, then the destination
        /// elements will be set to zero.
        /// The vertex buffer will remain mapped until the MDLVertexAttributeData
        /// is freed.
        #[method_id(vertexAttributeDataForAttributeNamed:asFormat:)]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexAttributeDataForAttributeNamed_asFormat(
            &self,
            name: &NSString,
            format: MDLVertexFormat,
        ) -> Option<Retained<MDLVertexAttributeData>>;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Immutable vertex descriptor for interpreting data in vertexBuffers
        ///
        /// Setting this applies the new layout in 'vertexBuffers' thus is a
        /// heavyweight operation as structured copies of almost all vertex
        /// buffer data could be made.  Additionally, if the new vertexDescriptor
        /// does not have an attribute in the original vertexDescriptor, that
        /// attribute will be deleted.  If the original vertexDescriptor does
        /// not have an attribute in the new vertexDescriptor, the data for the
        /// added attribute set as the added attribute's initializationValue
        /// property.
        ///
        /// The allocator associated with each original meshbuffer is used to
        /// reallocate the corresponding resultant meshbuffer.
        #[method_id(vertexDescriptor)]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexDescriptor(&self) -> Retained<MDLVertexDescriptor>;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Setter for [`vertexDescriptor`][Self::vertexDescriptor].
        #[method(setVertexDescriptor:)]
        pub unsafe fn setVertexDescriptor(&self, vertex_descriptor: &MDLVertexDescriptor);

        /// Number of vertices in the vertexBuffers
        ///
        /// The size of vertex data in each buffer can be computed by multiplying
        /// this value with the stride of the buffer in the vertexDescriptor's
        /// layout
        #[method(vertexCount)]
        pub unsafe fn vertexCount(&self) -> NSUInteger;

        /// Setter for [`vertexCount`][Self::vertexCount].
        #[method(setVertexCount:)]
        pub unsafe fn setVertexCount(&self, vertex_count: NSUInteger);

        #[cfg(feature = "MDLMeshBuffer")]
        /// Array of buffers containing vertex data
        ///
        /// The vertex buffers in this array are indexed by the vertex descriptor.
        #[method_id(vertexBuffers)]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexBuffers(&self) -> Retained<NSArray<ProtocolObject<dyn MDLMeshBuffer>>>;

        #[cfg(feature = "MDLMeshBuffer")]
        /// Setter for [`vertexBuffers`][Self::vertexBuffers].
        #[method(setVertexBuffers:)]
        pub unsafe fn setVertexBuffers(
            &self,
            vertex_buffers: &NSArray<ProtocolObject<dyn MDLMeshBuffer>>,
        );

        #[cfg(feature = "MDLSubmesh")]
        /// Array of submeshes containing an indexbuffer referencing the vertex
        /// data and material to be applied when the mesh is rendered
        #[method_id(submeshes)]
        #[unsafe(method_family = none)]
        pub unsafe fn submeshes(&self) -> Option<Retained<NSMutableArray<MDLSubmesh>>>;

        #[cfg(feature = "MDLSubmesh")]
        /// Setter for [`submeshes`][Self::submeshes].
        #[method(setSubmeshes:)]
        pub unsafe fn setSubmeshes(&self, submeshes: Option<&NSMutableArray<MDLSubmesh>>);

        #[cfg(feature = "MDLMeshBuffer")]
        /// allocator used to allocate contained mesh buffers
        #[method_id(allocator)]
        #[unsafe(method_family = none)]
        pub unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "MDLObject")]
    unsafe impl MDLMesh {
        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_methods!(
    /// Modifiers
    #[cfg(feature = "MDLObject")]
    unsafe impl MDLMesh {
        #[cfg(feature = "MDLVertexDescriptor")]
        /// Convenience method to add an attribute
        ///
        /// The mesh's allocator will be used to create storage for the new
        /// attribute.
        #[method(addAttributeWithName:format:)]
        pub unsafe fn addAttributeWithName_format(&self, name: &NSString, format: MDLVertexFormat);

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Create a new vertex attribute including an associated buffer with
        /// a copy of the supplied data, and update the vertex descriptor accordingly
        ///
        /// Parameter `name`: The name the attribute can be found by
        ///
        /// Parameter `format`: Format of the data, such as MDLVertexFormatFloat3
        ///
        /// Parameter `type`: The usage of the attribute, such as MDLVertexAttributePosition
        ///
        /// Parameter `data`: Object containing the data to be used in the new vertex buffer
        ///
        /// Parameter `stride`: The increment in bytes from the start of one data entry to
        /// the next.
        #[method(addAttributeWithName:format:type:data:stride:)]
        pub unsafe fn addAttributeWithName_format_type_data_stride(
            &self,
            name: &NSString,
            format: MDLVertexFormat,
            r#type: &NSString,
            data: &NSData,
            stride: NSInteger,
        );

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Create a new vertex attribute including an associated buffer with
        /// a copy of the supplied data, and update the vertex descriptor accordingly
        ///
        /// Parameter `name`: The name the attribute can be found by
        ///
        /// Parameter `format`: Format of the data, such as MDLVertexFormatFloat3
        ///
        /// Parameter `type`: The usage of the attribute, such as MDLVertexAttributePosition
        ///
        /// Parameter `data`: Object containing the data to be used in the new vertex buffer
        ///
        /// Parameter `stride`: The increment in bytes from the start of one data entry to
        /// the next.
        ///
        /// Parameter `time`: The time the attribute is to be invoked at.
        ///
        /// Adding an attribute, such as position data, at multiple times will
        /// result in attributes being created for each of those times.
        /// Attributes corresponding to multiple times can be retrieved from
        /// the vertex descriptor.
        #[method(addAttributeWithName:format:type:data:stride:time:)]
        pub unsafe fn addAttributeWithName_format_type_data_stride_time(
            &self,
            name: &NSString,
            format: MDLVertexFormat,
            r#type: &NSString,
            data: &NSData,
            stride: NSInteger,
            time: NSTimeInterval,
        );

        /// Calculate and add vertex normal data
        ///
        /// Parameter `attributeName`: Name is the attribute name of vertex normal attribute.  If nil, vertex normals
        /// will be added with the MDLVertexAttributeNormal name string
        ///
        /// Parameter `creaseThreshold`: Threshold of the dot product between the 2 triangles after which
        /// their face normal will be smoothed out. Therefore, a threshold of 0 will
        /// smooth everything and a threshold of 1 won't smooth anything.
        ///
        /// Uses the attribute named MDLVertexAttributePosition to calculate
        /// vertex normals. If the mesh does not have an attribute with
        /// 'attributeName', it will be added, otherwise the attribute name will
        /// be overwritten with vertex normal data. 'vertexDescriptor' will be
        /// updated to reflect the new attribute.
        #[method(addNormalsWithAttributeNamed:creaseThreshold:)]
        pub unsafe fn addNormalsWithAttributeNamed_creaseThreshold(
            &self,
            attribute_name: Option<&NSString>,
            crease_threshold: c_float,
        );

        /// Create a shader basis where the tangent and bitangent span the uv -> object space transform
        ///
        /// Parameter `textureCoordinateAttributeName`: Name of texture coordinates to use in calculations
        ///
        /// Parameter `tangentAttributeName`: Name of vertex tangent attribute.
        ///
        /// Parameter `bitangentAttributeName`: Name of vertex bitangent attribute.
        ///
        /// Uses the attribute named MDLVertexAttributePosition and
        /// textureCoordinateAttributeName to calculate tangent and bitangent
        /// attributes. The mesh's vertexDescriptor will be updated to reflect
        /// the new attributes if necessary. The basis may not be orthogonal; to gaurantee an orthogonal
        /// tangent basis please use addOrthTanBasisForTextureCoordinateAttibuteNamed selector.
        #[method(addTangentBasisForTextureCoordinateAttributeNamed:tangentAttributeNamed:bitangentAttributeNamed:)]
        pub unsafe fn addTangentBasisForTextureCoordinateAttributeNamed_tangentAttributeNamed_bitangentAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
            tangent_attribute_name: &NSString,
            bitangent_attribute_name: Option<&NSString>,
        );

        /// Create tangents which are orthogonal to the normal
        ///
        /// Parameter `textureCoordinateAttributeName`: texture coordinates to use in calculations
        ///
        /// Parameter `normalAttributeName`: normals to use in calculations
        ///
        /// Parameter `tangentAttributeName`: Name of a four component vertex tangent attribute.
        ///
        /// Uses the attribute named MDLVertexAttributePosition and
        /// textureCoordinateAttributeName and the specified normals to calculate
        /// tangent information. The mesh's vertexDescriptor will be updated to
        /// reflect the new attribute if necessary.
        /// Note that this method does NOT produce a T.w component which is used in B = (N x T) * T.w
        /// Please use addOrthTanBasisForTextureCoordinateAttributeNamed.
        #[method(addTangentBasisForTextureCoordinateAttributeNamed:normalAttributeNamed:tangentAttributeNamed:)]
        pub unsafe fn addTangentBasisForTextureCoordinateAttributeNamed_normalAttributeNamed_tangentAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
            normal_attribute_name: &NSString,
            tangent_attribute_name: &NSString,
        );

        #[method(addOrthTanBasisForTextureCoordinateAttributeNamed:normalAttributeNamed:tangentAttributeNamed:)]
        pub unsafe fn addOrthTanBasisForTextureCoordinateAttributeNamed_normalAttributeNamed_tangentAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
            normal_attribute_name: &NSString,
            tangent_attribute_name: &NSString,
        );

        /// Creates texture coordinates by unwrapping the mesh
        ///
        /// Parameter `textureCoordinateAttributeName`: texture coordinates to modify or create
        ///
        /// Uses the attribute named MDLVertexAttributePosition and if available,
        /// the attribute named MDLVertexAttributeNormal to calculate texture coordinates
        #[method(addUnwrappedTextureCoordinatesForAttributeNamed:)]
        pub unsafe fn addUnwrappedTextureCoordinatesForAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
        );

        /// Flips texture coordinates by performing the operation (u,v) = (u, 1-v)
        ///
        /// Parameter `textureCoordinateAttributeName`: texture coordinates to modify
        ///
        /// Many application generate model files with texture coordinate mapping
        /// assuming a bottom left bitmap origin. It can be more convenient to
        /// have texture coordinates corresponding to an upper left bitmap origin.
        /// This selector will perform the flip operation if the requested texture
        /// coordinate attribute exists on the mesh. An exception will be raised if
        /// the attribute cannot be found
        #[method(flipTextureCoordinatesInAttributeNamed:)]
        pub unsafe fn flipTextureCoordinatesInAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
        );

        /// Deindexes the vertex array
        ///
        /// If any vertices are shared on multiple faces, duplicate those
        /// vertices so faces do not share vertices. The vertex buffer and index
        /// buffers on submeshes may grow to accomadate any vertices added.
        #[deprecated]
        #[method(makeVerticesUnique)]
        pub unsafe fn makeVerticesUnique(&self);

        /// Deindexes the vertex array
        ///
        /// If any vertices are shared on multiple faces, duplicate those
        /// vertices so faces do not share vertices. The vertex buffer and index
        /// buffers on submeshes may grow to accomadate any vertices added.
        #[method(makeVerticesUniqueAndReturnError:_)]
        pub unsafe fn makeVerticesUniqueAndReturnError(&self) -> Result<(), Retained<NSError>>;

        /// replace existing attribute data with new attribute data retaining
        /// the format of the replacement data.
        ///
        /// If the specified attribute does not already exist, it will be
        /// created.
        #[method(replaceAttributeNamed:withData:)]
        pub unsafe fn replaceAttributeNamed_withData(
            &self,
            name: &NSString,
            new_data: &MDLVertexAttributeData,
        );

        /// update existing attribute data with new attribute data retaining
        /// the format of the existing data.
        ///
        /// If the specified attribute does not already exist, it will be
        /// created with the same format as the newData.
        #[method(updateAttributeNamed:withData:)]
        pub unsafe fn updateAttributeNamed_withData(
            &self,
            name: &NSString,
            new_data: &MDLVertexAttributeData,
        );

        /// remove an attribute
        ///
        /// if the named attribute does not exist, nothing happens.
        #[method(removeAttributeNamed:)]
        pub unsafe fn removeAttributeNamed(&self, name: &NSString);
    }
);

extern_methods!(
    /// Generators
    #[cfg(feature = "MDLObject")]
    unsafe impl MDLMesh {
        #[cfg(feature = "MDLMeshBuffer")]
        /// Factory method that generates a subdivided mesh from a source mesh
        ///
        /// Parameter `mesh`: Mesh from which to generate a subdivided mesh
        ///
        /// Parameter `submeshIndex`: Index of submesh in Mesh's submesh array from which to
        /// generate a subdivided mesh
        ///
        /// Parameter `subdivisionLevels`: The number of levels to subdivide mesh
        ///
        /// Subdivision levels over four are likely to generate more triangles
        /// than can be reasonably displayed. Index and vertex data will use
        /// the same allocator used for the source mesh. Loading an asset
        /// using the topology preservation flag set to YES will result in the
        /// best subdivision results.
        ///
        /// Returns: Returns a mesh subdivided to index level, unless subdivision is
        /// impossible.
        #[method_id(initMeshBySubdividingMesh:submeshIndex:subdivisionLevels:allocator:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initMeshBySubdividingMesh_submeshIndex_subdivisionLevels_allocator(
            this: Allocated<Self>,
            mesh: &MDLMesh,
            submesh_index: c_int,
            subdivision_levels: c_uint,
            allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "MDLMeshBuffer", feature = "MDLTypes"))]
        #[method_id(newIcosahedronWithRadius:inwardNormals:geometryType:allocator:)]
        #[unsafe(method_family = new)]
        pub unsafe fn newIcosahedronWithRadius_inwardNormals_geometryType_allocator(
            radius: c_float,
            inward_normals: bool,
            geometry_type: MDLGeometryType,
            allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(feature = "MDLMeshBuffer")]
        #[method_id(newIcosahedronWithRadius:inwardNormals:allocator:)]
        #[unsafe(method_family = new)]
        pub unsafe fn newIcosahedronWithRadius_inwardNormals_allocator(
            radius: c_float,
            inward_normals: bool,
            allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[method_id(newSubdividedMesh:submeshIndex:subdivisionLevels:)]
        #[unsafe(method_family = new)]
        pub unsafe fn newSubdividedMesh_submeshIndex_subdivisionLevels(
            mesh: &MDLMesh,
            submesh_index: NSUInteger,
            subdivision_levels: NSUInteger,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// MDLLightBaking
    #[cfg(feature = "MDLObject")]
    unsafe impl MDLMesh {
        /// Creates an Ambient Occlusion texture, returns true upon success, false
        /// upon failure
        ///
        /// Parameter `bakeQuality`: Float between 0 and 1 that defines quality of the bake process.
        /// 0 is of lower quality but bakes faster and uses less memory, where 1 is
        /// of higher quality.
        ///
        /// Parameter `attenuationFactor`: Float between 0 to 1 that defines how to attenuate the
        /// AO value. 0 doesn't change it, and at 1, all AO values are white except
        /// if they are originally completely black. Quadratic attenuation in between.
        ///
        /// Parameter `objectsToConsider`: NSArray of MDLMeshes containing the objects to raytrace
        /// against
        ///
        /// Parameter `vertexAttributeName`: NSString of the MDLVertexAttribute where the vertex
        /// texture UVs will be stored. Creates it if it doesn't exist, otherwise
        /// overwrites current values.
        ///
        /// Parameter `materialPropertyName`: NSString of the MDLMaterialProperty that will store
        /// the texture in the Mesh.
        ///
        /// Returns: Success or failure of the baking process.
        #[method(generateAmbientOcclusionTextureWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:)]
        pub unsafe fn generateAmbientOcclusionTextureWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed_materialPropertyNamed(
            &self,
            bake_quality: c_float,
            attenuation_factor: c_float,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
            material_property_name: &NSString,
        ) -> bool;

        #[method(generateAmbientOcclusionVertexColorsWithRaysPerSample:attenuationFactor:objectsToConsider:vertexAttributeNamed:)]
        pub unsafe fn generateAmbientOcclusionVertexColorsWithRaysPerSample_attenuationFactor_objectsToConsider_vertexAttributeNamed(
            &self,
            rays_per_sample: NSInteger,
            attenuation_factor: c_float,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
        ) -> bool;

        #[method(generateAmbientOcclusionVertexColorsWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:)]
        pub unsafe fn generateAmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed(
            &self,
            bake_quality: c_float,
            attenuation_factor: c_float,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
        ) -> bool;

        #[cfg(feature = "MDLLight")]
        #[method(generateLightMapTextureWithQuality:lightsToConsider:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:)]
        pub unsafe fn generateLightMapTextureWithQuality_lightsToConsider_objectsToConsider_vertexAttributeNamed_materialPropertyNamed(
            &self,
            bake_quality: c_float,
            lights_to_consider: &NSArray<MDLLight>,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
            material_property_name: &NSString,
        ) -> bool;

        #[cfg(feature = "MDLLight")]
        #[method(generateLightMapVertexColorsWithLightsToConsider:objectsToConsider:vertexAttributeNamed:)]
        pub unsafe fn generateLightMapVertexColorsWithLightsToConsider_objectsToConsider_vertexAttributeNamed(
            &self,
            lights_to_consider: &NSArray<MDLLight>,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
        ) -> bool;
    }
);
