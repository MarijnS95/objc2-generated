//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Type of data a MDLMeshBuffer has been allocated for
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbuffertype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MDLMeshBufferType(pub NSUInteger);
impl MDLMeshBufferType {
    #[doc(alias = "MDLMeshBufferTypeVertex")]
    pub const Vertex: Self = Self(1);
    #[doc(alias = "MDLMeshBufferTypeIndex")]
    pub const Index: Self = Self(2);
    #[doc(alias = "MDLMeshBufferTypeCustom")]
    pub const Custom: Self = Self(3);
}

unsafe impl Encode for MDLMeshBufferType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MDLMeshBufferType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Represents a reference to memory of a mapped MeshBuffer
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbuffermap?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferMap;
);

unsafe impl NSObjectProtocol for MDLMeshBufferMap {}

extern_methods!(
    unsafe impl MDLMeshBufferMap {
        #[cfg(feature = "block2")]
        /// Called by implementor of MDLMeshBuffer protocol to create the map
        /// and arrange for unmapping on deallocation.
        #[method_id(@__retain_semantics Init initWithBytes:deallocator:)]
        pub unsafe fn initWithBytes_deallocator(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            deallocator: Option<&block2::Block<dyn Fn()>>,
        ) -> Retained<Self>;

        /// Mutable pointer to data in a MDLMeshBuffer object.
        #[method(bytes)]
        pub unsafe fn bytes(&self) -> NonNull<c_void>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MDLMeshBufferMap {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// Used by ModelIO to represent a buffer to be filled with vertex and
    /// index data
    ///
    /// Supports deep copy of data by conforming to the NSCopying protocol
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbuffer?language=objc)
    pub unsafe trait MDLMeshBuffer: NSCopying + NSObjectProtocol {
        /// Fills buffer with data at offset
        ///
        /// Parameter `data`: Data to fill buffer with
        ///
        /// Parameter `offset`: Byte offset in buffer to begin filling data
        ///
        /// Fills data.length bytes of data.  Will not write beyond length of
        /// this buffer.
        #[method(fillData:offset:)]
        unsafe fn fillData_offset(&self, data: &NSData, offset: NSUInteger);

        /// CPU access to buffer's memory
        ///
        /// Returns: An MDLMeshBufferMap object to read or modify a buffer's memory
        ///
        /// The buffer will remain mapped as long as the returned MDLMeshBufferMap
        /// object exists. Mapping a buffer may impose restrictions on a system.
        /// For instance,  if the implementing class maps an OpenGL buffer, that
        /// buffer may be  unavailable for rendering while mapped, and cause a
        /// draw failure.  Precautions must be taken in such cases.
        #[method_id(@__retain_semantics Other map)]
        unsafe fn map(&self) -> Retained<MDLMeshBufferMap>;

        /// Size in bytes of the buffer allocation
        #[method(length)]
        unsafe fn length(&self) -> NSUInteger;

        /// Allocator object used to create this buffer.
        ///
        /// This allcoator used for copy and relayout operations (such as when
        /// a new vertex descriptor is applied to a vertex buffer)
        #[method_id(@__retain_semantics Other allocator)]
        unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;

        /// Zone from which this buffer was created
        ///
        /// This zone will be used for copy and relayout operations (such as
        /// when a new vertex descriptor is applied to a vertex buffer).  If
        /// the default zone is used this will be nil.
        #[method_id(@__retain_semantics Other zone)]
        unsafe fn zone(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferZone>>;

        /// the intended type of the buffer
        #[method(type)]
        unsafe fn r#type(&self) -> MDLMeshBufferType;
    }
);

extern_class!(
    /// A CPU memory backed mesh buffer
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbufferdata?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferData;
);

unsafe impl MDLMeshBuffer for MDLMeshBufferData {}

unsafe impl NSCopying for MDLMeshBufferData {}

unsafe impl CopyingHelper for MDLMeshBufferData {
    type Result = Self;
}

unsafe impl NSObjectProtocol for MDLMeshBufferData {}

extern_methods!(
    unsafe impl MDLMeshBufferData {
        /// instantiate a new data backed mesh buffer
        ///
        /// Parameter `type`: the intended use of the buffer
        ///
        /// Parameter `length`: the size of buffer to allocate, in bytes
        #[method_id(@__retain_semantics Init initWithType:length:)]
        pub unsafe fn initWithType_length(
            this: Allocated<Self>,
            r#type: MDLMeshBufferType,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// instantiate a new data backed mesh buffer
        ///
        /// Parameter `type`: the intended use of the buffer
        ///
        /// Parameter `data`: the data to be used as a mesh buffer. It will be copied.
        #[method_id(@__retain_semantics Init initWithType:data:)]
        pub unsafe fn initWithType_data(
            this: Allocated<Self>,
            r#type: MDLMeshBufferType,
            data: Option<&NSData>,
        ) -> Retained<Self>;

        #[method_id(@__retain_semantics Other data)]
        pub unsafe fn data(&self) -> Retained<NSData>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MDLMeshBufferData {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// A reference to a logical pool of memory from which mesh buffers would
    /// be allocated
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbufferzone?language=objc)
    pub unsafe trait MDLMeshBufferZone: NSObjectProtocol {
        /// Total size of memory in the zone
        #[method(capacity)]
        unsafe fn capacity(&self) -> NSUInteger;

        /// Allocator used to create the zone
        #[method_id(@__retain_semantics Other allocator)]
        unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;
    }
);

extern_protocol!(
    /// Object for allocating buffers to back vertex and index data
    ///
    /// Accepted by MDLAsset init method.  Implementor creates objects
    /// implementing MDLMeshBuffer with memory to be filled with vertex and
    /// index data during 3d file loading and parsing.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator?language=objc)
    pub unsafe trait MDLMeshBufferAllocator: NSObjectProtocol {
        /// Create a zone which can be used to allocate MDLMeshBuffer objects
        ///
        /// Parameter `capacity`: Total size in bytes of all buffers which can be created from
        /// this zone
        #[method_id(@__retain_semantics New newZone:)]
        unsafe fn newZone(
            &self,
            capacity: NSUInteger,
        ) -> Retained<ProtocolObject<dyn MDLMeshBufferZone>>;

        /// Create a zone which can be used to allocate MDLMeshBuffer objects
        ///
        /// Parameter `sizes`: Sizes of each buffer to be created in this zone
        ///
        /// Parameter `types`: Type of each buffer to be created in this zone. Values to be of
        /// MDLMeshBufferType
        ///
        /// Will create a zone from which MDLMeshBuffer objects can be
        /// allocated.  This will allocate a zone with enough capacity
        /// for each of the buffers with sizes and types specified even taking
        /// into any alignment restrictions necessary to use these buffers.
        #[method_id(@__retain_semantics New newZoneForBuffersWithSize:andType:)]
        unsafe fn newZoneForBuffersWithSize_andType(
            &self,
            sizes: &NSArray<NSNumber>,
            types: &NSArray<NSNumber>,
        ) -> Retained<ProtocolObject<dyn MDLMeshBufferZone>>;

        /// Create a buffer in a default zone
        ///
        /// Parameter `length`: Size of buffer to be created in bytes
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        #[method_id(@__retain_semantics New newBuffer:type:)]
        unsafe fn newBuffer_type(
            &self,
            length: NSUInteger,
            r#type: MDLMeshBufferType,
        ) -> Retained<ProtocolObject<dyn MDLMeshBuffer>>;

        /// Create a buffer in a default zone and fill with data in the supplied
        /// NSData object
        ///
        /// Parameter `data`: Memory to fill the buffer with
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        #[method_id(@__retain_semantics New newBufferWithData:type:)]
        unsafe fn newBufferWithData_type(
            &self,
            data: &NSData,
            r#type: MDLMeshBufferType,
        ) -> Retained<ProtocolObject<dyn MDLMeshBuffer>>;

        /// Create a buffer from a given zone with the given length
        ///
        /// Returns: An object conforming to the MDLMeshBuffer protocol.  Returns nil the
        /// buffer could not be allocated in the zone given.
        ///
        /// Parameter `zone`: Zone from which to allocate the memory
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        ///
        /// An implementing MDLMeshBufferAllocator object may increase the size
        /// of the zone if the buffer could not be allocated with the current
        /// zone size.  Alternatively the implementation may return nil if the
        /// buffer could not be allocated.
        #[method_id(@__retain_semantics New newBufferFromZone:length:type:)]
        unsafe fn newBufferFromZone_length_type(
            &self,
            zone: Option<&ProtocolObject<dyn MDLMeshBufferZone>>,
            length: NSUInteger,
            r#type: MDLMeshBufferType,
        ) -> Option<Retained<ProtocolObject<dyn MDLMeshBuffer>>>;

        /// Create a buffer from a given zone and fill with data in the supplied
        /// NSData object
        ///
        /// Returns: An object conforming to the MDLMeshBuffer protocol.  Returns nil the
        /// buffer could not be allocated in the given zone
        ///
        /// Parameter `zone`: Zone from which to allocate the memory
        ///
        /// Parameter `data`: Values with which to fill the buffer
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        ///
        /// An implementing MDLMeshBufferAllocator object may increase the size
        /// of the zone if the buffer could not be allocated with the current
        /// zone size. Alternatively the implementation may return nil if the
        /// buffer could not be allocated.
        #[method_id(@__retain_semantics New newBufferFromZone:data:type:)]
        unsafe fn newBufferFromZone_data_type(
            &self,
            zone: Option<&ProtocolObject<dyn MDLMeshBufferZone>>,
            data: &NSData,
            r#type: MDLMeshBufferType,
        ) -> Option<Retained<ProtocolObject<dyn MDLMeshBuffer>>>;
    }
);

extern_class!(
    /// An allocator to use when backing with an NSData is appropriate.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbufferdataallocator?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferDataAllocator;
);

unsafe impl MDLMeshBufferAllocator for MDLMeshBufferDataAllocator {}

unsafe impl NSObjectProtocol for MDLMeshBufferDataAllocator {}

extern_methods!(
    unsafe impl MDLMeshBufferDataAllocator {}
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MDLMeshBufferDataAllocator {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// A default zone that can be use for convenience
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmeshbufferzonedefault?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferZoneDefault;
);

unsafe impl MDLMeshBufferZone for MDLMeshBufferZoneDefault {}

unsafe impl NSObjectProtocol for MDLMeshBufferZoneDefault {}

extern_methods!(
    unsafe impl MDLMeshBufferZoneDefault {
        #[method(capacity)]
        pub unsafe fn capacity(&self) -> NSUInteger;

        #[method_id(@__retain_semantics Other allocator)]
        pub unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MDLMeshBufferZoneDefault {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
