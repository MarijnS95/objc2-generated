//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-security")]
use objc2_security::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentity?language=objc)
#[repr(C)]
pub struct CSIdentity {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CSIdentity"]
    unsafe impl CSIdentity {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityquery?language=objc)
#[repr(C)]
pub struct CSIdentityQuery {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CSIdentityQuery"]
    unsafe impl CSIdentityQuery {}
);

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentitygenerateposixname?language=objc)
    pub static kCSIdentityGeneratePosixName: Option<&'static CFString>;
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityclassuser?language=objc)
pub const kCSIdentityClassUser: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityclassgroup?language=objc)
pub const kCSIdentityClassGroup: c_uint = 2;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityclass?language=objc)
pub type CSIdentityClass = CFIndex;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityflagnone?language=objc)
pub const kCSIdentityFlagNone: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityflaghidden?language=objc)
pub const kCSIdentityFlagHidden: c_uint = 1;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityflags?language=objc)
pub type CSIdentityFlags = CFOptionFlags;

unsafe impl ConcreteType for CSIdentity {
    #[doc(alias = "CSIdentityGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CSIdentityGetTypeID() -> CFTypeID;
        }
        unsafe { CSIdentityGetTypeID() }
    }
}

#[cfg(feature = "CSIdentityAuthority")]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityCreate(
    allocator: Option<&CFAllocator>,
    identity_class: CSIdentityClass,
    full_name: Option<&CFString>,
    posix_name: Option<&CFString>,
    flags: CSIdentityFlags,
    authority: Option<&CSIdentityAuthority>,
) -> Option<CFRetained<CSIdentity>> {
    extern "C-unwind" {
        fn CSIdentityCreate(
            allocator: Option<&CFAllocator>,
            identity_class: CSIdentityClass,
            full_name: Option<&CFString>,
            posix_name: Option<&CFString>,
            flags: CSIdentityFlags,
            authority: Option<&CSIdentityAuthority>,
        ) -> Option<NonNull<CSIdentity>>;
    }
    let ret = unsafe {
        CSIdentityCreate(
            allocator,
            identity_class,
            full_name,
            posix_name,
            flags,
            authority,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityCreateCopy(
    allocator: Option<&CFAllocator>,
    identity: Option<&CSIdentity>,
) -> Option<CFRetained<CSIdentity>> {
    extern "C-unwind" {
        fn CSIdentityCreateCopy(
            allocator: Option<&CFAllocator>,
            identity: Option<&CSIdentity>,
        ) -> Option<NonNull<CSIdentity>>;
    }
    let ret = unsafe { CSIdentityCreateCopy(allocator, identity) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    pub fn CSIdentityGetClass(identity: &CSIdentity) -> CSIdentityClass;
}

#[cfg(feature = "CSIdentityAuthority")]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetAuthority(
    identity: &CSIdentity,
) -> Option<CFRetained<CSIdentityAuthority>> {
    extern "C-unwind" {
        fn CSIdentityGetAuthority(identity: &CSIdentity) -> Option<NonNull<CSIdentityAuthority>>;
    }
    let ret = unsafe { CSIdentityGetAuthority(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetUUID(
    identity: &CSIdentity,
) -> Option<CFRetained<CFUUID>> {
    extern "C-unwind" {
        fn CSIdentityGetUUID(identity: &CSIdentity) -> Option<NonNull<CFUUID>>;
    }
    let ret = unsafe { CSIdentityGetUUID(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetFullName(
    identity: &CSIdentity,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CSIdentityGetFullName(identity: &CSIdentity) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CSIdentityGetFullName(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn CSIdentityGetPosixID(identity: &CSIdentity) -> libc::id_t;
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetPosixName(
    identity: &CSIdentity,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CSIdentityGetPosixName(identity: &CSIdentity) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CSIdentityGetPosixName(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetEmailAddress(
    identity: &CSIdentity,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CSIdentityGetEmailAddress(identity: &CSIdentity) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CSIdentityGetEmailAddress(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetImageURL(
    identity: &CSIdentity,
) -> Option<CFRetained<CFURL>> {
    extern "C-unwind" {
        fn CSIdentityGetImageURL(identity: &CSIdentity) -> Option<NonNull<CFURL>>;
    }
    let ret = unsafe { CSIdentityGetImageURL(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetImageData(
    identity: &CSIdentity,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CSIdentityGetImageData(identity: &CSIdentity) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CSIdentityGetImageData(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetImageDataType(
    identity: &CSIdentity,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CSIdentityGetImageDataType(identity: &CSIdentity) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CSIdentityGetImageDataType(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetAliases(
    identity: &CSIdentity,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CSIdentityGetAliases(identity: &CSIdentity) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CSIdentityGetAliases(identity) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityIsMemberOfGroup(
    identity: &CSIdentity,
    group: Option<&CSIdentity>,
) -> bool {
    extern "C-unwind" {
        fn CSIdentityIsMemberOfGroup(identity: &CSIdentity, group: Option<&CSIdentity>) -> Boolean;
    }
    let ret = unsafe { CSIdentityIsMemberOfGroup(identity, group) };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityIsHidden(identity: &CSIdentity) -> bool {
    extern "C-unwind" {
        fn CSIdentityIsHidden(identity: &CSIdentity) -> Boolean;
    }
    let ret = unsafe { CSIdentityIsHidden(identity) };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityCreatePersistentReference(
    allocator: Option<&CFAllocator>,
    identity: Option<&CSIdentity>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CSIdentityCreatePersistentReference(
            allocator: Option<&CFAllocator>,
            identity: Option<&CSIdentity>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CSIdentityCreatePersistentReference(allocator, identity) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityIsEnabled(user: &CSIdentity) -> bool {
    extern "C-unwind" {
        fn CSIdentityIsEnabled(user: &CSIdentity) -> Boolean;
    }
    let ret = unsafe { CSIdentityIsEnabled(user) };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityAuthenticateUsingPassword(
    user: &CSIdentity,
    password: Option<&CFString>,
) -> bool {
    extern "C-unwind" {
        fn CSIdentityAuthenticateUsingPassword(
            user: &CSIdentity,
            password: Option<&CFString>,
        ) -> Boolean;
    }
    let ret = unsafe { CSIdentityAuthenticateUsingPassword(user, password) };
    ret != 0
}

#[cfg(feature = "objc2-security")]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityGetCertificate(
    user: &CSIdentity,
) -> Option<CFRetained<SecCertificate>> {
    extern "C-unwind" {
        fn CSIdentityGetCertificate(user: &CSIdentity) -> Option<NonNull<SecCertificate>>;
    }
    let ret = unsafe { CSIdentityGetCertificate(user) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityCreateGroupMembershipQuery(
    allocator: Option<&CFAllocator>,
    group: Option<&CSIdentity>,
) -> Option<CFRetained<CSIdentityQuery>> {
    extern "C-unwind" {
        fn CSIdentityCreateGroupMembershipQuery(
            allocator: Option<&CFAllocator>,
            group: Option<&CSIdentity>,
        ) -> Option<NonNull<CSIdentityQuery>>;
    }
    let ret = unsafe { CSIdentityCreateGroupMembershipQuery(allocator, group) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    pub fn CSIdentitySetFullName(identity: &CSIdentity, full_name: Option<&CFString>);
}

extern "C-unwind" {
    pub fn CSIdentitySetEmailAddress(identity: &CSIdentity, email_address: Option<&CFString>);
}

extern "C-unwind" {
    pub fn CSIdentitySetImageURL(identity: &CSIdentity, url: Option<&CFURL>);
}

extern "C-unwind" {
    pub fn CSIdentitySetImageData(
        identity: &CSIdentity,
        image_data: Option<&CFData>,
        image_data_type: Option<&CFString>,
    );
}

extern "C-unwind" {
    pub fn CSIdentityAddAlias(identity: &CSIdentity, alias: Option<&CFString>);
}

extern "C-unwind" {
    pub fn CSIdentityRemoveAlias(identity: &CSIdentity, alias: Option<&CFString>);
}

extern "C-unwind" {
    pub fn CSIdentityAddMember(group: &CSIdentity, member: Option<&CSIdentity>);
}

extern "C-unwind" {
    pub fn CSIdentityRemoveMember(group: &CSIdentity, member: Option<&CSIdentity>);
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentitySetIsEnabled(user: &CSIdentity, is_enabled: bool) {
    extern "C-unwind" {
        fn CSIdentitySetIsEnabled(user: &CSIdentity, is_enabled: Boolean);
    }
    unsafe { CSIdentitySetIsEnabled(user, is_enabled as _) }
}

extern "C-unwind" {
    pub fn CSIdentitySetPassword(user: &CSIdentity, password: Option<&CFString>);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-security")]
    pub fn CSIdentitySetCertificate(user: &CSIdentity, certificate: Option<&SecCertificate>);
}

extern "C-unwind" {
    pub fn CSIdentityDelete(identity: &CSIdentity);
}

#[cfg(feature = "objc2-security")]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityCommit(
    identity: &CSIdentity,
    authorization: AuthorizationRef,
    error: *mut *mut CFError,
) -> bool {
    extern "C-unwind" {
        fn CSIdentityCommit(
            identity: &CSIdentity,
            authorization: AuthorizationRef,
            error: *mut *mut CFError,
        ) -> Boolean;
    }
    let ret = unsafe { CSIdentityCommit(identity, authorization, error) };
    ret != 0
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentitycommitcompleted?language=objc)
pub const kCSIdentityCommitCompleted: c_uint = 1;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentitystatusupdatedcallback?language=objc)
pub type CSIdentityStatusUpdatedCallback =
    Option<unsafe extern "C-unwind" fn(*mut CSIdentity, CFIndex, *mut CFError, *mut c_void)>;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityclientcontext?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CSIdentityClientContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
    pub statusUpdated: CSIdentityStatusUpdatedCallback,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CSIdentityClientContext {
    const ENCODING: Encoding = Encoding::Struct(
        "CSIdentityClientContext",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <CFAllocatorRetainCallBack>::ENCODING,
            <CFAllocatorReleaseCallBack>::ENCODING,
            <CFAllocatorCopyDescriptionCallBack>::ENCODING,
            <CSIdentityStatusUpdatedCallback>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CSIdentityClientContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "objc2-security")]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityCommitAsynchronously(
    identity: &CSIdentity,
    client_context: *const CSIdentityClientContext,
    run_loop: Option<&CFRunLoop>,
    run_loop_mode: Option<&CFString>,
    authorization: AuthorizationRef,
) -> bool {
    extern "C-unwind" {
        fn CSIdentityCommitAsynchronously(
            identity: &CSIdentity,
            client_context: *const CSIdentityClientContext,
            run_loop: Option<&CFRunLoop>,
            run_loop_mode: Option<&CFString>,
            authorization: AuthorizationRef,
        ) -> Boolean;
    }
    let ret = unsafe {
        CSIdentityCommitAsynchronously(
            identity,
            client_context,
            run_loop,
            run_loop_mode,
            authorization,
        )
    };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn CSIdentityIsCommitting(identity: &CSIdentity) -> bool {
    extern "C-unwind" {
        fn CSIdentityIsCommitting(identity: &CSIdentity) -> Boolean;
    }
    let ret = unsafe { CSIdentityIsCommitting(identity) };
    ret != 0
}

extern "C-unwind" {
    pub fn CSIdentityRemoveClient(identity: &CSIdentity);
}
