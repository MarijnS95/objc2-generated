//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-avf-audio")]
use objc2_avf_audio::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Analyzes a stream of audio data and provides analysis results to the client
    ///
    /// SNAudioStreamAnalyzer should be used to analyze a stream of audio, represented by a sequence of audio buffers over time.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/soundanalysis/snaudiostreamanalyzer?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SNAudioStreamAnalyzer;
);

unsafe impl NSObjectProtocol for SNAudioStreamAnalyzer {}

extern_methods!(
    unsafe impl SNAudioStreamAnalyzer {
        #[cfg(feature = "objc2-avf-audio")]
        /// Creates a new analyzer
        ///
        /// - Parameter format: The format of the audio stream to be analyzed. Only PCM formats are supported.
        #[method_id(@__method_family Init initWithFormat:)]
        pub unsafe fn initWithFormat(
            this: Allocated<Self>,
            format: &AVAudioFormat,
        ) -> Retained<Self>;

        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "SNRequest", feature = "SNResult"))]
        /// Adds a new analysis request to the analyzer
        ///
        /// - Parameters:
        ///
        /// - request: An audio analysis request to be performed on the audio stream
        ///
        /// - observer: The object that will receive the analysis results for the supplied request. The observer is weakly retained by the analyzer.
        ///
        /// - error: On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.
        ///
        /// - Returns: YES if the request was successfully added, and NO otherwise.
        ///
        /// Requests can be added while analysis is in progress. If the analyzer cannot perform the requested analysis, an error will be returned. For example, an error could be returned if the request requires a stream format that doesn't match the analyzer's stream format.
        #[method(addRequest:withObserver:error:_)]
        pub unsafe fn addRequest_withObserver_error(
            &self,
            request: &ProtocolObject<dyn SNRequest>,
            observer: &ProtocolObject<dyn SNResultsObserving>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "SNRequest")]
        /// Removes an existing analysis request from the analyzer
        /// - Parameter request: An audio analysis request to be removed
        /// Requests can be removed while analysis is in progress. Once the removeRequest method returns, the previously registered observer will not receive any more callbacks.
        #[method(removeRequest:)]
        pub unsafe fn removeRequest(&self, request: &ProtocolObject<dyn SNRequest>);

        /// Removes all requests from the analyzer
        #[method(removeAllRequests)]
        pub unsafe fn removeAllRequests(&self);

        #[cfg(feature = "objc2-avf-audio")]
        /// Provides the next buffer for analysis
        ///
        /// - Parameters:
        ///
        /// - audioBuffer: The buffer containing the audio to be processed
        ///
        /// - audioFramePosition: The frame position of the data in the buffer
        ///
        /// The framePosition should be a monotonically increasing sample timestamp. If the sample timeline is detected to be non-continuous, the analyzer's internal state may reset to account for the jump. Some types of audio analysis are performed at a fixed block size, which may differ from the buffer sizes provided for analysis. For this reason, an invocation of analyzeAudioBuffer may cause an analysis request observer to be called zero times, one time, or many times, depending on the relationship between the input buffer size, current analyzer state, and native analysis block size. Any errors produced during analysis will be provided through the request observers. This method may block as a means of indicating backpressure to the caller. These methods are not safe to call from a realtime audio context but may be called from lower priority threads (i.e. AVAudioEngine tap callback or AudioQueue callback).
        #[method(analyzeAudioBuffer:atAudioFramePosition:)]
        pub unsafe fn analyzeAudioBuffer_atAudioFramePosition(
            &self,
            audio_buffer: &AVAudioBuffer,
            audio_frame_position: AVAudioFramePosition,
        );

        /// Indicates that the audio stream has ended, and no more audio buffers will be analyzed
        ///
        /// After this method has been called, it is invalid to provide any more audio data for analysis, and any provided buffers will be ignored. This method is useful for types of analysis that may have final results to provide upon the completion of the stream.
        #[method(completeAnalysis)]
        pub unsafe fn completeAnalysis(&self);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl SNAudioStreamAnalyzer {
        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Analyzes an audio file and provides analysis results to the client
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/soundanalysis/snaudiofileanalyzer?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SNAudioFileAnalyzer;
);

unsafe impl NSObjectProtocol for SNAudioFileAnalyzer {}

extern_methods!(
    unsafe impl SNAudioFileAnalyzer {
        /// Creates a new analyzer
        ///
        /// - Parameters:
        ///
        /// - url: The url for the audio file to be analyzed
        ///
        /// - error: On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.
        #[method_id(@__method_family Init initWithURL:error:_)]
        pub unsafe fn initWithURL_error(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "SNRequest", feature = "SNResult"))]
        /// Adds a new analysis request to the analyzer
        ///
        /// - Parameters:
        ///
        /// - request: An audio analysis request to be performed on the audio stream
        ///
        /// - observer: The object that will receive the analysis results for the supplied request. The observer is weakly retained by the analyzer.
        ///
        /// - error On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.
        ///
        /// - Returns: YES if the request was successfully added, and NO otherwise.
        ///
        /// If addRequest is called while the file is being processed, an error will be returned.
        #[method(addRequest:withObserver:error:_)]
        pub unsafe fn addRequest_withObserver_error(
            &self,
            request: &ProtocolObject<dyn SNRequest>,
            observer: &ProtocolObject<dyn SNResultsObserving>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "SNRequest")]
        /// Removes an existing analysis request from the analyzer
        ///
        /// - Parameter request: An audio analysis request to be removed
        ///
        /// Requests can be removed while analysis is in progress. Once the removeRequest method returns, the previously registered observer will not receive any more callbacks.
        #[method(removeRequest:)]
        pub unsafe fn removeRequest(&self, request: &ProtocolObject<dyn SNRequest>);

        /// Removes all requests from the analyzer
        #[method(removeAllRequests)]
        pub unsafe fn removeAllRequests(&self);

        /// Analyzes the audio file synchronously
        ///
        /// This function executes synchronously. Any errors produced during analysis will flow downstream to the request observers. This method may block for a long period of time, so be careful to ensure this call does not block UI or other important tasks.
        #[method(analyze)]
        pub unsafe fn analyze(&self);

        #[cfg(feature = "block2")]
        /// Analyzes the audio file asynchronously
        ///
        /// This function executes asynchronously, calling the completion after the entire file has completed analysis. Any errors produced during analysis will flow downstream to the request observers. If the cancelAnalysis method is called, the completionHandler will still be called, but with didReachEndOfFile set to NO.
        #[method(analyzeWithCompletionHandler:)]
        pub unsafe fn analyzeWithCompletionHandler(
            &self,
            completion_handler: &block2::Block<dyn Fn(Bool)>,
        );

        /// Cancels any in-progress analysis of the audio file
        ///
        /// This function executes asynchronously, and will trigger the completion handler provided in the analyzeWithCompletionHandler method after the cancellation is complete.
        #[method(cancelAnalysis)]
        pub unsafe fn cancelAnalysis(&self);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl SNAudioFileAnalyzer {
        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
