//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Defines a spatial directive.
    /// The various goals cause force to be applied to agents to try to achieve said goal.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkgoal?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKGoal;
);

extern_conformance!(
    unsafe impl NSCopying for GKGoal {}
);

unsafe impl CopyingHelper for GKGoal {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for GKGoal {}
);

impl GKGoal {
    extern_methods!(
        #[cfg(all(feature = "GKAgent", feature = "GKComponent"))]
        /// Creates a goal to move toward the agent
        ///
        /// Parameter `agent`: the agent to seek
        #[unsafe(method(goalToSeekAgent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToSeekAgent(agent: &GKAgent) -> Retained<Self>;

        #[cfg(all(feature = "GKAgent", feature = "GKComponent"))]
        /// Creates a goal to move away from the agent
        ///
        /// Parameter `agent`: the agent to flee from
        #[unsafe(method(goalToFleeAgent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToFleeAgent(agent: &GKAgent) -> Retained<Self>;

        #[cfg(feature = "GKObstacle")]
        /// Creates a goal to avoid colliding with a group of agents without taking into account those agents' momentum
        ///
        /// Parameter `maxPredictionTime`: how far ahead in the future, in seconds, should we look for potential collisions
        #[unsafe(method(goalToAvoidObstacles:maxPredictionTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToAvoidObstacles_maxPredictionTime(
            obstacles: &NSArray<GKObstacle>,
            max_prediction_time: NSTimeInterval,
        ) -> Retained<Self>;

        #[cfg(all(feature = "GKAgent", feature = "GKComponent"))]
        /// Creates a goal to avoid colliding with a group of agents taking into account those agent's momentum
        ///
        /// Parameter `maxPredictionTime`: how far ahead in the future, in seconds, should we look for potential collisions
        #[unsafe(method(goalToAvoidAgents:maxPredictionTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToAvoidAgents_maxPredictionTime(
            agents: &NSArray<GKAgent>,
            max_prediction_time: NSTimeInterval,
        ) -> Retained<Self>;

        #[cfg(all(feature = "GKAgent", feature = "GKComponent"))]
        /// Creates a goal that tries to repel this agent away from the other agents and attempts to prevent overlap
        ///
        /// Parameter `maxDistance`: the distance between agents before repelling happens
        ///
        /// Parameter `maxAngle`: the angle, in radians, between this agent's foward and the vector toward the other agent before the repelling happens
        #[unsafe(method(goalToSeparateFromAgents:maxDistance:maxAngle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToSeparateFromAgents_maxDistance_maxAngle(
            agents: &NSArray<GKAgent>,
            max_distance: c_float,
            max_angle: c_float,
        ) -> Retained<Self>;

        #[cfg(all(feature = "GKAgent", feature = "GKComponent"))]
        /// Creates a goal to align this agent's orientation with the average orientation of the group of agents.
        ///
        /// Parameter `maxDistance`: the distance between agents before alignment happens
        ///
        /// Parameter `maxAngle`: the angle, in radians, between this agent's foward and the vector toward the other agent before alignment happens
        #[unsafe(method(goalToAlignWithAgents:maxDistance:maxAngle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToAlignWithAgents_maxDistance_maxAngle(
            agents: &NSArray<GKAgent>,
            max_distance: c_float,
            max_angle: c_float,
        ) -> Retained<Self>;

        #[cfg(all(feature = "GKAgent", feature = "GKComponent"))]
        /// Creates a goal to seek the average position of the group of agents.
        ///
        /// Parameter `maxDistance`: the distance between agents before cohesion happens
        ///
        /// Parameter `maxAngle`: the angle between this agent's foward and the vector toward the other agent before cohesion happens
        #[unsafe(method(goalToCohereWithAgents:maxDistance:maxAngle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToCohereWithAgents_maxDistance_maxAngle(
            agents: &NSArray<GKAgent>,
            max_distance: c_float,
            max_angle: c_float,
        ) -> Retained<Self>;

        /// Creates a goal that attempts to change our momentum to reach the target speed
        ///
        /// Parameter `targetSpeed`: the target speed
        #[unsafe(method(goalToReachTargetSpeed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToReachTargetSpeed(target_speed: c_float) -> Retained<Self>;

        /// Creates a goal that will make the agent appear to wander, aimlessly moving forward and turning randomly
        ///
        /// Parameter `speed`: the speed at which to wander
        #[unsafe(method(goalToWander:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToWander(speed: c_float) -> Retained<Self>;

        #[cfg(all(feature = "GKAgent", feature = "GKComponent"))]
        /// Creates a goal that will attempt to intercept another target agent taking into account that agent's momentum
        ///
        /// Parameter `target`: agent to intercept
        ///
        /// Parameter `maxPredictionTime`: how far ahead in the future, in seconds, should we look for potential intercepts
        #[unsafe(method(goalToInterceptAgent:maxPredictionTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToInterceptAgent_maxPredictionTime(
            target: &GKAgent,
            max_prediction_time: NSTimeInterval,
        ) -> Retained<Self>;

        #[cfg(feature = "GKPath")]
        /// Creates a goal that will attempt to follow the given path
        ///
        /// Parameter `path`: the path to follow
        ///
        /// Parameter `maxPredictionTime`: how far ahead in the future, in seconds, should we look for potential intercepts
        ///
        /// Parameter `forward`: direction to follow the path. forward = NO is reverse
        #[unsafe(method(goalToFollowPath:maxPredictionTime:forward:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToFollowPath_maxPredictionTime_forward(
            path: &GKPath,
            max_prediction_time: NSTimeInterval,
            forward: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "GKPath")]
        /// Creates a goal that will attempt to stay on the given path
        ///
        /// Parameter `path`: the path to follow
        ///
        /// Parameter `maxPredictionTime`: how far ahead in the future, in seconds, should we look for potential intercepts
        #[unsafe(method(goalToStayOnPath:maxPredictionTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn goalToStayOnPath_maxPredictionTime(
            path: &GKPath,
            max_prediction_time: NSTimeInterval,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKGoal {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
