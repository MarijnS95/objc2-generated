//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Maximum / minimum values for GKGameModel scoreForPlayer. Values must be within these ranges.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkgamemodelmaxscore?language=objc)
pub static GKGameModelMaxScore: NSInteger = 1 << 24;

/// [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkgamemodelminscore?language=objc)
pub static GKGameModelMinScore: NSInteger = -(1 << 24);

extern_protocol!(
    /// A protocol used to encapsulate the data needed to affect an update to a game model.
    /// Typically represents an action or move performed by a player.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkgamemodelupdate?language=objc)
    pub unsafe trait GKGameModelUpdate: NSObjectProtocol {
        /// Property get/set by GKMinmaxStrategist to sort GKGameModelUpdates.
        #[unsafe(method(value))]
        #[unsafe(method_family = none)]
        unsafe fn value(&self) -> NSInteger;

        /// Setter for [`value`][Self::value].
        #[unsafe(method(setValue:))]
        #[unsafe(method_family = none)]
        unsafe fn setValue(&self, value: NSInteger);
    }
);

extern_protocol!(
    /// A protocol used to represent an individual player within a game model.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkgamemodelplayer?language=objc)
    pub unsafe trait GKGameModelPlayer: NSObjectProtocol {
        /// Identifier used by GKMinmaxStrategist differentiate players from one another.
        #[unsafe(method(playerId))]
        #[unsafe(method_family = none)]
        unsafe fn playerId(&self) -> NSInteger;
    }
);

extern_protocol!(
    /// A protocol for abstracting a game model for use with the GKMinmaxStrategist class. The minmax
    /// strategist uses the game model class, along with GKGameModelPlayer and GKGameModelUpdate to
    /// find optimal moves in an adversarial, turn-based game.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkgamemodel?language=objc)
    pub unsafe trait GKGameModel: NSObjectProtocol + NSCopying {
        /// Array of instances of GKGameModelPlayers representing players within this game model. When the
        /// GKMinmaxStrategist class is used to find an optimal move for a specific player, it uses this
        /// array to rate the moves of that playerâ€™s opponent(s).
        #[unsafe(method(players))]
        #[unsafe(method_family = none)]
        unsafe fn players(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn GKGameModelPlayer>>>>;

        /// The player whose turn it is to perform an update to the game model. GKMinmaxStrategist assumes
        /// that the next call to the applyGameModelUpdate: method will perform a move on behalf of this player.
        #[unsafe(method(activePlayer))]
        #[unsafe(method_family = none)]
        unsafe fn activePlayer(&self) -> Option<Retained<ProtocolObject<dyn GKGameModelPlayer>>>;

        /// Sets the data of another game model. All data should be copied over, and should not maintain
        /// any pointers to the copied game state. This is used by the GKMinmaxStrategist to process
        /// permutations of the game without needing to apply potentially destructive updates to the
        /// primary game model.
        #[unsafe(method(setGameModel:))]
        #[unsafe(method_family = none)]
        unsafe fn setGameModel(&self, game_model: &ProtocolObject<dyn GKGameModel>);

        /// Returns an array of all the GKGameModelUpdates (i.e. actions/moves) that the active
        /// player can undertake, with one instance of GKGameModelUpdate for each possible move.
        /// Returns nil if the specified player is invalid, is not a part of the game model, or
        /// if there are no valid moves available.
        #[unsafe(method(gameModelUpdatesForPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn gameModelUpdatesForPlayer(
            &self,
            player: &ProtocolObject<dyn GKGameModelPlayer>,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn GKGameModelUpdate>>>>;

        /// Applies a GKGameModelUpdate to the game model, potentially resulting in a new activePlayer.
        /// GKMinmaxStrategist will call this method on a copy of the primary game model to speculate
        /// about possible future moves and their effects. It is assumed that calling this method performs
        /// a move on behalf of the player identified by the activePlayer property.
        #[unsafe(method(applyGameModelUpdate:))]
        #[unsafe(method_family = none)]
        unsafe fn applyGameModelUpdate(
            &self,
            game_model_update: &ProtocolObject<dyn GKGameModelUpdate>,
        );

        /// Returns the score for the specified player. A higher value indicates a better position for
        /// the player than a lower value. Required by GKMinmaxStrategist to determine which
        /// GKGameModelUpdate is the most advantageous for a given player. If the player is invalid, or
        /// not a part of the game model, returns NSIntegerMin.
        #[optional]
        #[unsafe(method(scoreForPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn scoreForPlayer(
            &self,
            player: &ProtocolObject<dyn GKGameModelPlayer>,
        ) -> NSInteger;

        /// Returns YES if the specified player has reached a win state, NO if otherwise. Note that NO does not
        /// necessarily mean that the player has lost. Optionally used by GKMinmaxStrategist to improve move selection.
        #[optional]
        #[unsafe(method(isWinForPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn isWinForPlayer(&self, player: &ProtocolObject<dyn GKGameModelPlayer>) -> bool;

        /// Returns YES if the specified player has reached a loss state, NO if otherwise. Note that NO does not
        /// necessarily mean that the player has won. Optionally used by GKMinmaxStrategist to improve move selection.
        #[optional]
        #[unsafe(method(isLossForPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn isLossForPlayer(&self, player: &ProtocolObject<dyn GKGameModelPlayer>) -> bool;

        #[optional]
        #[unsafe(method(unapplyGameModelUpdate:))]
        #[unsafe(method_family = none)]
        unsafe fn unapplyGameModelUpdate(
            &self,
            game_model_update: &ProtocolObject<dyn GKGameModelUpdate>,
        );
    }
);
