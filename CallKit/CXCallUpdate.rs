//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/callkit/cxcallupdate?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CXCallUpdate;
);

unsafe impl NSCopying for CXCallUpdate {}

unsafe impl CopyingHelper for CXCallUpdate {
    type Result = Self;
}

unsafe impl NSObjectProtocol for CXCallUpdate {}

extern_methods!(
    unsafe impl CXCallUpdate {
        #[cfg(feature = "CXHandle")]
        /// Handle for the remote party (for an incoming call, the caller; for an outgoing call, the callee)
        #[method_id(@__method_family Other remoteHandle)]
        pub unsafe fn remoteHandle(&self) -> Option<Retained<CXHandle>>;

        #[cfg(feature = "CXHandle")]
        /// Setter for [`remoteHandle`][Self::remoteHandle].
        #[method(setRemoteHandle:)]
        pub unsafe fn setRemoteHandle(&self, remote_handle: Option<&CXHandle>);

        /// Override the computed caller name to a provider-defined value.
        /// Normally the system will determine the appropriate caller name to display (e.g. using the user's contacts) based on the supplied caller identifier. Set this property to customize.
        #[method_id(@__method_family Other localizedCallerName)]
        pub unsafe fn localizedCallerName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localizedCallerName`][Self::localizedCallerName].
        #[method(setLocalizedCallerName:)]
        pub unsafe fn setLocalizedCallerName(&self, localized_caller_name: Option<&NSString>);

        /// Whether the call can be held on its own or swapped with another call
        #[method(supportsHolding)]
        pub unsafe fn supportsHolding(&self) -> bool;

        /// Setter for [`supportsHolding`][Self::supportsHolding].
        #[method(setSupportsHolding:)]
        pub unsafe fn setSupportsHolding(&self, supports_holding: bool);

        /// Whether the call can be grouped (merged) with other calls when it is ungrouped
        #[method(supportsGrouping)]
        pub unsafe fn supportsGrouping(&self) -> bool;

        /// Setter for [`supportsGrouping`][Self::supportsGrouping].
        #[method(setSupportsGrouping:)]
        pub unsafe fn setSupportsGrouping(&self, supports_grouping: bool);

        /// The call can be ungrouped (taken private) when it is grouped
        #[method(supportsUngrouping)]
        pub unsafe fn supportsUngrouping(&self) -> bool;

        /// Setter for [`supportsUngrouping`][Self::supportsUngrouping].
        #[method(setSupportsUngrouping:)]
        pub unsafe fn setSupportsUngrouping(&self, supports_ungrouping: bool);

        /// The call can send DTMF tones via hard pause digits or in-call keypad entries
        #[method(supportsDTMF)]
        pub unsafe fn supportsDTMF(&self) -> bool;

        /// Setter for [`supportsDTMF`][Self::supportsDTMF].
        #[method(setSupportsDTMF:)]
        pub unsafe fn setSupportsDTMF(&self, supports_dtmf: bool);

        /// The call includes video in addition to audio.
        #[method(hasVideo)]
        pub unsafe fn hasVideo(&self) -> bool;

        /// Setter for [`hasVideo`][Self::hasVideo].
        #[method(setHasVideo:)]
        pub unsafe fn setHasVideo(&self, has_video: bool);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl CXCallUpdate {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
