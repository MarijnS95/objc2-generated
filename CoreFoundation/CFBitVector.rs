//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfbit?language=objc)
pub type CFBit = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfbitvector?language=objc)
#[repr(C)]
pub struct CFBitVector {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CFBitVector"]
    unsafe impl CFBitVector {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfmutablebitvector?language=objc)
#[repr(C)]
pub struct CFMutableBitVector {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CFBitVector"]
    unsafe impl CFMutableBitVector: CFBitVector {}
);

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorCreate(
        allocator: Option<&CFAllocator>,
        bytes: *const u8,
        num_bits: CFIndex,
    ) -> *mut CFBitVector;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorCreateCopy(
        allocator: Option<&CFAllocator>,
        bv: Option<&CFBitVector>,
    ) -> *mut CFBitVector;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorCreateMutable(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
    ) -> *mut CFMutableBitVector;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorCreateMutableCopy(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        bv: Option<&CFBitVector>,
    ) -> *mut CFMutableBitVector;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorGetCount(bv: Option<&CFBitVector>) -> CFIndex;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorGetCountOfBit(
        bv: Option<&CFBitVector>,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorContainsBit(
        bv: Option<&CFBitVector>,
        range: CFRange,
        value: CFBit,
    ) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorGetBitAtIndex(bv: Option<&CFBitVector>, idx: CFIndex) -> CFBit;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorGetBits(bv: Option<&CFBitVector>, range: CFRange, bytes: *mut u8);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorGetFirstIndexOfBit(
        bv: Option<&CFBitVector>,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorGetLastIndexOfBit(
        bv: Option<&CFBitVector>,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorSetCount(bv: Option<&CFMutableBitVector>, count: CFIndex);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorFlipBitAtIndex(bv: Option<&CFMutableBitVector>, idx: CFIndex);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorFlipBits(bv: Option<&CFMutableBitVector>, range: CFRange);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorSetBitAtIndex(bv: Option<&CFMutableBitVector>, idx: CFIndex, value: CFBit);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFBitVectorSetBits(bv: Option<&CFMutableBitVector>, range: CFRange, value: CFBit);
}

extern "C-unwind" {
    pub fn CFBitVectorSetAllBits(bv: Option<&CFMutableBitVector>, value: CFBit);
}
