//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopmode?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "CFBase")]
pub type CFRunLoopMode = CFString;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloop?language=objc)
#[repr(C)]
pub struct CFRunLoop {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CFRunLoop"]
    unsafe impl CFRunLoop {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopsource?language=objc)
#[repr(C)]
pub struct CFRunLoopSource {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CFRunLoopSource"]
    unsafe impl CFRunLoopSource {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopobserver?language=objc)
#[repr(C)]
pub struct CFRunLoopObserver {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CFRunLoopObserver"]
    unsafe impl CFRunLoopObserver {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooptimer?language=objc)
#[repr(C)]
pub struct CFRunLoopTimer {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__CFRunLoopTimer"]
    unsafe impl CFRunLoopTimer {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooprunresult?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFRunLoopRunResult(pub i32);
impl CFRunLoopRunResult {
    #[doc(alias = "kCFRunLoopRunFinished")]
    pub const Finished: Self = Self(1);
    #[doc(alias = "kCFRunLoopRunStopped")]
    pub const Stopped: Self = Self(2);
    #[doc(alias = "kCFRunLoopRunTimedOut")]
    pub const TimedOut: Self = Self(3);
    #[doc(alias = "kCFRunLoopRunHandledSource")]
    pub const HandledSource: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFRunLoopRunResult {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFRunLoopRunResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopactivity?language=objc)
// NS_OPTIONS
#[cfg(feature = "CFBase")]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFRunLoopActivity(pub CFOptionFlags);
#[cfg(feature = "CFBase")]
bitflags::bitflags! {
    impl CFRunLoopActivity: CFOptionFlags {
        #[doc(alias = "kCFRunLoopEntry")]
        const Entry = 1<<0;
        #[doc(alias = "kCFRunLoopBeforeTimers")]
        const BeforeTimers = 1<<1;
        #[doc(alias = "kCFRunLoopBeforeSources")]
        const BeforeSources = 1<<2;
        #[doc(alias = "kCFRunLoopBeforeWaiting")]
        const BeforeWaiting = 1<<5;
        #[doc(alias = "kCFRunLoopAfterWaiting")]
        const AfterWaiting = 1<<6;
        #[doc(alias = "kCFRunLoopExit")]
        const Exit = 1<<7;
        #[doc(alias = "kCFRunLoopAllActivities")]
        const AllActivities = 0x0FFFFFFF;
    }
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopActivity {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopActivity {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfrunloopdefaultmode?language=objc)
    #[cfg(feature = "CFBase")]
    pub static kCFRunLoopDefaultMode: Option<&'static CFRunLoopMode>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfrunloopcommonmodes?language=objc)
    #[cfg(feature = "CFBase")]
    pub static kCFRunLoopCommonModes: Option<&'static CFRunLoopMode>;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    pub fn CFRunLoopGetCurrent() -> *mut CFRunLoop;
}

extern "C-unwind" {
    pub fn CFRunLoopGetMain() -> *mut CFRunLoop;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopCopyCurrentMode(rl: Option<&CFRunLoop>) -> *mut CFRunLoopMode;
}

extern "C-unwind" {
    #[cfg(feature = "CFArray")]
    pub fn CFRunLoopCopyAllModes(rl: Option<&CFRunLoop>) -> *mut CFArray;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddCommonMode(rl: Option<&CFRunLoop>, mode: Option<&CFRunLoopMode>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate"))]
    pub fn CFRunLoopGetNextTimerFireDate(
        rl: Option<&CFRunLoop>,
        mode: Option<&CFRunLoopMode>,
    ) -> CFAbsoluteTime;
}

extern "C-unwind" {
    pub fn CFRunLoopRun();
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate"))]
    pub fn CFRunLoopRunInMode(
        mode: Option<&CFRunLoopMode>,
        seconds: CFTimeInterval,
        return_after_source_handled: Boolean,
    ) -> CFRunLoopRunResult;
}

extern "C-unwind" {
    pub fn CFRunLoopIsWaiting(rl: Option<&CFRunLoop>) -> Boolean;
}

extern "C-unwind" {
    pub fn CFRunLoopWakeUp(rl: Option<&CFRunLoop>);
}

extern "C-unwind" {
    pub fn CFRunLoopStop(rl: Option<&CFRunLoop>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "block2"))]
    pub fn CFRunLoopPerformBlock(
        rl: Option<&CFRunLoop>,
        mode: CFTypeRef,
        block: Option<&block2::Block<dyn Fn()>>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopContainsSource(
        rl: Option<&CFRunLoop>,
        source: Option<&CFRunLoopSource>,
        mode: Option<&CFRunLoopMode>,
    ) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddSource(
        rl: Option<&CFRunLoop>,
        source: Option<&CFRunLoopSource>,
        mode: Option<&CFRunLoopMode>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopRemoveSource(
        rl: Option<&CFRunLoop>,
        source: Option<&CFRunLoopSource>,
        mode: Option<&CFRunLoopMode>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopContainsObserver(
        rl: Option<&CFRunLoop>,
        observer: Option<&CFRunLoopObserver>,
        mode: Option<&CFRunLoopMode>,
    ) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddObserver(
        rl: Option<&CFRunLoop>,
        observer: Option<&CFRunLoopObserver>,
        mode: Option<&CFRunLoopMode>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopRemoveObserver(
        rl: Option<&CFRunLoop>,
        observer: Option<&CFRunLoopObserver>,
        mode: Option<&CFRunLoopMode>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopContainsTimer(
        rl: Option<&CFRunLoop>,
        timer: Option<&CFRunLoopTimer>,
        mode: Option<&CFRunLoopMode>,
    ) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddTimer(
        rl: Option<&CFRunLoop>,
        timer: Option<&CFRunLoopTimer>,
        mode: Option<&CFRunLoopMode>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopRemoveTimer(
        rl: Option<&CFRunLoop>,
        timer: Option<&CFRunLoopTimer>,
        mode: Option<&CFRunLoopMode>,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopsourcecontext?language=objc)
#[cfg(feature = "CFBase")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopSourceContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*const c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*const c_void) -> *mut CFString>,
    pub equal: Option<unsafe extern "C-unwind" fn(*const c_void, *const c_void) -> Boolean>,
    pub hash: Option<unsafe extern "C-unwind" fn(*const c_void) -> CFHashCode>,
    pub schedule:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut CFRunLoop, *mut CFRunLoopMode)>,
    pub cancel:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut CFRunLoop, *mut CFRunLoopMode)>,
    pub perform: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopSourceContext {
    const ENCODING: Encoding = Encoding::Struct("?", &[<CFIndex>::ENCODING,<*mut c_void>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,) -> *const c_void>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,)>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,) -> *mut CFString>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,*const c_void,) -> Boolean>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,) -> CFHashCode>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,*mut CFRunLoop,*mut CFRunLoopMode,)>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,*mut CFRunLoop,*mut CFRunLoopMode,)>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,)>>::ENCODING,]);
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopSourceContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopsourcecontext1?language=objc)
#[cfg(all(feature = "CFBase", feature = "libc"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopSourceContext1 {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*const c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*const c_void) -> *mut CFString>,
    pub equal: Option<unsafe extern "C-unwind" fn(*const c_void, *const c_void) -> Boolean>,
    pub hash: Option<unsafe extern "C-unwind" fn(*const c_void) -> CFHashCode>,
    pub getPort: Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>,
    pub perform: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            CFIndex,
            *mut CFAllocator,
            *mut c_void,
        ) -> *mut c_void,
    >,
}

#[cfg(all(feature = "CFBase", feature = "libc", feature = "objc2"))]
unsafe impl Encode for CFRunLoopSourceContext1 {
    const ENCODING: Encoding = Encoding::Struct("?", &[<CFIndex>::ENCODING,<*mut c_void>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,) -> *const c_void>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,)>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,) -> *mut CFString>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,*const c_void,) -> Boolean>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*const c_void,) -> CFHashCode>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,) -> libc::mach_port_t>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,CFIndex,*mut CFAllocator,*mut c_void,) -> *mut c_void>>::ENCODING,]);
}

#[cfg(all(feature = "CFBase", feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopSourceContext1 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceCreate(
        allocator: Option<&CFAllocator>,
        order: CFIndex,
        context: *mut CFRunLoopSourceContext,
    ) -> *mut CFRunLoopSource;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceGetOrder(source: Option<&CFRunLoopSource>) -> CFIndex;
}

extern "C-unwind" {
    pub fn CFRunLoopSourceInvalidate(source: Option<&CFRunLoopSource>);
}

extern "C-unwind" {
    pub fn CFRunLoopSourceIsValid(source: Option<&CFRunLoopSource>) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceGetContext(
        source: Option<&CFRunLoopSource>,
        context: *mut CFRunLoopSourceContext,
    );
}

extern "C-unwind" {
    pub fn CFRunLoopSourceSignal(source: Option<&CFRunLoopSource>);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopobservercontext?language=objc)
#[cfg(feature = "CFBase")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopObserverContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*const c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*const c_void) -> *mut CFString>,
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopObserverContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void) -> *mut CFString>>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopObserverContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopobservercallback?language=objc)
#[cfg(feature = "CFBase")]
pub type CFRunLoopObserverCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFRunLoopObserver, CFRunLoopActivity, *mut c_void)>;

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverCreate(
        allocator: Option<&CFAllocator>,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        callout: CFRunLoopObserverCallBack,
        context: *mut CFRunLoopObserverContext,
    ) -> *mut CFRunLoopObserver;
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "block2"))]
    pub fn CFRunLoopObserverCreateWithHandler(
        allocator: Option<&CFAllocator>,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        block: Option<&block2::Block<dyn Fn(*mut CFRunLoopObserver, CFRunLoopActivity)>>,
    ) -> *mut CFRunLoopObserver;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetActivities(observer: Option<&CFRunLoopObserver>) -> CFOptionFlags;
}

extern "C-unwind" {
    pub fn CFRunLoopObserverDoesRepeat(observer: Option<&CFRunLoopObserver>) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetOrder(observer: Option<&CFRunLoopObserver>) -> CFIndex;
}

extern "C-unwind" {
    pub fn CFRunLoopObserverInvalidate(observer: Option<&CFRunLoopObserver>);
}

extern "C-unwind" {
    pub fn CFRunLoopObserverIsValid(observer: Option<&CFRunLoopObserver>) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetContext(
        observer: Option<&CFRunLoopObserver>,
        context: *mut CFRunLoopObserverContext,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooptimercontext?language=objc)
#[cfg(feature = "CFBase")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopTimerContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*const c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*const c_void) -> *mut CFString>,
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopTimerContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*const c_void) -> *mut CFString>>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopTimerContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooptimercallback?language=objc)
pub type CFRunLoopTimerCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFRunLoopTimer, *mut c_void)>;

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopTimerGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate"))]
    pub fn CFRunLoopTimerCreate(
        allocator: Option<&CFAllocator>,
        fire_date: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        callout: CFRunLoopTimerCallBack,
        context: *mut CFRunLoopTimerContext,
    ) -> *mut CFRunLoopTimer;
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate", feature = "block2"))]
    pub fn CFRunLoopTimerCreateWithHandler(
        allocator: Option<&CFAllocator>,
        fire_date: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        block: Option<&block2::Block<dyn Fn(*mut CFRunLoopTimer)>>,
    ) -> *mut CFRunLoopTimer;
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerGetNextFireDate(timer: Option<&CFRunLoopTimer>) -> CFAbsoluteTime;
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerSetNextFireDate(timer: Option<&CFRunLoopTimer>, fire_date: CFAbsoluteTime);
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerGetInterval(timer: Option<&CFRunLoopTimer>) -> CFTimeInterval;
}

extern "C-unwind" {
    pub fn CFRunLoopTimerDoesRepeat(timer: Option<&CFRunLoopTimer>) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopTimerGetOrder(timer: Option<&CFRunLoopTimer>) -> CFIndex;
}

extern "C-unwind" {
    pub fn CFRunLoopTimerInvalidate(timer: Option<&CFRunLoopTimer>);
}

extern "C-unwind" {
    pub fn CFRunLoopTimerIsValid(timer: Option<&CFRunLoopTimer>) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopTimerGetContext(
        timer: Option<&CFRunLoopTimer>,
        context: *mut CFRunLoopTimerContext,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerGetTolerance(timer: Option<&CFRunLoopTimer>) -> CFTimeInterval;
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerSetTolerance(timer: Option<&CFRunLoopTimer>, tolerance: CFTimeInterval);
}
