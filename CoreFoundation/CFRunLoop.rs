//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopmode?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "CFBase")]
pub type CFRunLoopMode = CFStringRef;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopref?language=objc)
pub type CFRunLoopRef = *mut c_void;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopsourceref?language=objc)
pub type CFRunLoopSourceRef = *mut c_void;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopobserverref?language=objc)
pub type CFRunLoopObserverRef = *mut c_void;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooptimerref?language=objc)
pub type CFRunLoopTimerRef = *mut c_void;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooprunresult?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFRunLoopRunResult(pub i32);
impl CFRunLoopRunResult {
    pub const kCFRunLoopRunFinished: Self = Self(1);
    pub const kCFRunLoopRunStopped: Self = Self(2);
    pub const kCFRunLoopRunTimedOut: Self = Self(3);
    pub const kCFRunLoopRunHandledSource: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFRunLoopRunResult {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFRunLoopRunResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopactivity?language=objc)
// NS_OPTIONS
#[cfg(feature = "CFBase")]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFRunLoopActivity(pub CFOptionFlags);
#[cfg(feature = "CFBase")]
bitflags::bitflags! {
    impl CFRunLoopActivity: CFOptionFlags {
        const kCFRunLoopEntry = 1<<0;
        const kCFRunLoopBeforeTimers = 1<<1;
        const kCFRunLoopBeforeSources = 1<<2;
        const kCFRunLoopBeforeWaiting = 1<<5;
        const kCFRunLoopAfterWaiting = 1<<6;
        const kCFRunLoopExit = 1<<7;
        const kCFRunLoopAllActivities = 0x0FFFFFFF;
    }
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopActivity {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopActivity {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfrunloopdefaultmode?language=objc)
    #[cfg(feature = "CFBase")]
    pub static kCFRunLoopDefaultMode: CFRunLoopMode;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfrunloopcommonmodes?language=objc)
    #[cfg(feature = "CFBase")]
    pub static kCFRunLoopCommonModes: CFRunLoopMode;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    pub fn CFRunLoopGetCurrent() -> CFRunLoopRef;
}

extern "C-unwind" {
    pub fn CFRunLoopGetMain() -> CFRunLoopRef;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopCopyCurrentMode(rl: CFRunLoopRef) -> CFRunLoopMode;
}

extern "C-unwind" {
    #[cfg(feature = "CFArray")]
    pub fn CFRunLoopCopyAllModes(rl: CFRunLoopRef) -> CFArrayRef;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddCommonMode(rl: CFRunLoopRef, mode: CFRunLoopMode);
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate"))]
    pub fn CFRunLoopGetNextTimerFireDate(rl: CFRunLoopRef, mode: CFRunLoopMode) -> CFAbsoluteTime;
}

extern "C-unwind" {
    pub fn CFRunLoopRun();
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate"))]
    pub fn CFRunLoopRunInMode(
        mode: CFRunLoopMode,
        seconds: CFTimeInterval,
        return_after_source_handled: Boolean,
    ) -> CFRunLoopRunResult;
}

extern "C-unwind" {
    pub fn CFRunLoopIsWaiting(rl: CFRunLoopRef) -> Boolean;
}

extern "C-unwind" {
    pub fn CFRunLoopWakeUp(rl: CFRunLoopRef);
}

extern "C-unwind" {
    pub fn CFRunLoopStop(rl: CFRunLoopRef);
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "block2"))]
    pub fn CFRunLoopPerformBlock(
        rl: CFRunLoopRef,
        mode: CFTypeRef,
        block: Option<&block2::Block<dyn Fn()>>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopContainsSource(
        rl: CFRunLoopRef,
        source: CFRunLoopSourceRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddSource(rl: CFRunLoopRef, source: CFRunLoopSourceRef, mode: CFRunLoopMode);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopRemoveSource(rl: CFRunLoopRef, source: CFRunLoopSourceRef, mode: CFRunLoopMode);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopContainsObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopRemoveObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopContainsTimer(
        rl: CFRunLoopRef,
        timer: CFRunLoopTimerRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopAddTimer(rl: CFRunLoopRef, timer: CFRunLoopTimerRef, mode: CFRunLoopMode);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopRemoveTimer(rl: CFRunLoopRef, timer: CFRunLoopTimerRef, mode: CFRunLoopMode);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopsourcecontext?language=objc)
#[cfg(feature = "CFBase")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopSourceContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFStringRef>,
    pub equal: Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void) -> Boolean>,
    pub hash: Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFHashCode>,
    pub schedule: Option<unsafe extern "C-unwind" fn(*mut c_void, CFRunLoopRef, CFRunLoopMode)>,
    pub cancel: Option<unsafe extern "C-unwind" fn(*mut c_void, CFRunLoopRef, CFRunLoopMode)>,
    pub perform: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopSourceContext {
    const ENCODING: Encoding = Encoding::Struct("?", &[<CFIndex>::ENCODING,<*mut c_void>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut c_void>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,)>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,) -> CFStringRef>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,*mut c_void,) -> Boolean>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,) -> CFHashCode>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,CFRunLoopRef,CFRunLoopMode,)>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,CFRunLoopRef,CFRunLoopMode,)>>::ENCODING,<Option<unsafe extern "C-unwind" fn(*mut c_void,)>>::ENCODING,]);
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopSourceContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopsourcecontext1?language=objc)
#[cfg(all(feature = "CFBase", feature = "libc"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopSourceContext1 {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFStringRef>,
    pub equal: Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void) -> Boolean>,
    pub hash: Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFHashCode>,
    pub getPort: Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>,
    pub perform: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            CFIndex,
            CFAllocatorRef,
            *mut c_void,
        ) -> *mut c_void,
    >,
}

#[cfg(all(feature = "CFBase", feature = "libc", feature = "objc2"))]
unsafe impl Encode for CFRunLoopSourceContext1 {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFStringRef>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void) -> Boolean>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFHashCode>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>>::ENCODING,
            <Option<
                unsafe extern "C-unwind" fn(
                    *mut c_void,
                    CFIndex,
                    CFAllocatorRef,
                    *mut c_void,
                ) -> *mut c_void,
            >>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CFBase", feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopSourceContext1 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceCreate(
        allocator: CFAllocatorRef,
        order: CFIndex,
        context: *mut CFRunLoopSourceContext,
    ) -> CFRunLoopSourceRef;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceGetOrder(source: CFRunLoopSourceRef) -> CFIndex;
}

extern "C-unwind" {
    pub fn CFRunLoopSourceInvalidate(source: CFRunLoopSourceRef);
}

extern "C-unwind" {
    pub fn CFRunLoopSourceIsValid(source: CFRunLoopSourceRef) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopSourceGetContext(
        source: CFRunLoopSourceRef,
        context: *mut CFRunLoopSourceContext,
    );
}

extern "C-unwind" {
    pub fn CFRunLoopSourceSignal(source: CFRunLoopSourceRef);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopobservercontext?language=objc)
#[cfg(feature = "CFBase")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopObserverContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFStringRef>,
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopObserverContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFStringRef>>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopObserverContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunloopobservercallback?language=objc)
#[cfg(feature = "CFBase")]
pub type CFRunLoopObserverCallBack =
    Option<unsafe extern "C-unwind" fn(CFRunLoopObserverRef, CFRunLoopActivity, *mut c_void)>;

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverCreate(
        allocator: CFAllocatorRef,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        callout: CFRunLoopObserverCallBack,
        context: *mut CFRunLoopObserverContext,
    ) -> CFRunLoopObserverRef;
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "block2"))]
    pub fn CFRunLoopObserverCreateWithHandler(
        allocator: CFAllocatorRef,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        block: Option<&block2::Block<dyn Fn(CFRunLoopObserverRef, CFRunLoopActivity)>>,
    ) -> CFRunLoopObserverRef;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetActivities(observer: CFRunLoopObserverRef) -> CFOptionFlags;
}

extern "C-unwind" {
    pub fn CFRunLoopObserverDoesRepeat(observer: CFRunLoopObserverRef) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetOrder(observer: CFRunLoopObserverRef) -> CFIndex;
}

extern "C-unwind" {
    pub fn CFRunLoopObserverInvalidate(observer: CFRunLoopObserverRef);
}

extern "C-unwind" {
    pub fn CFRunLoopObserverIsValid(observer: CFRunLoopObserverRef) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopObserverGetContext(
        observer: CFRunLoopObserverRef,
        context: *mut CFRunLoopObserverContext,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooptimercontext?language=objc)
#[cfg(feature = "CFBase")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFRunLoopTimerContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFStringRef>,
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl Encode for CFRunLoopTimerContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> CFStringRef>>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CFBase", feature = "objc2"))]
unsafe impl RefEncode for CFRunLoopTimerContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfrunlooptimercallback?language=objc)
pub type CFRunLoopTimerCallBack =
    Option<unsafe extern "C-unwind" fn(CFRunLoopTimerRef, *mut c_void)>;

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopTimerGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate"))]
    pub fn CFRunLoopTimerCreate(
        allocator: CFAllocatorRef,
        fire_date: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        callout: CFRunLoopTimerCallBack,
        context: *mut CFRunLoopTimerContext,
    ) -> CFRunLoopTimerRef;
}

extern "C-unwind" {
    #[cfg(all(feature = "CFBase", feature = "CFDate", feature = "block2"))]
    pub fn CFRunLoopTimerCreateWithHandler(
        allocator: CFAllocatorRef,
        fire_date: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        block: Option<&block2::Block<dyn Fn(CFRunLoopTimerRef)>>,
    ) -> CFRunLoopTimerRef;
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerGetNextFireDate(timer: CFRunLoopTimerRef) -> CFAbsoluteTime;
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerSetNextFireDate(timer: CFRunLoopTimerRef, fire_date: CFAbsoluteTime);
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerGetInterval(timer: CFRunLoopTimerRef) -> CFTimeInterval;
}

extern "C-unwind" {
    pub fn CFRunLoopTimerDoesRepeat(timer: CFRunLoopTimerRef) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopTimerGetOrder(timer: CFRunLoopTimerRef) -> CFIndex;
}

extern "C-unwind" {
    pub fn CFRunLoopTimerInvalidate(timer: CFRunLoopTimerRef);
}

extern "C-unwind" {
    pub fn CFRunLoopTimerIsValid(timer: CFRunLoopTimerRef) -> Boolean;
}

extern "C-unwind" {
    #[cfg(feature = "CFBase")]
    pub fn CFRunLoopTimerGetContext(timer: CFRunLoopTimerRef, context: *mut CFRunLoopTimerContext);
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerGetTolerance(timer: CFRunLoopTimerRef) -> CFTimeInterval;
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    pub fn CFRunLoopTimerSetTolerance(timer: CFRunLoopTimerRef, tolerance: CFTimeInterval);
}
