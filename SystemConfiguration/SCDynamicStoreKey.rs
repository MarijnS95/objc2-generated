//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

/// Creates a dynamic store key that can be used to access
/// a specific global (as opposed to a per-service or per-interface)
/// network configuration entity.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Parameter `domain`: A string specifying the desired domain, such as the
/// requested configuration (kSCDynamicStoreDomainSetup) or the
/// actual state (kSCDynamicStoreDomainState).
///
/// Parameter `entity`: A string containing the specific global entity, such
/// as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
///
/// Returns: Returns a string containing the formatted key.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkGlobalEntity(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
    entity: &CFString,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkGlobalEntity(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
            entity: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateNetworkGlobalEntity(allocator, domain, entity) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a dynamic store key that can be used to access
/// the network interface configuration information stored in
/// the dynamic store.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Parameter `domain`: A string specifying the desired domain, such as the
/// requested configuration (kSCDynamicStoreDomainSetup) or the
/// actual state (kSCDynamicStoreDomainState).
///
/// Returns: Returns a string containing the formatted key.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkInterface(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkInterface(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateNetworkInterface(allocator, domain) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a dynamic store key that can be used to access
/// the per-interface network configuration information stored in
/// the dynamic store.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Parameter `domain`: A string specifying the desired domain, such as the
/// requested configuration (kSCDynamicStoreDomainSetup) or the
/// actual state (kSCDynamicStoreDomainState).
///
/// Parameter `ifname`: A string containing the interface name or a regular
/// expression pattern.
///
/// Parameter `entity`: A string containing the specific global entity, such
/// as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
///
/// Returns: Returns a string containing the formatted key.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkInterfaceEntity(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
    ifname: &CFString,
    entity: Option<&CFString>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkInterfaceEntity(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
            ifname: &CFString,
            entity: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret =
        unsafe { SCDynamicStoreKeyCreateNetworkInterfaceEntity(allocator, domain, ifname, entity) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a dynamic store key that can be used to access
/// the per-service network configuration information stored in
/// the dynamic store.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Parameter `domain`: A string specifying the desired domain, such as the
/// requested configuration (kSCDynamicStoreDomainSetup) or the
/// actual state (kSCDynamicStoreDomainState).
///
/// Parameter `serviceID`: A string containing the service ID or a regular
/// expression pattern.
///
/// Parameter `entity`: A string containing the specific global entity, such
/// as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
///
/// Returns: Returns a string containing the formatted key.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkServiceEntity(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
    service_id: &CFString,
    entity: Option<&CFString>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkServiceEntity(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
            service_id: &CFString,
            entity: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        SCDynamicStoreKeyCreateNetworkServiceEntity(allocator, domain, service_id, entity)
    };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a key that can be used in conjuntion with
/// SCDynamicStoreSetNotificationKeys function to receive
/// notifications when the current computer name changes.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Returns: Returns a notification string for the current computer or
/// host name.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateComputerName(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateComputerName(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateComputerName(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a key that can be used in conjunction with
/// SCDynamicStoreSetNotificationKeys function to receive
/// notifications when the current console user changes.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Returns: Returns a notification string for the current console user.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateConsoleUser(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateConsoleUser(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateConsoleUser(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a key that can be used in conjunction with the
/// SCDynamicStoreSetNotificationKeys function to receive
/// notifications when the HostNames entity changes.  The
/// HostNames entity includes the local host name.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Returns: Returns a notification string for the HostNames entity.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateHostNames(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateHostNames(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateHostNames(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a key that can be used in conjunction with the
/// SCDynamicStoreSetNotificationKeys function to receive
/// notifications when the location identifier changes.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Returns: Returns a notification string for the current location
/// identifier.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateLocation(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateLocation(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateLocation(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Creates a key that can be used in conjunction with
/// the SCDynamicStoreSetNotificationKeys function to receive
/// notifications when the current network proxy settings
/// (such as HTTP or FTP) are changed.
///
/// Parameter `allocator`: The CFAllocator that should be used to allocate
/// memory for this key.
/// This parameter may be NULL in which case the current
/// default CFAllocator is used. If this reference is not
/// a valid CFAllocator, the behavior is undefined.
///
/// Returns: Returns a notification string for the current proxy settings.
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreKeyCreateProxies(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateProxies(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateProxies(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}
