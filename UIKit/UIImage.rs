//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
#[cfg(feature = "objc2-core-image")]
#[cfg(not(target_os = "watchos"))]
use objc2_core_image::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiimageorientation?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIImageOrientation(pub NSInteger);
impl UIImageOrientation {
    #[doc(alias = "UIImageOrientationUp")]
    pub const Up: Self = Self(0);
    #[doc(alias = "UIImageOrientationDown")]
    pub const Down: Self = Self(1);
    #[doc(alias = "UIImageOrientationLeft")]
    pub const Left: Self = Self(2);
    #[doc(alias = "UIImageOrientationRight")]
    pub const Right: Self = Self(3);
    #[doc(alias = "UIImageOrientationUpMirrored")]
    pub const UpMirrored: Self = Self(4);
    #[doc(alias = "UIImageOrientationDownMirrored")]
    pub const DownMirrored: Self = Self(5);
    #[doc(alias = "UIImageOrientationLeftMirrored")]
    pub const LeftMirrored: Self = Self(6);
    #[doc(alias = "UIImageOrientationRightMirrored")]
    pub const RightMirrored: Self = Self(7);
}

unsafe impl Encode for UIImageOrientation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIImageOrientation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiimageresizingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIImageResizingMode(pub NSInteger);
impl UIImageResizingMode {
    #[doc(alias = "UIImageResizingModeTile")]
    pub const Tile: Self = Self(0);
    #[doc(alias = "UIImageResizingModeStretch")]
    pub const Stretch: Self = Self(1);
}

unsafe impl Encode for UIImageResizingMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIImageResizingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiimagerenderingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIImageRenderingMode(pub NSInteger);
impl UIImageRenderingMode {
    #[doc(alias = "UIImageRenderingModeAutomatic")]
    pub const Automatic: Self = Self(0);
    #[doc(alias = "UIImageRenderingModeAlwaysOriginal")]
    pub const AlwaysOriginal: Self = Self(1);
    #[doc(alias = "UIImageRenderingModeAlwaysTemplate")]
    pub const AlwaysTemplate: Self = Self(2);
}

unsafe impl Encode for UIImageRenderingMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIImageRenderingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiimage?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIImage;
);

unsafe impl Send for UIImage {}

unsafe impl Sync for UIImage {}

unsafe impl NSCoding for UIImage {}

unsafe impl NSObjectProtocol for UIImage {}

unsafe impl NSSecureCoding for UIImage {}

extern_methods!(
    unsafe impl UIImage {
        #[unsafe(method_family(none))]
        #[method_id(systemImageNamed:)]
        pub unsafe fn systemImageNamed(name: &NSString) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        #[unsafe(method_family(none))]
        #[method_id(systemImageNamed:withConfiguration:)]
        pub unsafe fn systemImageNamed_withConfiguration(
            name: &NSString,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method_family(none))]
        #[method_id(systemImageNamed:compatibleWithTraitCollection:)]
        pub unsafe fn systemImageNamed_compatibleWithTraitCollection(
            name: &NSString,
            trait_collection: Option<&UITraitCollection>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        /// Retrieve a system-provided image with the specified name and variable value (between 0 and 1).
        ///
        /// This will only return system-provided images. If you want a custom image as defined in your own catalogs,
        /// you should use
        /// `+imageNamed:inBundle:variableValue:withConfiguration:.`
        /// Returns
        /// `nil`if an image with specified name doesn't exist.
        #[unsafe(method_family(none))]
        #[method_id(systemImageNamed:variableValue:withConfiguration:)]
        pub unsafe fn systemImageNamed_variableValue_withConfiguration(
            name: &NSString,
            value: c_double,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[unsafe(method_family(none))]
        #[method_id(imageNamed:)]
        pub unsafe fn imageNamed(name: &NSString) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        #[unsafe(method_family(none))]
        #[method_id(imageNamed:inBundle:withConfiguration:)]
        pub unsafe fn imageNamed_inBundle_withConfiguration(
            name: &NSString,
            bundle: Option<&NSBundle>,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method_family(none))]
        #[method_id(imageNamed:inBundle:compatibleWithTraitCollection:)]
        pub unsafe fn imageNamed_inBundle_compatibleWithTraitCollection(
            name: &NSString,
            bundle: Option<&NSBundle>,
            trait_collection: Option<&UITraitCollection>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        /// Retrieve a image with the specified name and variable value (between 0 and 1).
        ///
        /// This will only return custom images defined in your own catalogs. If you want a system-provided image,
        /// you should use
        /// `+systemImageNamed:variableValue:withConfiguration:.`
        /// Returns
        /// `nil`if an image with specified name doesn't exist.
        #[unsafe(method_family(none))]
        #[method_id(imageNamed:inBundle:variableValue:withConfiguration:)]
        pub unsafe fn imageNamed_inBundle_variableValue_withConfiguration(
            name: &NSString,
            bundle: Option<&NSBundle>,
            value: c_double,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[unsafe(method_family(none))]
        #[method_id(imageWithContentsOfFile:)]
        pub unsafe fn imageWithContentsOfFile(path: &NSString) -> Option<Retained<UIImage>>;

        #[unsafe(method_family(none))]
        #[method_id(imageWithData:)]
        pub unsafe fn imageWithData(data: &NSData) -> Option<Retained<UIImage>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method_family(none))]
        #[method_id(imageWithData:scale:)]
        pub unsafe fn imageWithData_scale(
            data: &NSData,
            scale: CGFloat,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method_family(none))]
        #[method_id(imageWithCGImage:)]
        pub unsafe fn imageWithCGImage(cg_image: &CGImage) -> Retained<UIImage>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method_family(none))]
        #[method_id(imageWithCGImage:scale:orientation:)]
        pub unsafe fn imageWithCGImage_scale_orientation(
            cg_image: &CGImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<UIImage>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method_family(none))]
        #[method_id(imageWithCIImage:)]
        pub unsafe fn imageWithCIImage(ci_image: &CIImage) -> Retained<UIImage>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-image"))]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method_family(none))]
        #[method_id(imageWithCIImage:scale:orientation:)]
        pub unsafe fn imageWithCIImage_scale_orientation(
            ci_image: &CIImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<UIImage>;

        #[unsafe(method_family(init))]
        #[method_id(initWithContentsOfFile:)]
        pub unsafe fn initWithContentsOfFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(initWithData:)]
        pub unsafe fn initWithData(this: Allocated<Self>, data: &NSData) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method_family(init))]
        #[method_id(initWithData:scale:)]
        pub unsafe fn initWithData_scale(
            this: Allocated<Self>,
            data: &NSData,
            scale: CGFloat,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method_family(init))]
        #[method_id(initWithCGImage:)]
        pub unsafe fn initWithCGImage(this: Allocated<Self>, cg_image: &CGImage) -> Retained<Self>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method_family(init))]
        #[method_id(initWithCGImage:scale:orientation:)]
        pub unsafe fn initWithCGImage_scale_orientation(
            this: Allocated<Self>,
            cg_image: &CGImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method_family(init))]
        #[method_id(initWithCIImage:)]
        pub unsafe fn initWithCIImage(this: Allocated<Self>, ci_image: &CIImage) -> Retained<Self>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-image"))]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method_family(init))]
        #[method_id(initWithCIImage:scale:orientation:)]
        pub unsafe fn initWithCIImage_scale_orientation(
            this: Allocated<Self>,
            ci_image: &CIImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[method(size)]
        pub unsafe fn size(&self) -> CGSize;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method_family(none))]
        #[method_id(CGImage)]
        pub unsafe fn CGImage(&self) -> Option<Retained<CGImage>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method_family(none))]
        #[method_id(CIImage)]
        pub unsafe fn CIImage(&self) -> Option<Retained<CIImage>>;

        #[method(imageOrientation)]
        pub unsafe fn imageOrientation(&self) -> UIImageOrientation;

        #[cfg(feature = "objc2-core-foundation")]
        #[method(scale)]
        pub unsafe fn scale(&self) -> CGFloat;

        #[method(isSymbolImage)]
        pub unsafe fn isSymbolImage(&self) -> bool;

        #[unsafe(method_family(none))]
        #[method_id(animatedImageNamed:duration:)]
        pub unsafe fn animatedImageNamed_duration(
            name: &NSString,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method_family(none))]
        #[method_id(animatedResizableImageNamed:capInsets:duration:)]
        pub unsafe fn animatedResizableImageNamed_capInsets_duration(
            name: &NSString,
            cap_insets: UIEdgeInsets,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method_family(none))]
        #[method_id(animatedResizableImageNamed:capInsets:resizingMode:duration:)]
        pub unsafe fn animatedResizableImageNamed_capInsets_resizingMode_duration(
            name: &NSString,
            cap_insets: UIEdgeInsets,
            resizing_mode: UIImageResizingMode,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        #[unsafe(method_family(none))]
        #[method_id(animatedImageWithImages:duration:)]
        pub unsafe fn animatedImageWithImages_duration(
            images: &NSArray<UIImage>,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        #[unsafe(method_family(none))]
        #[method_id(images)]
        pub unsafe fn images(&self) -> Option<Retained<NSArray<UIImage>>>;

        #[method(duration)]
        pub unsafe fn duration(&self) -> NSTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[method(drawAtPoint:)]
        pub unsafe fn drawAtPoint(&self, point: CGPoint);

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[method(drawAtPoint:blendMode:alpha:)]
        pub unsafe fn drawAtPoint_blendMode_alpha(
            &self,
            point: CGPoint,
            blend_mode: CGBlendMode,
            alpha: CGFloat,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[method(drawInRect:)]
        pub unsafe fn drawInRect(&self, rect: CGRect);

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[method(drawInRect:blendMode:alpha:)]
        pub unsafe fn drawInRect_blendMode_alpha(
            &self,
            rect: CGRect,
            blend_mode: CGBlendMode,
            alpha: CGFloat,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[method(drawAsPatternInRect:)]
        pub unsafe fn drawAsPatternInRect(&self, rect: CGRect);

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method_family(none))]
        #[method_id(resizableImageWithCapInsets:)]
        pub unsafe fn resizableImageWithCapInsets(
            &self,
            cap_insets: UIEdgeInsets,
        ) -> Retained<UIImage>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method_family(none))]
        #[method_id(resizableImageWithCapInsets:resizingMode:)]
        pub unsafe fn resizableImageWithCapInsets_resizingMode(
            &self,
            cap_insets: UIEdgeInsets,
            resizing_mode: UIImageResizingMode,
        ) -> Retained<UIImage>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[method(capInsets)]
        pub unsafe fn capInsets(&self) -> UIEdgeInsets;

        #[method(resizingMode)]
        pub unsafe fn resizingMode(&self) -> UIImageResizingMode;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method_family(none))]
        #[method_id(imageWithAlignmentRectInsets:)]
        pub unsafe fn imageWithAlignmentRectInsets(
            &self,
            alignment_insets: UIEdgeInsets,
        ) -> Retained<UIImage>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[method(alignmentRectInsets)]
        pub unsafe fn alignmentRectInsets(&self) -> UIEdgeInsets;

        #[unsafe(method_family(none))]
        #[method_id(imageWithRenderingMode:)]
        pub unsafe fn imageWithRenderingMode(
            &self,
            rendering_mode: UIImageRenderingMode,
        ) -> Retained<UIImage>;

        #[method(renderingMode)]
        pub unsafe fn renderingMode(&self) -> UIImageRenderingMode;

        #[cfg(all(feature = "UIGraphicsImageRenderer", feature = "UIGraphicsRenderer"))]
        #[unsafe(method_family(none))]
        #[method_id(imageRendererFormat)]
        pub unsafe fn imageRendererFormat(&self) -> Retained<UIGraphicsImageRendererFormat>;

        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method_family(none))]
        #[method_id(traitCollection)]
        pub unsafe fn traitCollection(&self) -> Retained<UITraitCollection>;

        #[cfg(feature = "UIImageAsset")]
        #[unsafe(method_family(none))]
        #[method_id(imageAsset)]
        pub unsafe fn imageAsset(&self) -> Option<Retained<UIImageAsset>>;

        #[unsafe(method_family(none))]
        #[method_id(imageFlippedForRightToLeftLayoutDirection)]
        pub unsafe fn imageFlippedForRightToLeftLayoutDirection(&self) -> Retained<UIImage>;

        #[method(flipsForRightToLeftLayoutDirection)]
        pub unsafe fn flipsForRightToLeftLayoutDirection(&self) -> bool;

        #[unsafe(method_family(none))]
        #[method_id(imageWithHorizontallyFlippedOrientation)]
        pub unsafe fn imageWithHorizontallyFlippedOrientation(&self) -> Retained<UIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        #[method(baselineOffsetFromBottom)]
        pub unsafe fn baselineOffsetFromBottom(&self) -> CGFloat;

        #[method(hasBaseline)]
        pub unsafe fn hasBaseline(&self) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method_family(none))]
        #[method_id(imageWithBaselineOffsetFromBottom:)]
        pub unsafe fn imageWithBaselineOffsetFromBottom(
            &self,
            baseline_offset: CGFloat,
        ) -> Retained<UIImage>;

        #[unsafe(method_family(none))]
        #[method_id(imageWithoutBaseline)]
        pub unsafe fn imageWithoutBaseline(&self) -> Retained<UIImage>;

        #[cfg(feature = "UIImageConfiguration")]
        #[unsafe(method_family(none))]
        #[method_id(configuration)]
        pub unsafe fn configuration(&self) -> Option<Retained<UIImageConfiguration>>;

        #[cfg(feature = "UIImageConfiguration")]
        #[unsafe(method_family(none))]
        #[method_id(imageWithConfiguration:)]
        pub unsafe fn imageWithConfiguration(
            &self,
            configuration: &UIImageConfiguration,
        ) -> Retained<UIImage>;

        #[cfg(all(
            feature = "UIImageConfiguration",
            feature = "UIImageSymbolConfiguration"
        ))]
        #[unsafe(method_family(none))]
        #[method_id(symbolConfiguration)]
        pub unsafe fn symbolConfiguration(&self) -> Option<Retained<UIImageSymbolConfiguration>>;

        #[cfg(all(
            feature = "UIImageConfiguration",
            feature = "UIImageSymbolConfiguration"
        ))]
        #[unsafe(method_family(none))]
        #[method_id(imageByApplyingSymbolConfiguration:)]
        pub unsafe fn imageByApplyingSymbolConfiguration(
            &self,
            configuration: &UIImageSymbolConfiguration,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIColor")]
        #[unsafe(method_family(none))]
        #[method_id(imageWithTintColor:)]
        pub unsafe fn imageWithTintColor(&self, color: &UIColor) -> Retained<UIImage>;

        #[cfg(feature = "UIColor")]
        #[unsafe(method_family(none))]
        #[method_id(imageWithTintColor:renderingMode:)]
        pub unsafe fn imageWithTintColor_renderingMode(
            &self,
            color: &UIColor,
            rendering_mode: UIImageRenderingMode,
        ) -> Retained<UIImage>;

        /// Decodes an image synchronously and provides a new one for display in views and animations.
        ///
        ///
        /// Returns: A new version of the image object for display. If the system can’t decode the image, this method returns `nil`.
        ///
        ///
        /// Note: The prepared `UIImage` is not related to the original image. If the properties of the screen (such as its resolution or color gamut) change, or if the image is displayed on a different screen that the one it was prepared for, it may not render correctly.
        #[unsafe(method_family(none))]
        #[method_id(imageByPreparingForDisplay)]
        pub unsafe fn imageByPreparingForDisplay(&self) -> Option<Retained<UIImage>>;

        #[cfg(feature = "block2")]
        /// Decodes an image asynchronously and provides a new one for display in views and animations.
        ///
        /// The completion handler will be invoked on a private queue. Be sure to return to the main queue before assigning the prepared image to an image view.
        ///
        ///
        /// Parameter `completionHandler`: A block to invoke with the prepared image. If preparation failed (for example, because the image data is corrupt),
        /// `image`will be `nil`.
        ///
        ///
        /// Note: The prepared `UIImage` is not related to the original image. If the properties of the screen (such as its resolution or color gamut) change, or if the image is displayed on a different screen that the one it was prepared for, it may not render correctly.
        #[method(prepareForDisplayWithCompletionHandler:)]
        pub unsafe fn prepareForDisplayWithCompletionHandler(
            &self,
            completion_handler: &block2::Block<dyn Fn(*mut UIImage)>,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method_family(none))]
        #[method_id(imageByPreparingThumbnailOfSize:)]
        pub unsafe fn imageByPreparingThumbnailOfSize(
            &self,
            size: CGSize,
        ) -> Option<Retained<UIImage>>;

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        #[method(prepareThumbnailOfSize:completionHandler:)]
        pub unsafe fn prepareThumbnailOfSize_completionHandler(
            &self,
            size: CGSize,
            completion_handler: &block2::Block<dyn Fn(*mut UIImage)>,
        );

        /// Indicates that this image is tagged for display of high dynamic range content.
        #[method(isHighDynamicRange)]
        pub unsafe fn isHighDynamicRange(&self) -> bool;

        /// Returns a new image that will render within the standard range.
        #[unsafe(method_family(none))]
        #[method_id(imageRestrictedToStandardDynamicRange)]
        pub unsafe fn imageRestrictedToStandardDynamicRange(&self) -> Retained<UIImage>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UIImage {
        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_methods!(
    /// PreconfiguredSystemImages
    unsafe impl UIImage {
        #[unsafe(method_family(none))]
        #[method_id(actionsImage)]
        pub unsafe fn actionsImage() -> Retained<UIImage>;

        #[unsafe(method_family(none))]
        #[method_id(addImage)]
        pub unsafe fn addImage() -> Retained<UIImage>;

        #[unsafe(method_family(none))]
        #[method_id(removeImage)]
        pub unsafe fn removeImage() -> Retained<UIImage>;

        #[unsafe(method_family(none))]
        #[method_id(checkmarkImage)]
        pub unsafe fn checkmarkImage() -> Retained<UIImage>;

        #[unsafe(method_family(none))]
        #[method_id(strokedCheckmarkImage)]
        pub unsafe fn strokedCheckmarkImage() -> Retained<UIImage>;
    }
);

extern_methods!(
    /// NSItemProvider
    unsafe impl UIImage {}
);

unsafe impl NSItemProviderReading for UIImage {}

unsafe impl NSItemProviderWriting for UIImage {}

extern_methods!(
    /// UIImage
    #[cfg(feature = "NSTextAttachment")]
    unsafe impl NSTextAttachment {
        #[unsafe(method_family(none))]
        #[method_id(textAttachmentWithImage:)]
        pub unsafe fn textAttachmentWithImage(image: &UIImage) -> Retained<NSTextAttachment>;
    }
);

extern_methods!(
    /// UIImageDeprecated
    unsafe impl UIImage {
        #[unsafe(method_family(none))]
        #[method_id(stretchableImageWithLeftCapWidth:topCapHeight:)]
        pub unsafe fn stretchableImageWithLeftCapWidth_topCapHeight(
            &self,
            left_cap_width: NSInteger,
            top_cap_height: NSInteger,
        ) -> Retained<UIImage>;

        #[method(leftCapWidth)]
        pub unsafe fn leftCapWidth(&self) -> NSInteger;

        #[method(topCapHeight)]
        pub unsafe fn topCapHeight(&self) -> NSInteger;
    }
);

extern_category!(
    /// Category "UIKitAdditions" on [`CIImage`].
    #[doc(alias = "UIKitAdditions")]
    pub unsafe trait CIImageUIKitAdditions {
        #[unsafe(method_family(init))]
        #[method_id(initWithImage:)]
        unsafe fn initWithImage(this: Allocated<Self>, image: &UIImage) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method_family(init))]
        #[method_id(initWithImage:options:)]
        unsafe fn initWithImage_options(
            this: Allocated<Self>,
            image: &UIImage,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<Self>>;
    }

    #[cfg(feature = "objc2-core-image")]
    #[cfg(not(target_os = "watchos"))]
    unsafe impl CIImageUIKitAdditions for CIImage {}
);

/// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format
#[inline]
pub unsafe extern "C-unwind" fn UIImagePNGRepresentation(
    image: &UIImage,
) -> Option<Retained<NSData>> {
    extern "C-unwind" {
        fn UIImagePNGRepresentation(image: &UIImage) -> *mut NSData;
    }
    let ret = unsafe { UIImagePNGRepresentation(image) };
    unsafe { Retained::retain_autoreleased(ret) }
}

/// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn UIImageJPEGRepresentation(
    image: &UIImage,
    compression_quality: CGFloat,
) -> Option<Retained<NSData>> {
    extern "C-unwind" {
        fn UIImageJPEGRepresentation(image: &UIImage, compression_quality: CGFloat) -> *mut NSData;
    }
    let ret = unsafe { UIImageJPEGRepresentation(image, compression_quality) };
    unsafe { Retained::retain_autoreleased(ret) }
}

/// Returns HEIC data representing the image, or nil if such a representation could not be generated. HEIC is recommended for efficiently storing all kinds of images, including those with high dynamic range content.
#[inline]
pub unsafe extern "C-unwind" fn UIImageHEICRepresentation(
    image: &UIImage,
) -> Option<Retained<NSData>> {
    extern "C-unwind" {
        fn UIImageHEICRepresentation(image: &UIImage) -> *mut NSData;
    }
    let ret = unsafe { UIImageHEICRepresentation(image) };
    unsafe { Retained::retain_autoreleased(ret) }
}
