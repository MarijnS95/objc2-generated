//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorydisplayedstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UICellAccessoryDisplayedState(pub NSInteger);
impl UICellAccessoryDisplayedState {
    /// The accessory is always displayed.
    #[doc(alias = "UICellAccessoryDisplayedAlways")]
    pub const Always: Self = Self(0);
    /// The accessory is displayed only when the cell is editing.
    #[doc(alias = "UICellAccessoryDisplayedWhenEditing")]
    pub const WhenEditing: Self = Self(1);
    /// The accessory is displayed only when the cell is not editing.
    #[doc(alias = "UICellAccessoryDisplayedWhenNotEditing")]
    pub const WhenNotEditing: Self = Self(2);
}

unsafe impl Encode for UICellAccessoryDisplayedState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UICellAccessoryDisplayedState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A special constant that can be set to the `reservedLayoutWidth` property. This requests the
    /// system standard layout width.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorystandarddimension?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static UICellAccessoryStandardDimension: CGFloat;
}

extern_class!(
    /// Abstract base class. Do not instantiate directly.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessory?language=objc)
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessory;
);

unsafe impl NSCoding for UICellAccessory {}

unsafe impl NSCopying for UICellAccessory {}

unsafe impl CopyingHelper for UICellAccessory {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessory {}

unsafe impl NSSecureCoding for UICellAccessory {}

extern_methods!(
    unsafe impl UICellAccessory {
        /// The state(s) for which the accessory should be displayed.
        #[method(displayedState)]
        pub unsafe fn displayedState(&self) -> UICellAccessoryDisplayedState;

        /// Setter for [`displayedState`][Self::displayedState].
        #[method(setDisplayedState:)]
        pub unsafe fn setDisplayedState(&self, displayed_state: UICellAccessoryDisplayedState);

        /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
        /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
        #[method(isHidden)]
        pub unsafe fn isHidden(&self) -> bool;

        /// Setter for [`isHidden`][Self::isHidden].
        #[method(setHidden:)]
        pub unsafe fn setHidden(&self, hidden: bool);

        #[cfg(feature = "objc2-core-foundation")]
        /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
        /// This is used to ensure horizontal alignment of different accessories in adjacent cells, even when
        /// the actual accessory view width varies slightly. A value of 0 means the actual width of the
        /// accessory will be used. Use UICellAccessoryStandardDimension to request the standard width.
        #[method(reservedLayoutWidth)]
        pub unsafe fn reservedLayoutWidth(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`reservedLayoutWidth`][Self::reservedLayoutWidth].
        #[method(setReservedLayoutWidth:)]
        pub unsafe fn setReservedLayoutWidth(&self, reserved_layout_width: CGFloat);

        #[cfg(feature = "UIColor")]
        /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
        #[unsafe(method_family(none))]
        #[method_id(tintColor)]
        pub unsafe fn tintColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`tintColor`][Self::tintColor].
        #[method(setTintColor:)]
        pub unsafe fn setTintColor(&self, tint_color: Option<&UIColor>);

        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessory {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// A disclosure chevron that points in the trailing direction.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorydisclosureindicator?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryDisclosureIndicator;
);

unsafe impl NSCoding for UICellAccessoryDisclosureIndicator {}

unsafe impl NSCopying for UICellAccessoryDisclosureIndicator {}

unsafe impl CopyingHelper for UICellAccessoryDisclosureIndicator {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryDisclosureIndicator {}

unsafe impl NSSecureCoding for UICellAccessoryDisclosureIndicator {}

extern_methods!(
    unsafe impl UICellAccessoryDisclosureIndicator {}
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryDisclosureIndicator {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryDisclosureIndicator {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// A detail (info) button.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorydetail?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryDetail;
);

unsafe impl NSCoding for UICellAccessoryDetail {}

unsafe impl NSCopying for UICellAccessoryDetail {}

unsafe impl CopyingHelper for UICellAccessoryDetail {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryDetail {}

unsafe impl NSSecureCoding for UICellAccessoryDetail {}

extern_methods!(
    unsafe impl UICellAccessoryDetail {
        #[cfg(feature = "block2")]
        /// An optional handler to call when the detail accessory is tapped. If nil, taps on the accessory are ignored.
        #[method(actionHandler)]
        pub unsafe fn actionHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`actionHandler`][Self::actionHandler].
        #[method(setActionHandler:)]
        pub unsafe fn setActionHandler(&self, action_handler: Option<&block2::Block<dyn Fn()>>);
    }
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryDetail {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryDetail {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// A checkmark with default green color.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorycheckmark?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryCheckmark;
);

unsafe impl NSCoding for UICellAccessoryCheckmark {}

unsafe impl NSCopying for UICellAccessoryCheckmark {}

unsafe impl CopyingHelper for UICellAccessoryCheckmark {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryCheckmark {}

unsafe impl NSSecureCoding for UICellAccessoryCheckmark {}

extern_methods!(
    unsafe impl UICellAccessoryCheckmark {}
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryCheckmark {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryCheckmark {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// A delete control (minus sign inside a circle) with default red color.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorydelete?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryDelete;
);

unsafe impl NSCoding for UICellAccessoryDelete {}

unsafe impl NSCopying for UICellAccessoryDelete {}

unsafe impl CopyingHelper for UICellAccessoryDelete {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryDelete {}

unsafe impl NSSecureCoding for UICellAccessoryDelete {}

extern_methods!(
    unsafe impl UICellAccessoryDelete {
        #[cfg(feature = "UIColor")]
        /// The background color to apply to the accessory. Default value is nil, which uses the system default.
        #[unsafe(method_family(none))]
        #[method_id(backgroundColor)]
        pub unsafe fn backgroundColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`backgroundColor`][Self::backgroundColor].
        #[method(setBackgroundColor:)]
        pub unsafe fn setBackgroundColor(&self, background_color: Option<&UIColor>);

        #[cfg(feature = "block2")]
        /// An optional handler to call when the delete accessory is tapped. If nil, a tap will reveal any trailing swipe actions for the cell.
        #[method(actionHandler)]
        pub unsafe fn actionHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`actionHandler`][Self::actionHandler].
        #[method(setActionHandler:)]
        pub unsafe fn setActionHandler(&self, action_handler: Option<&block2::Block<dyn Fn()>>);
    }
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryDelete {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryDelete {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// An insert control (plus sign inside a circle) with default green color.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessoryinsert?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryInsert;
);

unsafe impl NSCoding for UICellAccessoryInsert {}

unsafe impl NSCopying for UICellAccessoryInsert {}

unsafe impl CopyingHelper for UICellAccessoryInsert {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryInsert {}

unsafe impl NSSecureCoding for UICellAccessoryInsert {}

extern_methods!(
    unsafe impl UICellAccessoryInsert {
        #[cfg(feature = "UIColor")]
        /// The background color to apply to the accessory. Default value is nil, which uses the system default.
        #[unsafe(method_family(none))]
        #[method_id(backgroundColor)]
        pub unsafe fn backgroundColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`backgroundColor`][Self::backgroundColor].
        #[method(setBackgroundColor:)]
        pub unsafe fn setBackgroundColor(&self, background_color: Option<&UIColor>);

        #[cfg(feature = "block2")]
        /// An optional handler to call when the insert accessory is tapped. If nil, taps on the accessory are ignored.
        #[method(actionHandler)]
        pub unsafe fn actionHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`actionHandler`][Self::actionHandler].
        #[method(setActionHandler:)]
        pub unsafe fn setActionHandler(&self, action_handler: Option<&block2::Block<dyn Fn()>>);
    }
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryInsert {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryInsert {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// A reorder control (three horizontal lines) with default gray color that automatically initiates interactive
    /// reordering on the collection view when dragged (if supported).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessoryreorder?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryReorder;
);

unsafe impl NSCoding for UICellAccessoryReorder {}

unsafe impl NSCopying for UICellAccessoryReorder {}

unsafe impl CopyingHelper for UICellAccessoryReorder {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryReorder {}

unsafe impl NSSecureCoding for UICellAccessoryReorder {}

extern_methods!(
    unsafe impl UICellAccessoryReorder {
        /// Whether a vertical separator is displayed before the accessory when it is placed after another accessory. Default is YES.
        #[method(showsVerticalSeparator)]
        pub unsafe fn showsVerticalSeparator(&self) -> bool;

        /// Setter for [`showsVerticalSeparator`][Self::showsVerticalSeparator].
        #[method(setShowsVerticalSeparator:)]
        pub unsafe fn setShowsVerticalSeparator(&self, shows_vertical_separator: bool);
    }
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryReorder {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryReorder {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// A two-state control whose appearance follows the selection state of the cell (empty circle when deselected,
    /// filled circle with checkmark when selected).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorymultiselect?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryMultiselect;
);

unsafe impl NSCoding for UICellAccessoryMultiselect {}

unsafe impl NSCopying for UICellAccessoryMultiselect {}

unsafe impl CopyingHelper for UICellAccessoryMultiselect {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryMultiselect {}

unsafe impl NSSecureCoding for UICellAccessoryMultiselect {}

extern_methods!(
    unsafe impl UICellAccessoryMultiselect {
        #[cfg(feature = "UIColor")]
        /// The background color to apply to the accessory. Default value is nil, which uses the system default.
        #[unsafe(method_family(none))]
        #[method_id(backgroundColor)]
        pub unsafe fn backgroundColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`backgroundColor`][Self::backgroundColor].
        #[method(setBackgroundColor:)]
        pub unsafe fn setBackgroundColor(&self, background_color: Option<&UIColor>);
    }
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryMultiselect {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryMultiselect {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessoryoutlinedisclosurestyle?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UICellAccessoryOutlineDisclosureStyle(pub NSInteger);
impl UICellAccessoryOutlineDisclosureStyle {
    /// The style will be automatically determined based on whether the cell is configured to be a section header or not.
    #[doc(alias = "UICellAccessoryOutlineDisclosureStyleAutomatic")]
    pub const Automatic: Self = Self(0);
    /// A style appropriate for a section header, where a tap anywhere in the header will toggle the expansion state
    /// of the item (the cell cannot be selected).
    #[doc(alias = "UICellAccessoryOutlineDisclosureStyleHeader")]
    pub const Header: Self = Self(1);
    /// A style appropriate for a cell which can be selected itself and also has nested children, where only taps on the
    /// outline disclosure will toggle the expansion state of the item; taps on the cell will select the item as normal.
    #[doc(alias = "UICellAccessoryOutlineDisclosureStyleCell")]
    pub const Cell: Self = Self(2);
}

unsafe impl Encode for UICellAccessoryOutlineDisclosureStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UICellAccessoryOutlineDisclosureStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A rotating disclosure chevron for use with outlines, used to indicate and toggle the expanded/collapsed state of the item.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessoryoutlinedisclosure?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryOutlineDisclosure;
);

unsafe impl NSCoding for UICellAccessoryOutlineDisclosure {}

unsafe impl NSCopying for UICellAccessoryOutlineDisclosure {}

unsafe impl CopyingHelper for UICellAccessoryOutlineDisclosure {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryOutlineDisclosure {}

unsafe impl NSSecureCoding for UICellAccessoryOutlineDisclosure {}

extern_methods!(
    unsafe impl UICellAccessoryOutlineDisclosure {
        /// The style of the outline disclosure accessory. Default is automatic.
        #[method(style)]
        pub unsafe fn style(&self) -> UICellAccessoryOutlineDisclosureStyle;

        /// Setter for [`style`][Self::style].
        #[method(setStyle:)]
        pub unsafe fn setStyle(&self, style: UICellAccessoryOutlineDisclosureStyle);

        #[cfg(feature = "block2")]
        /// An optional handler to call when the outline disclosure accessory is tapped. If nil, the default behavior when using
        /// a NSDiffableDataSourceSectionSnapshot is to toggle the expand/collapse state of the item in the section snapshot.
        #[method(actionHandler)]
        pub unsafe fn actionHandler(&self) -> *mut block2::Block<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`actionHandler`][Self::actionHandler].
        #[method(setActionHandler:)]
        pub unsafe fn setActionHandler(&self, action_handler: Option<&block2::Block<dyn Fn()>>);
    }
);

extern_methods!(
    /// Methods declared on superclass `UICellAccessory`
    unsafe impl UICellAccessoryOutlineDisclosure {
        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UICellAccessoryOutlineDisclosure {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// Up/down chevrons that indicate a tap anywhere in the cell presents a pop-up menu.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorypopupmenu?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryPopUpMenu;
);

unsafe impl NSCoding for UICellAccessoryPopUpMenu {}

unsafe impl NSCopying for UICellAccessoryPopUpMenu {}

unsafe impl CopyingHelper for UICellAccessoryPopUpMenu {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryPopUpMenu {}

unsafe impl NSSecureCoding for UICellAccessoryPopUpMenu {}

extern_methods!(
    unsafe impl UICellAccessoryPopUpMenu {
        #[cfg(all(feature = "UIMenu", feature = "UIMenuElement"))]
        /// Creates a new pop-up menu accessory using the provided menu.
        #[unsafe(method_family(init))]
        #[method_id(initWithMenu:)]
        pub unsafe fn initWithMenu(this: Allocated<Self>, menu: &UIMenu) -> Retained<Self>;

        #[cfg(all(feature = "UIMenu", feature = "UIMenuElement"))]
        #[unsafe(method_family(none))]
        #[method_id(menu)]
        pub unsafe fn menu(&self) -> Retained<UIMenu>;

        #[cfg(all(feature = "UIMenu", feature = "UIMenuElement", feature = "block2"))]
        /// An optional handler to call when the selected element in the menu changes.
        #[method(selectedElementDidChangeHandler)]
        pub unsafe fn selectedElementDidChangeHandler(
            &self,
        ) -> *mut block2::Block<dyn Fn(NonNull<UIMenu>)>;

        #[cfg(all(feature = "UIMenu", feature = "UIMenuElement", feature = "block2"))]
        /// Setter for [`selectedElementDidChangeHandler`][Self::selectedElementDidChangeHandler].
        #[method(setSelectedElementDidChangeHandler:)]
        pub unsafe fn setSelectedElementDidChangeHandler(
            &self,
            selected_element_did_change_handler: Option<&block2::Block<dyn Fn(NonNull<UIMenu>)>>,
        );

        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_class!(
    /// A label displaying a short string of text, typically a small number such as a count for the associated item.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorylabel?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryLabel;
);

unsafe impl NSCoding for UICellAccessoryLabel {}

unsafe impl NSCopying for UICellAccessoryLabel {}

unsafe impl CopyingHelper for UICellAccessoryLabel {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryLabel {}

unsafe impl NSSecureCoding for UICellAccessoryLabel {}

extern_methods!(
    unsafe impl UICellAccessoryLabel {
        /// Creates a new label accessory using the provided text.
        #[unsafe(method_family(init))]
        #[method_id(initWithText:)]
        pub unsafe fn initWithText(this: Allocated<Self>, text: &NSString) -> Retained<Self>;

        #[unsafe(method_family(none))]
        #[method_id(text)]
        pub unsafe fn text(&self) -> Retained<NSString>;

        #[cfg(feature = "UIFont")]
        /// The font used for the label. Default is the preferred font for UIFontTextStyleBody.
        #[unsafe(method_family(none))]
        #[method_id(font)]
        pub unsafe fn font(&self) -> Retained<UIFont>;

        #[cfg(feature = "UIFont")]
        /// Setter for [`font`][Self::font].
        #[method(setFont:)]
        pub unsafe fn setFont(&self, font: &UIFont);

        /// Whether the label automatically adjusts its font based on the content size category. Default is YES.
        #[method(adjustsFontForContentSizeCategory)]
        pub unsafe fn adjustsFontForContentSizeCategory(&self) -> bool;

        /// Setter for [`adjustsFontForContentSizeCategory`][Self::adjustsFontForContentSizeCategory].
        #[method(setAdjustsFontForContentSizeCategory:)]
        pub unsafe fn setAdjustsFontForContentSizeCategory(
            &self,
            adjusts_font_for_content_size_category: bool,
        );

        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessoryplacement?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UICellAccessoryPlacement(pub NSInteger);
impl UICellAccessoryPlacement {
    /// Accessory placed on the leading edge.
    #[doc(alias = "UICellAccessoryPlacementLeading")]
    pub const Leading: Self = Self(0);
    /// Accessory placed on the trailing edge.
    #[doc(alias = "UICellAccessoryPlacementTrailing")]
    pub const Trailing: Self = Self(1);
}

unsafe impl Encode for UICellAccessoryPlacement {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UICellAccessoryPlacement {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Return an index to insert the accessory at, given an array of the existing accessories on the edge (in leading to trailing order).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessoryposition?language=objc)
#[cfg(feature = "block2")]
pub type UICellAccessoryPosition =
    *mut block2::Block<dyn Fn(NonNull<NSArray<UICellAccessory>>) -> NSUInteger>;

extern "C-unwind" {
    /// Positions the accessory before the accessory matching the class specified, or at the beginning if not found.
    #[cfg(feature = "block2")]
    pub fn UICellAccessoryPositionBeforeAccessoryOfClass(
        accessory_class: &AnyClass,
    ) -> UICellAccessoryPosition;
}

extern "C-unwind" {
    /// Positions the accessory after the accessory matching the class specified, or at the end if not found.
    #[cfg(feature = "block2")]
    pub fn UICellAccessoryPositionAfterAccessoryOfClass(
        accessory_class: &AnyClass,
    ) -> UICellAccessoryPosition;
}

extern_class!(
    /// An accessory using a custom view.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uicellaccessorycustomview?language=objc)
    #[unsafe(super(UICellAccessory, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICellAccessoryCustomView;
);

unsafe impl NSCoding for UICellAccessoryCustomView {}

unsafe impl NSCopying for UICellAccessoryCustomView {}

unsafe impl CopyingHelper for UICellAccessoryCustomView {
    type Result = Self;
}

unsafe impl NSObjectProtocol for UICellAccessoryCustomView {}

unsafe impl NSSecureCoding for UICellAccessoryCustomView {}

extern_methods!(
    unsafe impl UICellAccessoryCustomView {
        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        /// Creates a new custom view accessory using the provided view and specified placement. The custom view must have translatesAutoresizingMaskIntoConstraints
        /// enabled, but may use auto layout constraints internally for layout of subviews and/or to indicate its preferred size.
        #[unsafe(method_family(init))]
        #[method_id(initWithCustomView:placement:)]
        pub unsafe fn initWithCustomView_placement(
            this: Allocated<Self>,
            custom_view: &UIView,
            placement: UICellAccessoryPlacement,
        ) -> Retained<Self>;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method_family(none))]
        #[method_id(customView)]
        pub unsafe fn customView(&self) -> Retained<UIView>;

        #[method(placement)]
        pub unsafe fn placement(&self) -> UICellAccessoryPlacement;

        /// Whether the current frame size of the view is preserved (YES), or whether it is sized during layout of accessories (NO). Default is NO.
        #[method(maintainsFixedSize)]
        pub unsafe fn maintainsFixedSize(&self) -> bool;

        /// Setter for [`maintainsFixedSize`][Self::maintainsFixedSize].
        #[method(setMaintainsFixedSize:)]
        pub unsafe fn setMaintainsFixedSize(&self, maintains_fixed_size: bool);

        #[cfg(feature = "block2")]
        /// Allows customizing the relative position of the accessory amongst any other accessories displayed on the same edge.
        /// The default is to insert the accessory at a position closest to the inside of the cell.
        #[method(position)]
        pub unsafe fn position(&self) -> UICellAccessoryPosition;

        #[cfg(feature = "block2")]
        /// Setter for [`position`][Self::position].
        #[method(setPosition:)]
        pub unsafe fn setPosition(&self, position: UICellAccessoryPosition);

        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);
