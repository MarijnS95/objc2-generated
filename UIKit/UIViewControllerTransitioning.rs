//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontextfromviewcontrollerkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextFromViewControllerKey:
        &'static UITransitionContextViewControllerKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontexttoviewcontrollerkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextToViewControllerKey:
        &'static UITransitionContextViewControllerKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontextfromviewkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextFromViewKey: &'static UITransitionContextViewKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontexttoviewkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextToViewKey: &'static UITransitionContextViewKey;
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning?language=objc)
    pub unsafe trait UIViewControllerContextTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[method(containerView)]
        #[unsafe(method_family = none)]
        unsafe fn containerView(&self) -> Retained<UIView>;

        #[method(isAnimated)]
        #[unsafe(method_family = none)]
        unsafe fn isAnimated(&self) -> bool;

        #[method(isInteractive)]
        #[unsafe(method_family = none)]
        unsafe fn isInteractive(&self) -> bool;

        #[method(transitionWasCancelled)]
        #[unsafe(method_family = none)]
        unsafe fn transitionWasCancelled(&self) -> bool;

        #[cfg(feature = "UIViewController")]
        #[method(presentationStyle)]
        #[unsafe(method_family = none)]
        unsafe fn presentationStyle(&self) -> UIModalPresentationStyle;

        #[cfg(feature = "objc2-core-foundation")]
        #[method(updateInteractiveTransition:)]
        #[unsafe(method_family = none)]
        unsafe fn updateInteractiveTransition(&self, percent_complete: CGFloat);

        #[method(finishInteractiveTransition)]
        #[unsafe(method_family = none)]
        unsafe fn finishInteractiveTransition(&self);

        #[method(cancelInteractiveTransition)]
        #[unsafe(method_family = none)]
        unsafe fn cancelInteractiveTransition(&self);

        #[method(pauseInteractiveTransition)]
        #[unsafe(method_family = none)]
        unsafe fn pauseInteractiveTransition(&self);

        #[method(completeTransition:)]
        #[unsafe(method_family = none)]
        unsafe fn completeTransition(&self, did_complete: bool);

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[method(viewControllerForKey:)]
        #[unsafe(method_family = none)]
        unsafe fn viewControllerForKey(
            &self,
            key: &UITransitionContextViewControllerKey,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIView",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[method(viewForKey:)]
        #[unsafe(method_family = none)]
        unsafe fn viewForKey(&self, key: &UITransitionContextViewKey) -> Option<Retained<UIView>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[method(targetTransform)]
        #[unsafe(method_family = none)]
        unsafe fn targetTransform(&self) -> CGAffineTransform;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "objc2-core-foundation"
        ))]
        #[method(initialFrameForViewController:)]
        #[unsafe(method_family = none)]
        unsafe fn initialFrameForViewController(&self, vc: &UIViewController) -> CGRect;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "objc2-core-foundation"
        ))]
        #[method(finalFrameForViewController:)]
        #[unsafe(method_family = none)]
        unsafe fn finalFrameForViewController(&self, vc: &UIViewController) -> CGRect;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning?language=objc)
    pub unsafe trait UIViewControllerAnimatedTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[method(transitionDuration:)]
        #[unsafe(method_family = none)]
        unsafe fn transitionDuration(
            &self,
            transition_context: Option<&ProtocolObject<dyn UIViewControllerContextTransitioning>>,
        ) -> NSTimeInterval;

        #[method(animateTransition:)]
        #[unsafe(method_family = none)]
        unsafe fn animateTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        );

        #[cfg(feature = "UIViewAnimating")]
        /// A conforming object implements this method if the transition it creates can
        /// be interrupted. For example, it could return an instance of a
        /// UIViewPropertyAnimator. It is expected that this method will return the same
        /// instance for the life of a transition.
        #[optional]
        #[method(interruptibleAnimatorForTransition:)]
        #[unsafe(method_family = none)]
        unsafe fn interruptibleAnimatorForTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        ) -> Retained<ProtocolObject<dyn UIViewImplicitlyAnimating>>;

        #[optional]
        #[method(animationEnded:)]
        #[unsafe(method_family = none)]
        unsafe fn animationEnded(&self, transition_completed: bool);
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrollerinteractivetransitioning?language=objc)
    pub unsafe trait UIViewControllerInteractiveTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[method(startInteractiveTransition:)]
        #[unsafe(method_family = none)]
        unsafe fn startInteractiveTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[method(completionSpeed)]
        #[unsafe(method_family = none)]
        unsafe fn completionSpeed(&self) -> CGFloat;

        #[cfg(feature = "UIView")]
        #[optional]
        #[method(completionCurve)]
        #[unsafe(method_family = none)]
        unsafe fn completionCurve(&self) -> UIViewAnimationCurve;

        /// In 10.0, if an object conforming to UIViewControllerAnimatedTransitioning is
        /// known to be interruptible, it is possible to start it as if it was not
        /// interactive and then interrupt the transition and interact with it. In this
        /// case, implement this method and return NO. If an interactor does not
        /// implement this method, YES is assumed.
        #[optional]
        #[method(wantsInteractiveStart)]
        #[unsafe(method_family = none)]
        unsafe fn wantsInteractiveStart(&self) -> bool;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioningdelegate?language=objc)
    pub unsafe trait UIViewControllerTransitioningDelegate:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[method(animationControllerForPresentedController:presentingController:sourceController:)]
        #[unsafe(method_family = none)]
        unsafe fn animationControllerForPresentedController_presentingController_sourceController(
            &self,
            presented: &UIViewController,
            presenting: &UIViewController,
            source: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[method(animationControllerForDismissedController:)]
        #[unsafe(method_family = none)]
        unsafe fn animationControllerForDismissedController(
            &self,
            dismissed: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;

        #[optional]
        #[method(interactionControllerForPresentation:)]
        #[unsafe(method_family = none)]
        unsafe fn interactionControllerForPresentation(
            &self,
            animator: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[optional]
        #[method(interactionControllerForDismissal:)]
        #[unsafe(method_family = none)]
        unsafe fn interactionControllerForDismissal(
            &self,
            animator: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[cfg(all(
            feature = "UIPresentationController",
            feature = "UIResponder",
            feature = "UIViewController"
        ))]
        #[optional]
        #[method(presentationControllerForPresentedViewController:presentingViewController:sourceViewController:)]
        #[unsafe(method_family = none)]
        unsafe fn presentationControllerForPresentedViewController_presentingViewController_sourceViewController(
            &self,
            presented: &UIViewController,
            presenting: Option<&UIViewController>,
            source: &UIViewController,
        ) -> Option<Retained<UIPresentationController>>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uipercentdriveninteractivetransition?language=objc)
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIPercentDrivenInteractiveTransition;
);

unsafe impl NSObjectProtocol for UIPercentDrivenInteractiveTransition {}

unsafe impl UIViewControllerInteractiveTransitioning for UIPercentDrivenInteractiveTransition {}

extern_methods!(
    unsafe impl UIPercentDrivenInteractiveTransition {
        #[cfg(feature = "objc2-core-foundation")]
        /// This is the non-interactive duration that was returned when the
        /// animators transitionDuration: method was called when the transition started.
        #[method(duration)]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// The last percentComplete value specified by updateInteractiveTransition:
        #[method(percentComplete)]
        #[unsafe(method_family = none)]
        pub unsafe fn percentComplete(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// completionSpeed defaults to 1.0 which corresponds to a completion duration of
        /// (1 - percentComplete)*duration.  It must be greater than 0.0. The actual
        /// completion is inversely proportional to the completionSpeed.  This can be set
        /// before cancelInteractiveTransition or finishInteractiveTransition is called
        /// in order to speed up or slow down the non interactive part of the
        /// transition.
        #[method(completionSpeed)]
        #[unsafe(method_family = none)]
        pub unsafe fn completionSpeed(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`completionSpeed`][Self::completionSpeed].
        #[method(setCompletionSpeed:)]
        #[unsafe(method_family = none)]
        pub unsafe fn setCompletionSpeed(&self, completion_speed: CGFloat);

        #[cfg(feature = "UIView")]
        /// When the interactive part of the transition has completed, this property can
        /// be set to indicate a different animation curve. It defaults to UIViewAnimationCurveEaseInOut.
        /// Note that during the interactive portion of the animation the timing curve is linear.
        #[method(completionCurve)]
        #[unsafe(method_family = none)]
        pub unsafe fn completionCurve(&self) -> UIViewAnimationCurve;

        #[cfg(feature = "UIView")]
        /// Setter for [`completionCurve`][Self::completionCurve].
        #[method(setCompletionCurve:)]
        #[unsafe(method_family = none)]
        pub unsafe fn setCompletionCurve(&self, completion_curve: UIViewAnimationCurve);

        #[cfg(feature = "UITimingCurveProvider")]
        /// For an interruptible animator, one can specify a different timing curve provider to use when the
        /// transition is continued. This property is ignored if the animated transitioning object does not
        /// vend an interruptible animator.
        #[method(timingCurve)]
        #[unsafe(method_family = none)]
        pub unsafe fn timingCurve(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UITimingCurveProvider>>>;

        #[cfg(feature = "UITimingCurveProvider")]
        /// Setter for [`timingCurve`][Self::timingCurve].
        #[method(setTimingCurve:)]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimingCurve(
            &self,
            timing_curve: Option<&ProtocolObject<dyn UITimingCurveProvider>>,
        );

        /// Set this to NO in order to start an interruptible transition non
        /// interactively. By default this is YES, which is consistent with the behavior
        /// before 10.0.
        #[method(wantsInteractiveStart)]
        #[unsafe(method_family = none)]
        pub unsafe fn wantsInteractiveStart(&self) -> bool;

        /// Setter for [`wantsInteractiveStart`][Self::wantsInteractiveStart].
        #[method(setWantsInteractiveStart:)]
        #[unsafe(method_family = none)]
        pub unsafe fn setWantsInteractiveStart(&self, wants_interactive_start: bool);

        /// Use this method to pause a running interruptible animator. This will ensure that all blocks
        /// provided by a transition coordinator's notifyWhenInteractionChangesUsingBlock: method
        /// are executed when a transition moves in and out of an interactive mode.
        #[method(pauseInteractiveTransition)]
        #[unsafe(method_family = none)]
        pub unsafe fn pauseInteractiveTransition(&self);

        #[cfg(feature = "objc2-core-foundation")]
        #[method(updateInteractiveTransition:)]
        #[unsafe(method_family = none)]
        pub unsafe fn updateInteractiveTransition(&self, percent_complete: CGFloat);

        #[method(cancelInteractiveTransition)]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelInteractiveTransition(&self);

        #[method(finishInteractiveTransition)]
        #[unsafe(method_family = none)]
        pub unsafe fn finishInteractiveTransition(&self);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl UIPercentDrivenInteractiveTransition {
        #[method(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);
