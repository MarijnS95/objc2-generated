//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhttpauthentication?language=objc)
#[repr(C)]
pub struct CFHTTPAuthentication {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "_CFHTTPAuthentication"]
    unsafe impl CFHTTPAuthentication {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfstreamerrorhttpauthentication?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFStreamErrorHTTPAuthentication(pub c_int);
impl CFStreamErrorHTTPAuthentication {
    #[doc(alias = "kCFStreamErrorHTTPAuthenticationTypeUnsupported")]
    pub const TypeUnsupported: Self = Self(-1000);
    #[doc(alias = "kCFStreamErrorHTTPAuthenticationBadUserName")]
    pub const BadUserName: Self = Self(-1001);
    #[doc(alias = "kCFStreamErrorHTTPAuthenticationBadPassword")]
    pub const BadPassword: Self = Self(-1002);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStreamErrorHTTPAuthentication {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStreamErrorHTTPAuthentication {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfhttpauthenticationusername?language=objc)
    pub static kCFHTTPAuthenticationUsername: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfhttpauthenticationpassword?language=objc)
    pub static kCFHTTPAuthenticationPassword: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfhttpauthenticationaccountdomain?language=objc)
    pub static kCFHTTPAuthenticationAccountDomain: &'static CFString;
}

unsafe impl ConcreteType for CFHTTPAuthentication {
    #[doc(alias = "CFHTTPAuthenticationGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFHTTPAuthenticationGetTypeID() -> CFTypeID;
        }
        unsafe { CFHTTPAuthenticationGetTypeID() }
    }
}

#[cfg(feature = "CFHTTPMessage")]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCreateFromResponse(
    alloc: Option<&CFAllocator>,
    response: &CFHTTPMessage,
) -> CFRetained<CFHTTPAuthentication> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCreateFromResponse(
            alloc: Option<&CFAllocator>,
            response: &CFHTTPMessage,
        ) -> Option<NonNull<CFHTTPAuthentication>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCreateFromResponse(alloc, response) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationIsValid(
    auth: &CFHTTPAuthentication,
    error: *mut CFStreamError,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationIsValid(
            auth: &CFHTTPAuthentication,
            error: *mut CFStreamError,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationIsValid(auth, error) };
    ret != 0
}

#[cfg(feature = "CFHTTPMessage")]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationAppliesToRequest(
    auth: &CFHTTPAuthentication,
    request: &CFHTTPMessage,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationAppliesToRequest(
            auth: &CFHTTPAuthentication,
            request: &CFHTTPMessage,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationAppliesToRequest(auth, request) };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationRequiresOrderedRequests(
    auth: &CFHTTPAuthentication,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationRequiresOrderedRequests(auth: &CFHTTPAuthentication) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationRequiresOrderedRequests(auth) };
    ret != 0
}

#[cfg(feature = "CFHTTPMessage")]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPMessageApplyCredentials(
    request: &CFHTTPMessage,
    auth: &CFHTTPAuthentication,
    username: Option<&CFString>,
    password: Option<&CFString>,
    error: *mut CFStreamError,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPMessageApplyCredentials(
            request: &CFHTTPMessage,
            auth: &CFHTTPAuthentication,
            username: Option<&CFString>,
            password: Option<&CFString>,
            error: *mut CFStreamError,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPMessageApplyCredentials(request, auth, username, password, error) };
    ret != 0
}

#[cfg(feature = "CFHTTPMessage")]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPMessageApplyCredentialDictionary(
    request: &CFHTTPMessage,
    auth: &CFHTTPAuthentication,
    dict: &CFDictionary,
    error: *mut CFStreamError,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPMessageApplyCredentialDictionary(
            request: &CFHTTPMessage,
            auth: &CFHTTPAuthentication,
            dict: &CFDictionary,
            error: *mut CFStreamError,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPMessageApplyCredentialDictionary(request, auth, dict, error) };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCopyRealm(
    auth: &CFHTTPAuthentication,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCopyRealm(auth: &CFHTTPAuthentication) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCopyRealm(auth) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCopyDomains(
    auth: &CFHTTPAuthentication,
) -> CFRetained<CFArray> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCopyDomains(auth: &CFHTTPAuthentication)
            -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCopyDomains(auth) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCopyMethod(
    auth: &CFHTTPAuthentication,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCopyMethod(auth: &CFHTTPAuthentication)
            -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCopyMethod(auth) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationRequiresUserNameAndPassword(
    auth: &CFHTTPAuthentication,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationRequiresUserNameAndPassword(auth: &CFHTTPAuthentication) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationRequiresUserNameAndPassword(auth) };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationRequiresAccountDomain(
    auth: &CFHTTPAuthentication,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationRequiresAccountDomain(auth: &CFHTTPAuthentication) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationRequiresAccountDomain(auth) };
    ret != 0
}
