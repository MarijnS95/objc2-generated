// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::unportable_markdown)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "IOKit", kind = "framework")]
extern "C" {}

#[cfg(feature = "usb")]
#[path = "usb/mod.rs"]
mod __usb;

#[cfg(feature = "usb")]
pub use self::__usb::*;
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiodefaultmemorytype?language=objc)
pub const kIODefaultMemoryType: c_uint = 0;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiodefaultcache?language=objc)
pub const kIODefaultCache: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioinhibitcache?language=objc)
pub const kIOInhibitCache: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiowritethrucache?language=objc)
pub const kIOWriteThruCache: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocopybackcache?language=objc)
pub const kIOCopybackCache: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiowritecombinecache?language=objc)
pub const kIOWriteCombineCache: c_uint = 4;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocopybackinnercache?language=objc)
pub const kIOCopybackInnerCache: c_uint = 5;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiopostedwrite?language=objc)
pub const kIOPostedWrite: c_uint = 6;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorealtimecache?language=objc)
pub const kIORealTimeCache: c_uint = 7;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiopostedreordered?language=objc)
pub const kIOPostedReordered: c_uint = 8;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiopostedcombinedreordered?language=objc)
pub const kIOPostedCombinedReordered: c_uint = 9;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapanywhere?language=objc)
pub const kIOMapAnywhere: c_uint = 0x00000001;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapcachemask?language=objc)
pub const kIOMapCacheMask: c_uint = 0x00000f00;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapcacheshift?language=objc)
pub const kIOMapCacheShift: c_uint = 8;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapdefaultcache?language=objc)
pub const kIOMapDefaultCache: c_uint = kIODefaultCache << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapinhibitcache?language=objc)
pub const kIOMapInhibitCache: c_uint = kIOInhibitCache << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapwritethrucache?language=objc)
pub const kIOMapWriteThruCache: c_uint = kIOWriteThruCache << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapcopybackcache?language=objc)
pub const kIOMapCopybackCache: c_uint = kIOCopybackCache << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapwritecombinecache?language=objc)
pub const kIOMapWriteCombineCache: c_uint = kIOWriteCombineCache << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapcopybackinnercache?language=objc)
pub const kIOMapCopybackInnerCache: c_uint = kIOCopybackInnerCache << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomappostedwrite?language=objc)
pub const kIOMapPostedWrite: c_uint = kIOPostedWrite << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaprealtimecache?language=objc)
pub const kIOMapRealTimeCache: c_uint = kIORealTimeCache << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomappostedreordered?language=objc)
pub const kIOMapPostedReordered: c_uint = kIOPostedReordered << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomappostedcombinedreordered?language=objc)
pub const kIOMapPostedCombinedReordered: c_uint = kIOPostedCombinedReordered << kIOMapCacheShift;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapuseroptionsmask?language=objc)
pub const kIOMapUserOptionsMask: c_uint = 0x00000fff;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapreadonly?language=objc)
pub const kIOMapReadOnly: c_uint = 0x00001000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapstatic?language=objc)
pub const kIOMapStatic: c_uint = 0x01000000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapreference?language=objc)
pub const kIOMapReference: c_uint = 0x02000000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapunique?language=objc)
pub const kIOMapUnique: c_uint = 0x04000000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapprefault?language=objc)
pub const kIOMapPrefault: c_uint = 0x10000000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapoverwrite?language=objc)
pub const kIOMapOverwrite: c_uint = 0x20000000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapguardedmask?language=objc)
pub const kIOMapGuardedMask: c_uint = 0xC0000000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapguardedsmall?language=objc)
pub const kIOMapGuardedSmall: c_uint = 0x40000000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomapguardedlarge?language=objc)
pub const kIOMapGuardedLarge: c_uint = 0x80000000;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iooptionbits?language=objc)
pub type IOOptionBits = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iofixed?language=objc)
pub type IOFixed = i32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ioversion?language=objc)
pub type IOVersion = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ioitemcount?language=objc)
pub type IOItemCount = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iocachemode?language=objc)
pub type IOCacheMode = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iobytecount32?language=objc)
pub type IOByteCount32 = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iobytecount64?language=objc)
pub type IOByteCount64 = u64;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iophysicaladdress32?language=objc)
pub type IOPhysicalAddress32 = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iophysicaladdress64?language=objc)
pub type IOPhysicalAddress64 = u64;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iophysicallength32?language=objc)
pub type IOPhysicalLength32 = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iophysicallength64?language=objc)
pub type IOPhysicalLength64 = u64;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iovirtualaddress?language=objc)
#[cfg(feature = "libc")]
pub type IOVirtualAddress = libc::mach_vm_address_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iobytecount?language=objc)
pub type IOByteCount = IOByteCount64;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iologicaladdress?language=objc)
#[cfg(feature = "libc")]
pub type IOLogicalAddress = IOVirtualAddress;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iophysicaladdress?language=objc)
pub type IOPhysicalAddress = IOPhysicalAddress64;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iophysicallength?language=objc)
pub type IOPhysicalLength = IOPhysicalLength64;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iophysicalrange?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOPhysicalRange {
    pub address: IOPhysicalAddress,
    pub length: IOByteCount,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOPhysicalRange {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[<IOPhysicalAddress>::ENCODING, <IOByteCount>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOPhysicalRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iovirtualrange?language=objc)
#[cfg(feature = "libc")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOVirtualRange {
    pub address: IOVirtualAddress,
    pub length: IOByteCount,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOVirtualRange {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[<IOVirtualAddress>::ENCODING, <IOByteCount>::ENCODING],
    );
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOVirtualRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ioaddressrange?language=objc)
#[cfg(feature = "libc")]
pub type IOAddressRange = IOVirtualRange;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ionamedvalue?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IONamedValue {
    pub value: c_int,
    pub name: *const c_char,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IONamedValue {
    const ENCODING: Encoding =
        Encoding::Struct("?", &[<c_int>::ENCODING, <*const c_char>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IONamedValue {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ioalignment?language=objc)
pub type IOAlignment = c_uint;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/io_object_t?language=objc)
#[cfg(feature = "libc")]
pub type io_object_t = libc::mach_port_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/io_connect_t?language=objc)
#[cfg(feature = "libc")]
pub type io_connect_t = io_object_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/io_enumerator_t?language=objc)
#[cfg(feature = "libc")]
pub type io_enumerator_t = io_object_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/io_ident_t?language=objc)
#[cfg(feature = "libc")]
pub type io_ident_t = io_object_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/io_iterator_t?language=objc)
#[cfg(feature = "libc")]
pub type io_iterator_t = io_object_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/io_registry_entry_t?language=objc)
#[cfg(feature = "libc")]
pub type io_registry_entry_t = io_object_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/io_service_t?language=objc)
#[cfg(feature = "libc")]
pub type io_service_t = io_object_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/uext_object_t?language=objc)
#[cfg(feature = "libc")]
pub type uext_object_t = io_object_t;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/knanosecondscale?language=objc)
pub const kNanosecondScale: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kmicrosecondscale?language=objc)
pub const kMicrosecondScale: c_uint = 1000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kmillisecondscale?language=objc)
pub const kMillisecondScale: c_uint = 1000 * 1000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ksecondscale?language=objc)
pub const kSecondScale: c_uint = 1000 * 1000 * 1000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ktickscale?language=objc)
pub const kTickScale: c_uint = kSecondScale / 100;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioconnectmethodvaroutputsize?language=objc)
pub const kIOConnectMethodVarOutputSize: c_int = -3;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iodevicenumber?language=objc)
pub type IODeviceNumber = c_uint;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaxbusstall40usec?language=objc)
pub const kIOMaxBusStall40usec: c_uint = 40000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaxbusstall30usec?language=objc)
pub const kIOMaxBusStall30usec: c_uint = 30000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaxbusstall25usec?language=objc)
pub const kIOMaxBusStall25usec: c_uint = 25000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaxbusstall20usec?language=objc)
pub const kIOMaxBusStall20usec: c_uint = 20000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaxbusstall10usec?language=objc)
pub const kIOMaxBusStall10usec: c_uint = 10000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaxbusstall5usec?language=objc)
pub const kIOMaxBusStall5usec: c_uint = 5000;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomaxbusstallnone?language=objc)
pub const kIOMaxBusStallNone: c_uint = 0;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiosystemstatesleepdescriptionhibernatestateinactive?language=objc)
pub const kIOSystemStateSleepDescriptionHibernateStateInactive: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiosystemstatesleepdescriptionhibernatestatehibernating?language=objc)
pub const kIOSystemStateSleepDescriptionHibernateStateHibernating: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiosystemstatesleepdescriptionhibernatestatewakingfromhibernate?language=objc)
pub const kIOSystemStateSleepDescriptionHibernateStateWakingFromHibernate: c_uint = 2;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kfirstiokitnotificationtype?language=objc)
pub const kFirstIOKitNotificationType: c_uint = 100;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioservicepublishnotificationtype?language=objc)
pub const kIOServicePublishNotificationType: c_uint = 100;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioservicematchednotificationtype?language=objc)
pub const kIOServiceMatchedNotificationType: c_uint = 101;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioserviceterminatednotificationtype?language=objc)
pub const kIOServiceTerminatedNotificationType: c_uint = 102;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioasynccompletionnotificationtype?language=objc)
pub const kIOAsyncCompletionNotificationType: c_uint = 150;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioservicemessagenotificationtype?language=objc)
pub const kIOServiceMessageNotificationType: c_uint = 160;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/klastiokitnotificationtype?language=objc)
pub const kLastIOKitNotificationType: c_uint = 199;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiokitnoticationtypemask?language=objc)
pub const kIOKitNoticationTypeMask: c_uint = 0x00000FFF;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiokitnoticationtypesizeadjshift?language=objc)
pub const kIOKitNoticationTypeSizeAdjShift: c_uint = 30;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiokitnoticationmsgsizemask?language=objc)
pub const kIOKitNoticationMsgSizeMask: c_uint = 3;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kosnotificationmessageid?language=objc)
pub const kOSNotificationMessageID: c_uint = 53;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kosasynccompletemessageid?language=objc)
pub const kOSAsyncCompleteMessageID: c_uint = 57;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kmaxasyncargs?language=objc)
pub const kMaxAsyncArgs: c_uint = 16;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioasyncreservedindex?language=objc)
pub const kIOAsyncReservedIndex: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioasyncreservedcount?language=objc)
pub const kIOAsyncReservedCount: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioasynccalloutfuncindex?language=objc)
pub const kIOAsyncCalloutFuncIndex: c_uint = kIOAsyncReservedCount;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioasynccalloutrefconindex?language=objc)
pub const kIOAsyncCalloutRefconIndex: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioasynccalloutcount?language=objc)
pub const kIOAsyncCalloutCount: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomatchingcalloutfuncindex?language=objc)
pub const kIOMatchingCalloutFuncIndex: c_uint = kIOAsyncReservedCount;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomatchingcalloutrefconindex?language=objc)
pub const kIOMatchingCalloutRefconIndex: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomatchingcalloutcount?language=objc)
pub const kIOMatchingCalloutCount: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiointerestcalloutfuncindex?language=objc)
pub const kIOInterestCalloutFuncIndex: c_uint = kIOAsyncReservedCount;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiointerestcalloutrefconindex?language=objc)
pub const kIOInterestCalloutRefconIndex: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiointerestcalloutserviceindex?language=objc)
pub const kIOInterestCalloutServiceIndex: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiointerestcalloutcount?language=objc)
pub const kIOInterestCalloutCount: c_uint = 4;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kosasyncrefcount?language=objc)
pub const kOSAsyncRefCount: c_uint = 8;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kosasyncrefsize?language=objc)
pub const kOSAsyncRefSize: c_uint = 32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ioserviceinterestcontent?language=objc)
#[cfg(feature = "libc")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOServiceInterestContent {
    pub messageType: libc::natural_t,
    pub messageArgument: [*mut c_void; 1],
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOServiceInterestContent {
    const ENCODING: Encoding = Encoding::Struct(
        "IOServiceInterestContent",
        &[<libc::natural_t>::ENCODING, <[*mut c_void; 1]>::ENCODING],
    );
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOServiceInterestContent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ioasynccompletioncontent?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOAsyncCompletionContent {
    pub result: IOReturn,
    pub args: *mut *mut c_void,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOAsyncCompletionContent {
    const ENCODING: Encoding = Encoding::Struct(
        "IOAsyncCompletionContent",
        &[<IOReturn>::ENCODING, <*mut *mut c_void>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOAsyncCompletionContent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/ionotificationport?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct IONotificationPort {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IONotificationPort {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("IONotificationPort", &[]));
}

/// IOKitLib
/// IOKitLib implements non-kernel task access to common IOKit object types - IORegistryEntry, IOService, IOIterator etc. These functions are generic - families may provide API that is more specific.
/// <br>
/// IOKitLib represents IOKit objects outside the kernel with the types io_object_t, io_registry_entry_t, io_service_t,
/// &
/// io_connect_t. Function names usually begin with the type of object they are compatible with - eg. IOObjectRelease can be used with any io_object_t. Inside the kernel, the c++ class hierarchy allows the subclasses of each object type to receive the same requests from user level clients, for example in the kernel, IOService is a subclass of IORegistryEntry, which means any of the IORegistryEntryXXX functions in IOKitLib may be used with io_service_t's as well as io_registry_t's. There are functions available to introspect the class of the kernel object which any io_object_t et al. represents.
/// IOKit objects returned by all functions should be released with IOObjectRelease.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/ionotificationportref?language=objc)
pub type IONotificationPortRef = *mut IONotificationPort;

/// Callback function to be notified of IOService publication.
///
/// Parameter `refcon`: The refcon passed when the notification was installed.
///
/// Parameter `iterator`: The notification iterator which now has new objects.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/ioservicematchingcallback?language=objc)
#[cfg(feature = "libc")]
pub type IOServiceMatchingCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, io_iterator_t)>;

/// Callback function to be notified of changes in state of an IOService.
///
/// Parameter `refcon`: The refcon passed when the notification was installed.
///
/// Parameter `service`: The IOService whose state has changed.
///
/// Parameter `messageType`: A messageType enum, defined by IOKit/IOMessage.h or by the IOService's family.
///
/// Parameter `messageArgument`: An argument for the message, dependent on the messageType.  If the message data is larger than sizeof(void*), then messageArgument contains a pointer to the message data; otherwise, messageArgument contains the message data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/ioserviceinterestcallback?language=objc)
#[cfg(feature = "libc")]
pub type IOServiceInterestCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, io_service_t, u32, *mut c_void)>;

extern "C" {
    /// The default mach port used to initiate communication with IOKit.
    ///
    /// When specifying a main port to IOKit functions, the NULL argument indicates "use the default". This is a synonym for NULL, if you'd rather use a named constant.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomainportdefault?language=objc)
    #[cfg(feature = "libc")]
    pub static kIOMainPortDefault: libc::mach_port_t;
}

extern "C-unwind" {
    /// Returns the mach port used to initiate communication with IOKit.
    ///
    /// Functions that don't specify an existing object require the IOKit main port to be passed. This function obtains that port.
    ///
    /// Parameter `bootstrapPort`: Pass MACH_PORT_NULL for the default.
    ///
    /// Parameter `mainPort`: The main port is returned.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOMainPort(
        bootstrap_port: libc::mach_port_t,
        main_port: *mut libc::mach_port_t,
    ) -> libc::kern_return_t;
}

extern "C" {
    /// Deprecated name for kIOMainPortDefault.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/kiomasterportdefault?language=objc)
    #[cfg(feature = "libc")]
    pub static kIOMasterPortDefault: libc::mach_port_t;
}

extern "C-unwind" {
    /// Deprecated name for IOMainPort().
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOMasterPort(
        bootstrap_port: libc::mach_port_t,
        main_port: *mut libc::mach_port_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Creates and returns a notification object for receiving IOKit notifications of new devices or state changes.
    ///
    /// Creates the notification object to receive notifications from IOKit of new device arrivals or state changes. The notification object can be supply a CFRunLoopSource, or mach_port_t to be used to listen for events.
    ///
    /// Parameter `mainPort`: The main port obtained from IOMainPort(). Pass kIOMainPortDefault to look up the default main port.
    ///
    /// Returns: A reference to the notification object.
    #[cfg(feature = "libc")]
    pub fn IONotificationPortCreate(main_port: libc::mach_port_t) -> IONotificationPortRef;
}

extern "C-unwind" {
    /// Destroys a notification object created with IONotificationPortCreate.
    /// Also destroys any mach_port's or CFRunLoopSources obtained from
    /// <code>
    ///
    /// ```text
    ///  IONotificationPortGetRunLoopSource
    /// ```
    ///
    /// </code>
    /// or
    /// <code>
    ///
    /// ```text
    ///  IONotificationPortGetMachPort
    /// ```
    ///
    /// </code>
    ///
    /// Parameter `notify`: A reference to the notification object.
    pub fn IONotificationPortDestroy(notify: IONotificationPortRef);
}

/// Returns a CFRunLoopSource to be used to listen for notifications.
///
/// A notification object may deliver notifications to a CFRunLoop
/// by adding the run loop source returned by this function to the run loop.
///
/// The caller should not release this CFRunLoopSource. Just call
/// <code>
///
/// ```text
///  IONotificationPortDestroy
/// ```
///
/// </code>
/// to dispose of the
/// IONotificationPortRef and the CFRunLoopSource when done.
///
/// Parameter `notify`: The notification object.
///
/// Returns: A CFRunLoopSourceRef for the notification object.
#[inline]
pub unsafe extern "C-unwind" fn IONotificationPortGetRunLoopSource(
    notify: IONotificationPortRef,
) -> Option<CFRetained<CFRunLoopSource>> {
    extern "C-unwind" {
        fn IONotificationPortGetRunLoopSource(
            notify: IONotificationPortRef,
        ) -> Option<NonNull<CFRunLoopSource>>;
    }
    let ret = unsafe { IONotificationPortGetRunLoopSource(notify) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    /// Returns a mach_port to be used to listen for notifications.
    ///
    /// A notification object may deliver notifications to a mach messaging client
    /// if they listen for messages on the port obtained from this function.
    /// Callbacks associated with the notifications may be delivered by calling
    /// IODispatchCalloutFromMessage with messages received.
    ///
    /// The caller should not release this mach_port_t. Just call
    /// <code>
    ///
    /// ```text
    ///  IONotificationPortDestroy
    /// ```
    ///
    /// </code>
    /// to dispose of the
    /// mach_port_t and IONotificationPortRef when done.
    ///
    /// Parameter `notify`: The notification object.
    ///
    /// Returns: A mach_port for the notification object.
    #[cfg(feature = "libc")]
    pub fn IONotificationPortGetMachPort(notify: IONotificationPortRef) -> libc::mach_port_t;
}

extern "C-unwind" {
    /// Configure a notification port to be an importance receiver.
    ///
    /// Sets the MACH_PORT_IMPORTANCE_RECEIVER attribute on the underlying mach port.
    /// Importance-donating messages sent to a notification port with this
    /// attribute enabled will boost the importance of the receiving process for the
    /// duration of the notification handler.
    ///
    /// Parameter `notify`: The notification object.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IONotificationPortSetImportanceReceiver(
        notify: IONotificationPortRef,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Creates and returns a mach port suitable for receiving IOKit messages of the specified type.
    ///
    /// In the future IOKit may use specialized messages and ports
    /// instead of the standard ports created by mach_port_allocate(). Use this
    /// function instead of mach_port_allocate() to ensure compatibility with future
    /// revisions of IOKit.
    ///
    /// Parameter `msgType`: Type of message to be sent to this port
    /// (kOSNotificationMessageID or kOSAsyncCompleteMessageID)
    ///
    /// Parameter `recvPort`: The created port is returned.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOCreateReceivePort(
        msg_type: u32,
        recv_port: *mut libc::mach_port_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Releases an object handle previously returned by IOKitLib.
    ///
    /// All objects returned by IOKitLib should be released with this function when access to them is no longer needed. Using the object after it has been released may or may not return an error, depending on how many references the task has to the same object in the kernel.
    ///
    /// Parameter `object`: The IOKit object to release.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOObjectRelease(object: io_object_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Retains an object handle previously returned by IOKitLib.
    ///
    /// Gives the caller an additional reference to an existing object handle previously returned by IOKitLib.
    ///
    /// Parameter `object`: The IOKit object to retain.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOObjectRetain(object: io_object_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Return the class name of an IOKit object.
    ///
    /// This function uses the OSMetaClass system in the kernel to derive the name of the class the object is an instance of.
    ///
    /// Parameter `object`: The IOKit object.
    ///
    /// Parameter `className`: Caller allocated buffer to receive the name string.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOObjectGetClass(object: io_object_t, class_name: io_name_t) -> libc::kern_return_t;
}

/// Return the class name of an IOKit object.
///
/// This function does the same thing as IOObjectGetClass, but returns the result as a CFStringRef.
///
/// Parameter `object`: The IOKit object.
///
/// Returns: The resulting CFStringRef. This should be released by the caller. If a valid object is not passed in, then NULL is returned.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IOObjectCopyClass(
    object: io_object_t,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn IOObjectCopyClass(object: io_object_t) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { IOObjectCopyClass(object) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Return the superclass name of the given class.
///
/// This function uses the OSMetaClass system in the kernel to derive the name of the superclass of the class.
///
/// Parameter `classname`: The name of the class as a CFString.
///
/// Returns: The resulting CFStringRef. This should be released by the caller. If there is no superclass, or a valid class name is not passed in, then NULL is returned.
#[inline]
pub unsafe extern "C-unwind" fn IOObjectCopySuperclassForClass(
    classname: Option<&CFString>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn IOObjectCopySuperclassForClass(
            classname: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { IOObjectCopySuperclassForClass(classname) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Return the bundle identifier of the given class.
///
/// This function uses the OSMetaClass system in the kernel to derive the name of the kmod, which is the same as the bundle identifier.
///
/// Parameter `classname`: The name of the class as a CFString.
///
/// Returns: The resulting CFStringRef. This should be released by the caller. If a valid class name is not passed in, then NULL is returned.
#[inline]
pub unsafe extern "C-unwind" fn IOObjectCopyBundleIdentifierForClass(
    classname: Option<&CFString>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn IOObjectCopyBundleIdentifierForClass(
            classname: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { IOObjectCopyBundleIdentifierForClass(classname) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Performs an OSDynamicCast operation on an IOKit object.
///
/// This function uses the OSMetaClass system in the kernel to determine if the object will dynamic cast to a class, specified as a C-string. In other words, if the object is of that class or a subclass.
///
/// Parameter `object`: An IOKit object.
///
/// Parameter `className`: The name of the class, as a C-string.
///
/// Returns: If the object handle is valid, and represents an object in the kernel that dynamic casts to the class true is returned, otherwise false.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IOObjectConformsTo(
    object: io_object_t,
    class_name: io_name_t,
) -> bool {
    extern "C-unwind" {
        fn IOObjectConformsTo(object: io_object_t, class_name: io_name_t) -> libc::boolean_t;
    }
    let ret = unsafe { IOObjectConformsTo(object, class_name) };
    ret != 0
}

/// Checks two object handles to see if they represent the same kernel object.
///
/// If two object handles are returned by IOKitLib functions, this function will compare them to see if they represent the same kernel object.
///
/// Parameter `object`: An IOKit object.
///
/// Parameter `anObject`: Another IOKit object.
///
/// Returns: If both object handles are valid, and represent the same object in the kernel true is returned, otherwise false.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IOObjectIsEqualTo(
    object: io_object_t,
    an_object: io_object_t,
) -> bool {
    extern "C-unwind" {
        fn IOObjectIsEqualTo(object: io_object_t, an_object: io_object_t) -> libc::boolean_t;
    }
    let ret = unsafe { IOObjectIsEqualTo(object, an_object) };
    ret != 0
}

extern "C-unwind" {
    /// Returns kernel retain count of an IOKit object.
    ///
    /// This function may be used in diagnostics to determine the current retain count of the kernel object at the kernel level.
    ///
    /// Parameter `object`: An IOKit object.
    ///
    /// Returns: If the object handle is valid, the kernel objects retain count is returned, otherwise zero is returned.
    #[cfg(feature = "libc")]
    pub fn IOObjectGetKernelRetainCount(object: io_object_t) -> u32;
}

extern "C-unwind" {
    /// Returns the retain count for the current process of an IOKit object.
    ///
    /// This function may be used in diagnostics to determine the current retain count for the calling process of the kernel object.
    ///
    /// Parameter `object`: An IOKit object.
    ///
    /// Returns: If the object handle is valid, the objects user retain count is returned, otherwise zero is returned.
    #[cfg(feature = "libc")]
    pub fn IOObjectGetUserRetainCount(object: io_object_t) -> u32;
}

extern "C-unwind" {
    /// Returns kernel retain count of an IOKit object. Identical to IOObjectGetKernelRetainCount() but available prior to Mac OS 10.6.
    ///
    /// This function may be used in diagnostics to determine the current retain count of the kernel object at the kernel level.
    ///
    /// Parameter `object`: An IOKit object.
    ///
    /// Returns: If the object handle is valid, the kernel objects retain count is returned, otherwise zero is returned.
    #[cfg(feature = "libc")]
    pub fn IOObjectGetRetainCount(object: io_object_t) -> u32;
}

extern "C-unwind" {
    /// Returns the next object in an iteration.
    ///
    /// This function returns the next object in an iteration, or zero if no more remain or the iterator is invalid.
    ///
    /// Parameter `iterator`: An IOKit iterator handle.
    ///
    /// Returns: If the iterator handle is valid, the next element in the iteration is returned, otherwise zero is returned. The element should be released by the caller when it is finished.
    #[cfg(feature = "libc")]
    pub fn IOIteratorNext(iterator: io_iterator_t) -> io_object_t;
}

extern "C-unwind" {
    /// Resets an iteration back to the beginning.
    ///
    /// If an iterator is invalid, or if the caller wants to start over, IOIteratorReset will set the iteration back to the beginning.
    ///
    /// Parameter `iterator`: An IOKit iterator handle.
    #[cfg(feature = "libc")]
    pub fn IOIteratorReset(iterator: io_iterator_t);
}

/// Checks an iterator is still valid.
///
/// Some iterators will be made invalid if changes are made to the structure they are iterating over. This function checks the iterator is still valid and should be called when IOIteratorNext returns zero. An invalid iterator can be reset and the iteration restarted.
///
/// Parameter `iterator`: An IOKit iterator handle.
///
/// Returns: True if the iterator handle is valid, otherwise false is returned.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IOIteratorIsValid(iterator: io_iterator_t) -> bool {
    extern "C-unwind" {
        fn IOIteratorIsValid(iterator: io_iterator_t) -> libc::boolean_t;
    }
    let ret = unsafe { IOIteratorIsValid(iterator) };
    ret != 0
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOServiceAddNotification(
        main_port: libc::mach_port_t,
        notification_type: io_name_t,
        matching: Option<&CFDictionary>,
        wake_port: libc::mach_port_t,
        reference: usize,
        notification: *mut io_iterator_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Register for notification of state changes in an IOService.
    ///
    /// IOService objects deliver notifications of their state changes to their clients via the IOService::messageClients API, and to other interested parties including callers of this function. Message types are defined IOKit/IOMessage.h.
    ///
    /// Parameter `notifyPort`: A IONotificationPortRef object that controls how messages will be sent when the notification is fired. See IONotificationPortCreate.
    ///
    /// Parameter `interestType`: A notification type from IOKitKeys.h
    /// <br>
    /// kIOGeneralInterest General state changes delivered via the IOService::messageClients API.
    /// <br>
    /// kIOBusyInterest Delivered when the IOService changes its busy state to or from zero. The message argument contains the new busy state causing the notification.
    ///
    /// Parameter `callback`: A callback function called when the notification fires, with messageType and messageArgument for the state change.
    ///
    /// Parameter `refCon`: A reference constant for the callbacks use.
    ///
    /// Parameter `notification`: An object handle is returned on success, and should be released by the caller when the notification is to be destroyed.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOServiceAddInterestNotification(
        notify_port: IONotificationPortRef,
        service: io_service_t,
        interest_type: io_name_t,
        callback: IOServiceInterestCallback,
        ref_con: *mut c_void,
        notification: *mut io_object_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Match an IOService objects with matching dictionary.
    ///
    /// This function calls the matching method of an IOService object and returns the boolean result.
    ///
    /// Parameter `service`: The IOService object to match.
    ///
    /// Parameter `matching`: A CF dictionary containing matching information. IOKitLib can construct matching dictionaries for common criteria with helper functions such as IOServiceMatching, IOServiceNameMatching, IOBSDNameMatching.
    ///
    /// Parameter `matches`: The boolean result is returned.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOServiceMatchPropertyTable(
        service: io_service_t,
        matching: Option<&CFDictionary>,
        matches: *mut libc::boolean_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns the busyState of an IOService.
    ///
    /// Many activities in IOService are asynchronous. When registration, matching, or termination is in progress on an IOService, its busyState is increased by one. Change in busyState to or from zero also changes the IOService's provider's busyState by one, which means that an IOService is marked busy when any of the above activities is occurring on it or any of its clients.
    ///
    /// Parameter `service`: The IOService whose busyState to return.
    ///
    /// Parameter `busyState`: The busyState count is returned.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOServiceGetBusyState(
        service: io_service_t,
        busy_state: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns the busyState of all IOServices.
    ///
    /// Many activities in IOService are asynchronous. When registration, matching, or termination is in progress on an IOService, its busyState is increased by one. Change in busyState to or from zero also changes the IOService's provider's busyState by one, which means that an IOService is marked busy when any of the above activities is occurring on it or any of its clients. IOKitGetBusyState returns the busy state of the root of the service plane which reflects the busy state of all IOServices.
    ///
    /// Parameter `mainPort`: The main port obtained from IOMainPort(). Pass kIOMainPortDefault to look up the default main port.
    ///
    /// Parameter `busyState`: The busyState count is returned.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOKitGetBusyState(
        main_port: libc::mach_port_t,
        busy_state: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// A request to rescan a bus for device changes.
    ///
    /// A non kernel client may request a bus or controller rescan for added or removed devices, if the bus family does automatically notice such changes. For example, SCSI bus controllers do not notice device changes. The implementation of this routine is family dependent, and the default IOService implementation returns kIOReturnUnsupported.
    ///
    /// Parameter `service`: The IOService object to request a rescan, usually obtained via the IOServiceGetMatchingServices or IOServiceAddNotification APIs.
    ///
    /// Parameter `options`: An options mask, interpreted only by the IOService's family.
    ///
    /// Returns: A return code generated by IOService::requestProbe.
    #[cfg(feature = "libc")]
    pub fn IOServiceRequestProbe(service: io_service_t, options: u32) -> libc::kern_return_t;
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioserviceinteractionallowed?language=objc)
pub const kIOServiceInteractionAllowed: c_uint = 0x00000001;

extern "C-unwind" {
    /// Authorize access to an IOService.
    ///
    /// Determine whether this application is authorized to invoke IOServiceOpen() for a given IOService, either by confirming that it has been previously authorized by the user, or by soliciting the console user.
    ///
    /// Parameter `service`: The IOService object to be authorized, usually obtained via the IOServiceGetMatchingServices or IOServiceAddNotification APIs.
    ///
    /// Parameter `options`: kIOServiceInteractionAllowed may be set to permit user interaction, if required.
    ///
    /// Returns: kIOReturnSuccess if the IOService is authorized, kIOReturnNotPermitted if the IOService is not authorized.
    #[cfg(feature = "libc")]
    pub fn IOServiceAuthorize(service: io_service_t, options: u32) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOServiceOpenAsFileDescriptor(service: io_service_t, oflag: c_int) -> c_int;
}

extern "C-unwind" {
    /// Close a connection to an IOService and destroy the connect handle.
    ///
    /// A connection created with the IOServiceOpen should be closed when the connection is no longer to be used with IOServiceClose.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen. It will be destroyed by this function, and should not be released with IOObjectRelease.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOServiceClose(connect: io_connect_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Adds a reference to the connect handle.
    ///
    /// Adds a reference to the connect handle.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOConnectAddRef(connect: io_connect_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Remove a reference to the connect handle.
    ///
    /// Removes a reference to the connect handle.  If the last reference is removed an implicit IOServiceClose is performed.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOConnectRelease(connect: io_connect_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns the IOService a connect handle was opened on.
    ///
    /// Finds the service object a connection was opened on.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen.
    ///
    /// Parameter `service`: On success, the service handle the connection was opened on, which should be released with IOObjectRelease.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOConnectGetService(
        connect: io_connect_t,
        service: *mut io_service_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Set a port to receive family specific notifications.
    ///
    /// This is a generic method to pass a mach port send right to be be used by family specific notifications.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen.
    ///
    /// Parameter `type`: The type of notification requested, not interpreted by IOKit and family defined.
    ///
    /// Parameter `port`: The port to which to send notifications.
    ///
    /// Parameter `reference`: Some families may support passing a reference parameter for the callers use with the notification.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IOConnectSetNotificationPort(
        connect: io_connect_t,
        r#type: u32,
        port: libc::mach_port_t,
        reference: usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Set CF container based properties on a connection.
    ///
    /// This is a generic method to pass a CF container of properties to the connection. The properties are interpreted by the family and commonly represent configuration settings, but may be interpreted as anything.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen.
    ///
    /// Parameter `properties`: A CF container - commonly a CFDictionary but this is not enforced. The container should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    ///
    /// Returns: A kern_return_t error code returned by the family.
    #[cfg(feature = "libc")]
    pub fn IOConnectSetCFProperties(
        connect: io_connect_t,
        properties: Option<&CFType>,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Set a CF container based property on a connection.
    ///
    /// This is a generic method to pass a CF property to the connection. The property is interpreted by the family and commonly represent configuration settings, but may be interpreted as anything.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen.
    ///
    /// Parameter `propertyName`: The name of the property as a CFString.
    ///
    /// Parameter `property`: A CF container - should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    ///
    /// Returns: A kern_return_t error code returned by the object.
    #[cfg(feature = "libc")]
    pub fn IOConnectSetCFProperty(
        connect: io_connect_t,
        property_name: Option<&CFString>,
        property: Option<&CFType>,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectCallMethod(
        connection: libc::mach_port_t,
        selector: u32,
        input: *const u64,
        input_cnt: u32,
        input_struct: *const c_void,
        input_struct_cnt: usize,
        output: *mut u64,
        output_cnt: *mut u32,
        output_struct: *mut c_void,
        output_struct_cnt: *mut usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectCallAsyncMethod(
        connection: libc::mach_port_t,
        selector: u32,
        wake_port: libc::mach_port_t,
        reference: *mut u64,
        reference_cnt: u32,
        input: *const u64,
        input_cnt: u32,
        input_struct: *const c_void,
        input_struct_cnt: usize,
        output: *mut u64,
        output_cnt: *mut u32,
        output_struct: *mut c_void,
        output_struct_cnt: *mut usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectCallStructMethod(
        connection: libc::mach_port_t,
        selector: u32,
        input_struct: *const c_void,
        input_struct_cnt: usize,
        output_struct: *mut c_void,
        output_struct_cnt: *mut usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectCallAsyncStructMethod(
        connection: libc::mach_port_t,
        selector: u32,
        wake_port: libc::mach_port_t,
        reference: *mut u64,
        reference_cnt: u32,
        input_struct: *const c_void,
        input_struct_cnt: usize,
        output_struct: *mut c_void,
        output_struct_cnt: *mut usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectCallScalarMethod(
        connection: libc::mach_port_t,
        selector: u32,
        input: *const u64,
        input_cnt: u32,
        output: *mut u64,
        output_cnt: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectCallAsyncScalarMethod(
        connection: libc::mach_port_t,
        selector: u32,
        wake_port: libc::mach_port_t,
        reference: *mut u64,
        reference_cnt: u32,
        input: *const u64,
        input_cnt: u32,
        output: *mut u64,
        output_cnt: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectTrap0(connect: io_connect_t, index: u32) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectTrap1(connect: io_connect_t, index: u32, p1: usize) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectTrap2(
        connect: io_connect_t,
        index: u32,
        p1: usize,
        p2: usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectTrap3(
        connect: io_connect_t,
        index: u32,
        p1: usize,
        p2: usize,
        p3: usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectTrap4(
        connect: io_connect_t,
        index: u32,
        p1: usize,
        p2: usize,
        p3: usize,
        p4: usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectTrap5(
        connect: io_connect_t,
        index: u32,
        p1: usize,
        p2: usize,
        p3: usize,
        p4: usize,
        p5: usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOConnectTrap6(
        connect: io_connect_t,
        index: u32,
        p1: usize,
        p2: usize,
        p3: usize,
        p4: usize,
        p5: usize,
        p6: usize,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Inform a connection of a second connection.
    ///
    /// This is a generic method to inform a family connection of a second connection, and is rarely used.
    ///
    /// Parameter `connect`: The connect handle created by IOServiceOpen.
    ///
    /// Parameter `client`: Another connect handle created by IOServiceOpen.
    ///
    /// Returns: A kern_return_t error code returned by the family.
    #[cfg(feature = "libc")]
    pub fn IOConnectAddClient(connect: io_connect_t, client: io_connect_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Return a handle to the registry root.
    ///
    /// This method provides an accessor to the root of the registry for the machine. The root may be passed to a registry iterator when iterating a plane, and contains properties that describe the available planes, and diagnostic information for IOKit.
    ///
    /// Parameter `mainPort`: The main port obtained from IOMainPort(). Pass kIOMainPortDefault to look up the default main port.
    ///
    /// Returns: A handle to the IORegistryEntry root instance, to be released with IOObjectRelease by the caller, or MACH_PORT_NULL on failure.
    #[cfg(feature = "libc")]
    pub fn IORegistryGetRootEntry(main_port: libc::mach_port_t) -> io_registry_entry_t;
}

extern "C-unwind" {
    /// Looks up a registry entry by path.
    ///
    /// This function parses paths to lookup registry entries. The path should begin with '
    /// <plane
    /// name>:' If there are characters remaining unparsed after an entry has been looked up, this is considered an invalid lookup. Paths are further documented in IORegistryEntry.h
    ///
    /// Parameter `mainPort`: The main port obtained from IOMainPort(). Pass kIOMainPortDefault to look up the default main port.
    ///
    /// Parameter `path`: A C-string path.
    ///
    /// Returns: A handle to the IORegistryEntry which was found with the path, to be released with IOObjectRelease by the caller, or MACH_PORT_NULL on failure.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryFromPath(
        main_port: libc::mach_port_t,
        path: io_string_t,
    ) -> io_registry_entry_t;
}

extern "C-unwind" {
    /// Looks up a registry entry by path.
    ///
    /// This function parses paths to lookup registry entries. The path should begin with '
    /// <plane
    /// name>:' If there are characters remaining unparsed after an entry has been looked up, this is considered an invalid lookup. Paths are further documented in IORegistryEntry.h
    ///
    /// Parameter `mainPort`: The main port obtained from IOMainPort(). Pass kIOMainPortDefault to look up the default main port.
    ///
    /// Parameter `path`: A CFString path.
    ///
    /// Returns: A handle to the IORegistryEntry which was found with the path, to be released with IOObjectRelease by the caller, or MACH_PORT_NULL on failure.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryCopyFromPath(
        main_port: libc::mach_port_t,
        path: Option<&CFString>,
    ) -> io_registry_entry_t;
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioregistryiteraterecursively?language=objc)
pub const kIORegistryIterateRecursively: c_uint = 0x00000001;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kioregistryiterateparents?language=objc)
pub const kIORegistryIterateParents: c_uint = 0x00000002;

extern "C-unwind" {
    /// Create an iterator rooted at the registry root.
    ///
    /// This method creates an IORegistryIterator in the kernel that is set up with options to iterate children of the registry root entry, and to recurse automatically into entries as they are returned, or only when instructed with calls to IORegistryIteratorEnterEntry. The iterator object keeps track of entries that have been recursed into previously to avoid loops.
    ///
    /// Parameter `mainPort`: The main port obtained from IOMainPort(). Pass kIOMainPortDefault to look up the default main port.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `options`: kIORegistryIterateRecursively may be set to recurse automatically into each entry as it is returned from IOIteratorNext calls on the registry iterator.
    ///
    /// Parameter `iterator`: A created iterator handle, to be released by the caller when it has finished with it.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryCreateIterator(
        main_port: libc::mach_port_t,
        plane: io_name_t,
        options: IOOptionBits,
        iterator: *mut io_iterator_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Create an iterator rooted at a given registry entry.
    ///
    /// This method creates an IORegistryIterator in the kernel that is set up with options to iterate children or parents of a root entry, and to recurse automatically into entries as they are returned, or only when instructed with calls to IORegistryIteratorEnterEntry. The iterator object keeps track of entries that have been recursed into previously to avoid loops.
    ///
    /// Parameter `entry`: The root entry to begin the iteration at.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `options`: kIORegistryIterateRecursively may be set to recurse automatically into each entry as it is returned from IOIteratorNext calls on the registry iterator. kIORegistryIterateParents may be set to iterate the parents of each entry, by default the children are iterated.
    ///
    /// Parameter `iterator`: A created iterator handle, to be released by the caller when it has finished with it.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryCreateIterator(
        entry: io_registry_entry_t,
        plane: io_name_t,
        options: IOOptionBits,
        iterator: *mut io_iterator_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Recurse into the current entry in the registry iteration.
    ///
    /// This method makes the current entry, ie. the last entry returned by IOIteratorNext, the root in a new level of recursion.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryIteratorEnterEntry(iterator: io_iterator_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Exits a level of recursion, restoring the current entry.
    ///
    /// This method undoes an IORegistryIteratorEnterEntry, restoring the current entry. If there are no more levels of recursion to exit false is returned, otherwise true is returned.
    ///
    /// Returns: kIOReturnSuccess if a level of recursion was undone, kIOReturnNoDevice if no recursive levels are left in the iteration.
    #[cfg(feature = "libc")]
    pub fn IORegistryIteratorExitEntry(iterator: io_iterator_t) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns a C-string name assigned to a registry entry.
    ///
    /// Registry entries can be named in a particular plane, or globally. This function returns the entry's global name. The global name defaults to the entry's meta class name if it has not been named.
    ///
    /// Parameter `entry`: The registry entry handle whose name to look up.
    ///
    /// Parameter `name`: The caller's buffer to receive the name.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetName(
        entry: io_registry_entry_t,
        name: io_name_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns a C-string name assigned to a registry entry, in a specified plane.
    ///
    /// Registry entries can be named in a particular plane, or globally. This function returns the entry's name in the specified plane or global name if it has not been named in that plane. The global name defaults to the entry's meta class name if it has not been named.
    ///
    /// Parameter `entry`: The registry entry handle whose name to look up.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `name`: The caller's buffer to receive the name.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetNameInPlane(
        entry: io_registry_entry_t,
        plane: io_name_t,
        name: io_name_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns a C-string location assigned to a registry entry, in a specified plane.
    ///
    /// Registry entries can given a location string in a particular plane, or globally. If the entry has had a location set in the specified plane that location string will be returned, otherwise the global location string is returned. If no global location string has been set, an error is returned.
    ///
    /// Parameter `entry`: The registry entry handle whose name to look up.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `location`: The caller's buffer to receive the location string.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetLocationInPlane(
        entry: io_registry_entry_t,
        plane: io_name_t,
        location: io_name_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Create a path for a registry entry.
    ///
    /// The path for a registry entry is copied to the caller's buffer. The path describes the entry's attachment in a particular plane, which must be specified. The path begins with the plane name followed by a colon, and then followed by '/' separated path components for each of the entries between the root and the registry entry. An alias may also exist for the entry, and will be returned if available.
    ///
    /// Parameter `entry`: The registry entry handle whose path to look up.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `path`: A char buffer allocated by the caller.
    ///
    /// Returns: IORegistryEntryGetPath will fail if the entry is not attached in the plane, or if the buffer is not large enough to contain the path.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetPath(
        entry: io_registry_entry_t,
        plane: io_name_t,
        path: io_string_t,
    ) -> libc::kern_return_t;
}

/// Create a path for a registry entry.
///
/// The path for a registry entry is returned as a CFString The path describes the entry's attachment in a particular plane, which must be specified. The path begins with the plane name followed by a colon, and then followed by '/' separated path components for each of the entries between the root and the registry entry. An alias may also exist for the entry, and will be returned if available.
///
/// Parameter `entry`: The registry entry handle whose path to look up.
///
/// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
///
/// Returns: An instance of CFString on success, to be released by the caller. IORegistryEntryCopyPath will fail if the entry is not attached in the plane.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IORegistryEntryCopyPath(
    entry: io_registry_entry_t,
    plane: io_name_t,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn IORegistryEntryCopyPath(
            entry: io_registry_entry_t,
            plane: io_name_t,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { IORegistryEntryCopyPath(entry, plane) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Returns an ID for the registry entry that is global to all tasks.
    ///
    /// The entry ID returned by IORegistryEntryGetRegistryEntryID can be used to identify a registry entry across all tasks. A registry entry may be looked up by its entryID by creating a matching dictionary with IORegistryEntryIDMatching() to be used with the IOKit matching functions. The ID is valid only until the machine reboots.
    ///
    /// Parameter `entry`: The registry entry handle whose ID to look up.
    ///
    /// Parameter `entryID`: The resulting ID.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetRegistryEntryID(
        entry: io_registry_entry_t,
        entry_id: *mut u64,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Create a CF dictionary representation of a registry entry's property table.
    ///
    /// This function creates an instantaneous snapshot of a registry entry's property table, creating a CFDictionary analogue in the caller's task. Not every object available in the kernel is represented as a CF container; currently OSDictionary, OSArray, OSSet, OSSymbol, OSString, OSData, OSNumber, OSBoolean are created as their CF counterparts.
    ///
    /// Parameter `entry`: The registry entry handle whose property table to copy.
    ///
    /// Parameter `properties`: A CFDictionary is created and returned the caller on success. The caller should release with CFRelease.
    ///
    /// Parameter `allocator`: The CF allocator to use when creating the CF containers.
    ///
    /// Parameter `options`: No options are currently defined.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryCreateCFProperties(
        entry: io_registry_entry_t,
        properties: *mut *mut CFMutableDictionary,
        allocator: Option<&CFAllocator>,
        options: IOOptionBits,
    ) -> libc::kern_return_t;
}

/// Create a CF representation of a registry entry's property.
///
/// This function creates an instantaneous snapshot of a registry entry property, creating a CF container analogue in the caller's task. Not every object available in the kernel is represented as a CF container; currently OSDictionary, OSArray, OSSet, OSSymbol, OSString, OSData, OSNumber, OSBoolean are created as their CF counterparts.
///
/// Parameter `entry`: The registry entry handle whose property to copy.
///
/// Parameter `key`: A CFString specifying the property name.
///
/// Parameter `allocator`: The CF allocator to use when creating the CF container.
///
/// Parameter `options`: No options are currently defined.
///
/// Returns: A CF container is created and returned the caller on success. The caller should release with CFRelease.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IORegistryEntryCreateCFProperty(
    entry: io_registry_entry_t,
    key: Option<&CFString>,
    allocator: Option<&CFAllocator>,
    options: IOOptionBits,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IORegistryEntryCreateCFProperty(
            entry: io_registry_entry_t,
            key: Option<&CFString>,
            allocator: Option<&CFAllocator>,
            options: IOOptionBits,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IORegistryEntryCreateCFProperty(entry, key, allocator, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Create a CF representation of a registry entry's property.
///
/// This function creates an instantaneous snapshot of a registry entry property, creating a CF container analogue in the caller's task. Not every object available in the kernel is represented as a CF container; currently OSDictionary, OSArray, OSSet, OSSymbol, OSString, OSData, OSNumber, OSBoolean are created as their CF counterparts.
/// This function will search for a property, starting first with specified registry entry's property table, then iterating recusively through either the parent registry entries or the child registry entries of this entry. Once the first occurrence is found, it will lookup and return the value of the property, using the same semantics as IORegistryEntryCreateCFProperty. The iteration keeps track of entries that have been recursed into previously to avoid loops.
///
/// Parameter `entry`: The registry entry at which to start the search.
///
/// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
///
/// Parameter `key`: A CFString specifying the property name.
///
/// Parameter `allocator`: The CF allocator to use when creating the CF container.
///
/// Parameter `options`: kIORegistryIterateRecursively may be set to recurse automatically into the registry hierarchy. Without this option, this method degenerates into the standard IORegistryEntryCreateCFProperty() call. kIORegistryIterateParents may be set to iterate the parents of the entry, in place of the children.
///
/// Returns: A CF container is created and returned the caller on success. The caller should release with CFRelease.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IORegistryEntrySearchCFProperty(
    entry: io_registry_entry_t,
    plane: io_name_t,
    key: Option<&CFString>,
    allocator: Option<&CFAllocator>,
    options: IOOptionBits,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IORegistryEntrySearchCFProperty(
            entry: io_registry_entry_t,
            plane: io_name_t,
            key: Option<&CFString>,
            allocator: Option<&CFAllocator>,
            options: IOOptionBits,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IORegistryEntrySearchCFProperty(entry, plane, key, allocator, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetProperty(
        entry: io_registry_entry_t,
        property_name: io_name_t,
        buffer: io_struct_inband_t,
        size: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Set CF container based properties in a registry entry.
    ///
    /// This is a generic method to pass a CF container of properties to an object in the registry. Setting properties in a registry entry is not generally supported, it is more common to support IOConnectSetCFProperties for connection based property setting. The properties are interpreted by the object.
    ///
    /// Parameter `entry`: The registry entry whose properties to set.
    ///
    /// Parameter `properties`: A CF container - commonly a CFDictionary but this is not enforced. The container should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    ///
    /// Returns: A kern_return_t error code returned by the object.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntrySetCFProperties(
        entry: io_registry_entry_t,
        properties: Option<&CFType>,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Set a CF container based property in a registry entry.
    ///
    /// This is a generic method to pass a CF container as a property to an object in the registry. Setting properties in a registry entry is not generally supported, it is more common to support IOConnectSetCFProperty for connection based property setting. The property is interpreted by the object.
    ///
    /// Parameter `entry`: The registry entry whose property to set.
    ///
    /// Parameter `propertyName`: The name of the property as a CFString.
    ///
    /// Parameter `property`: A CF container - should consist of objects which are understood by IOKit - these are currently : CFDictionary, CFArray, CFSet, CFString, CFData, CFNumber, CFBoolean, and are passed in the kernel as the corresponding OSDictionary etc. objects.
    ///
    /// Returns: A kern_return_t error code returned by the object.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntrySetCFProperty(
        entry: io_registry_entry_t,
        property_name: Option<&CFString>,
        property: Option<&CFType>,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns an iterator over an registry entry's child entries in a plane.
    ///
    /// This method creates an iterator which will return each of a registry entry's child entries in a specified plane.
    ///
    /// Parameter `entry`: The registry entry whose children to iterate over.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `iterator`: The created iterator over the children of the entry, on success. The iterator must be released when the iteration is finished.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetChildIterator(
        entry: io_registry_entry_t,
        plane: io_name_t,
        iterator: *mut io_iterator_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns the first child of a registry entry in a plane.
    ///
    /// This function will return the child which first attached to a registry entry in a plane.
    ///
    /// Parameter `entry`: The registry entry whose child to look up.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `child`: The first child of the registry entry, on success. The child must be released by the caller.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetChildEntry(
        entry: io_registry_entry_t,
        plane: io_name_t,
        child: *mut io_registry_entry_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns an iterator over an registry entry's parent entries in a plane.
    ///
    /// This method creates an iterator which will return each of a registry entry's parent entries in a specified plane.
    ///
    /// Parameter `entry`: The registry entry whose parents to iterate over.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `iterator`: The created iterator over the parents of the entry, on success. The iterator must be released when the iteration is finished.
    ///
    /// Returns: A kern_return_t error.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetParentIterator(
        entry: io_registry_entry_t,
        plane: io_name_t,
        iterator: *mut io_iterator_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// Returns the first parent of a registry entry in a plane.
    ///
    /// This function will return the parent to which the registry entry was first attached in a plane.
    ///
    /// Parameter `entry`: The registry entry whose parent to look up.
    ///
    /// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
    ///
    /// Parameter `parent`: The first parent of the registry entry, on success. The parent must be released by the caller.
    ///
    /// Returns: A kern_return_t error code.
    #[cfg(feature = "libc")]
    pub fn IORegistryEntryGetParentEntry(
        entry: io_registry_entry_t,
        plane: io_name_t,
        parent: *mut io_registry_entry_t,
    ) -> libc::kern_return_t;
}

/// Determines if the registry entry is attached in a plane.
///
/// This method determines if the entry is attached in a plane to any other entry.
///
/// Parameter `entry`: The registry entry.
///
/// Parameter `plane`: The name of an existing registry plane. Plane names are defined in IOKitKeys.h, eg. kIOServicePlane.
///
/// Returns: If the entry has a parent in the plane, true is returned, otherwise false is returned.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IORegistryEntryInPlane(
    entry: io_registry_entry_t,
    plane: io_name_t,
) -> bool {
    extern "C-unwind" {
        fn IORegistryEntryInPlane(entry: io_registry_entry_t, plane: io_name_t) -> libc::boolean_t;
    }
    let ret = unsafe { IORegistryEntryInPlane(entry, plane) };
    ret != 0
}

/// Create a matching dictionary that specifies an IOService class match.
///
/// A very common matching criteria for IOService is based on its class. IOServiceMatching will create a matching dictionary that specifies any IOService of a class, or its subclasses. The class is specified by C-string name.
///
/// Parameter `name`: The class name, as a const C-string. Class matching is successful on IOService's of this class or any subclass.
///
/// Returns: The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller.
#[inline]
pub unsafe extern "C-unwind" fn IOServiceMatching(
    name: *const c_char,
) -> Option<CFRetained<CFMutableDictionary>> {
    extern "C-unwind" {
        fn IOServiceMatching(name: *const c_char) -> Option<NonNull<CFMutableDictionary>>;
    }
    let ret = unsafe { IOServiceMatching(name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Create a matching dictionary that specifies an IOService name match.
///
/// A common matching criteria for IOService is based on its name. IOServiceNameMatching will create a matching dictionary that specifies an IOService with a given name. Some IOServices created from the device tree will perform name matching on the standard compatible, name, model properties.
///
/// Parameter `name`: The IOService name, as a const C-string.
///
/// Returns: The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller.
#[inline]
pub unsafe extern "C-unwind" fn IOServiceNameMatching(
    name: *const c_char,
) -> Option<CFRetained<CFMutableDictionary>> {
    extern "C-unwind" {
        fn IOServiceNameMatching(name: *const c_char) -> Option<NonNull<CFMutableDictionary>>;
    }
    let ret = unsafe { IOServiceNameMatching(name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Create a matching dictionary that specifies an IOService match based on BSD device name.
///
/// IOServices that represent BSD devices have an associated BSD name. This function creates a matching dictionary that will match IOService's with a given BSD name.
///
/// Parameter `mainPort`: The main port obtained from IOMainPort(). Pass kIOMainPortDefault to look up the default main port.
///
/// Parameter `options`: No options are currently defined.
///
/// Parameter `bsdName`: The BSD name, as a const char *.
///
/// Returns: The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller.
#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IOBSDNameMatching(
    main_port: libc::mach_port_t,
    options: u32,
    bsd_name: *const c_char,
) -> Option<CFRetained<CFMutableDictionary>> {
    extern "C-unwind" {
        fn IOBSDNameMatching(
            main_port: libc::mach_port_t,
            options: u32,
            bsd_name: *const c_char,
        ) -> Option<NonNull<CFMutableDictionary>>;
    }
    let ret = unsafe { IOBSDNameMatching(main_port, options, bsd_name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "libc")]
#[inline]
pub unsafe extern "C-unwind" fn IOOpenFirmwarePathMatching(
    main_port: libc::mach_port_t,
    options: u32,
    path: *const c_char,
) -> Option<CFRetained<CFMutableDictionary>> {
    extern "C-unwind" {
        fn IOOpenFirmwarePathMatching(
            main_port: libc::mach_port_t,
            options: u32,
            path: *const c_char,
        ) -> Option<NonNull<CFMutableDictionary>>;
    }
    let ret = unsafe { IOOpenFirmwarePathMatching(main_port, options, path) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

/// Create a matching dictionary that specifies an IOService match based on a registry entry ID.
///
/// This function creates a matching dictionary that will match a registered, active IOService found with the given registry entry ID. The entry ID for a registry entry is returned by IORegistryEntryGetRegistryEntryID().
///
/// Parameter `entryID`: The registry entry ID to be found.
///
/// Returns: The matching dictionary created, is returned on success, or zero on failure. The dictionary is commonly passed to IOServiceGetMatchingServices or IOServiceAddNotification which will consume a reference, otherwise it should be released with CFRelease by the caller.
#[inline]
pub unsafe extern "C-unwind" fn IORegistryEntryIDMatching(
    entry_id: u64,
) -> Option<CFRetained<CFMutableDictionary>> {
    extern "C-unwind" {
        fn IORegistryEntryIDMatching(entry_id: u64) -> Option<NonNull<CFMutableDictionary>>;
    }
    let ret = unsafe { IORegistryEntryIDMatching(entry_id) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOServiceOFPathToBSDName(
        main_port: libc::mach_port_t,
        open_firmware_path: io_name_t,
        bsd_name: io_name_t,
    ) -> libc::kern_return_t;
}

/// standard callback function for asynchronous I/O requests with
/// no extra arguments beyond a refcon and result code.
///
/// Parameter `refcon`: The refcon passed into the original I/O request
///
/// Parameter `result`: The result of the I/O operation
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/ioasynccallback0?language=objc)
pub type IOAsyncCallback0 = Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn)>;

/// standard callback function for asynchronous I/O requests with
/// one extra argument beyond a refcon and result code.
/// This is often a count of the number of bytes transferred
///
/// Parameter `refcon`: The refcon passed into the original I/O request
///
/// Parameter `result`: The result of the I/O operation
///
/// Parameter `arg0`: Extra argument
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/ioasynccallback1?language=objc)
pub type IOAsyncCallback1 = Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void)>;

/// standard callback function for asynchronous I/O requests with
/// two extra arguments beyond a refcon and result code.
///
/// Parameter `refcon`: The refcon passed into the original I/O request
///
/// Parameter `result`: The result of the I/O operation
///
/// Parameter `arg0`: Extra argument
///
/// Parameter `arg1`: Extra argument
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/ioasynccallback2?language=objc)
pub type IOAsyncCallback2 =
    Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void, *mut c_void)>;

/// standard callback function for asynchronous I/O requests with
/// lots of extra arguments beyond a refcon and result code.
///
/// Parameter `refcon`: The refcon passed into the original I/O request
///
/// Parameter `result`: The result of the I/O operation
///
/// Parameter `args`: Array of extra arguments
///
/// Parameter `numArgs`: Number of extra arguments
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/ioasynccallback?language=objc)
pub type IOAsyncCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut *mut c_void, u32)>;

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOCatalogueSendData(
        main_port: libc::mach_port_t,
        flag: u32,
        buffer: *const c_char,
        size: u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOCatalogueTerminate(
        main_port: libc::mach_port_t,
        flag: u32,
        description: io_name_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOCatalogueGetData(
        main_port: libc::mach_port_t,
        flag: u32,
        buffer: *mut *mut c_char,
        size: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOCatalogueModuleLoaded(
        main_port: libc::mach_port_t,
        name: io_name_t,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOCatalogueReset(main_port: libc::mach_port_t, flag: u32) -> libc::kern_return_t;
}

/// Represents an entry within the data queue
///
/// This is a variable sized struct.  The data field simply represents the start of the data region.  The size of the data region is stored in the size field.  The whole size of the specific entry is the size of a UInt32 plus the size of the data region.
/// Field: size The size of the following data region.
/// Field: data Represents the beginning of the data region.  The address of the data field is a pointer to the start of the data region.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iodataqueueentry?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IODataQueueEntry {
    pub size: u32,
    pub data: [u8; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODataQueueEntry {
    const ENCODING: Encoding =
        Encoding::Struct("_IODataQueueEntry", &[<u32>::ENCODING, <[u8; 4]>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODataQueueEntry {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A struct mapping to the header region of a data queue.
///
/// This struct is variable sized.  The struct represents the data queue header information plus a pointer to the actual data queue itself.  The size of the struct is the combined size of the header fields (3 * sizeof(UInt32)) plus the actual size of the queue region.  This size is stored in the queueSize field.
/// Field: queueSize The size of the queue region pointed to by the queue field.
/// Field: head The location of the queue head.  This field is represented as a byte offset from the beginning of the queue memory region.
/// Field: tail The location of the queue tail.  This field is represented as a byte offset from the beginning of the queue memory region.
/// Field: queue Represents the beginning of the queue memory region.  The size of the region pointed to by queue is stored in the queueSize field.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iodataqueuememory?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IODataQueueMemory {
    pub queueSize: u32,
    pub head: u32,
    pub tail: u32,
    pub queue: [IODataQueueEntry; 1],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODataQueueMemory {
    const ENCODING: Encoding = Encoding::Struct(
        "_IODataQueueMemory",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[IODataQueueEntry; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODataQueueMemory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Used to determine if more data is available on the queue.
///
/// Parameter `dataQueue`: The IODataQueueMemory region mapped from the kernel.
///
/// Returns: Returns true if data is available and false if not.
#[inline]
pub unsafe extern "C-unwind" fn IODataQueueDataAvailable(
    data_queue: *mut IODataQueueMemory,
) -> bool {
    extern "C-unwind" {
        fn IODataQueueDataAvailable(data_queue: *mut IODataQueueMemory) -> Boolean;
    }
    let ret = unsafe { IODataQueueDataAvailable(data_queue) };
    ret != 0
}

extern "C-unwind" {
    /// Used to peek at the next entry on the queue.
    ///
    /// This function can be used to look at the next entry which allows the entry to be received without having to copy it with IODataQueueDequeue.  In order to do this, call IODataQueuePeek to get the entry.  Then call IODataQueueDequeue with a NULL data pointer.  That will cause the head to be moved to the next entry, but no memory to be copied.
    ///
    /// Parameter `dataQueue`: The IODataQueueMemory region mapped from the kernel.
    ///
    /// Returns: Returns a pointer to the next IODataQueueEntry if one is available.  Zero is returned if the queue is empty.
    pub fn IODataQueuePeek(data_queue: *mut IODataQueueMemory) -> *mut IODataQueueEntry;
}

extern "C-unwind" {
    /// Dequeues the next available entry on the queue and copies it into the given data pointer.
    ///
    /// This function will dequeue the next available entry on the queue.  If a data pointer is provided, it will copy the data into the memory region if there is enough space available as specified in the dataSize parameter.  If no data pointer is provided, it will simply move the head value past the current entry.
    ///
    /// Parameter `dataQueue`: The IODataQueueMemory region mapped from the kernel.
    ///
    /// Parameter `data`: A pointer to the data memory region in which to copy the next entry data on the queue.  If this parameter is 0 (NULL), it will simply move to the next entry.
    ///
    /// Parameter `dataSize`: A pointer to the size of the data parameter.  On return, this contains the size of the actual entry data - even if the original size was not large enough.
    ///
    /// Returns: Returns kIOReturnSuccess on success.  Other return values possible are: kIOReturnUnderrun - queue is empty, kIOReturnBadArgument - no dataQueue or no dataSize, kIOReturnNoSpace - dataSize is too small for entry.
    pub fn IODataQueueDequeue(
        data_queue: *mut IODataQueueMemory,
        data: *mut c_void,
        data_size: *mut u32,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Wait for an incoming dataAvailable message on the given notifyPort.
    ///
    /// This method will simply wait for an incoming message on the given notifyPort.  Once it is received, the return from mach_msg() is returned.
    ///
    /// Parameter `dataQueue`: The IODataQueueMemory region mapped from the kernel.
    ///
    /// Parameter `notificationPort`: Mach port on which to listen for incoming messages.
    ///
    /// Returns: Returns kIOReturnSuccess on success.  Returns kIOReturnBadArgument if either dataQueue is 0 (NULL) or notifyPort is MACH_PORT_NULL.  Returns the result of the mach_msg() listen call on the given port.
    #[cfg(feature = "libc")]
    pub fn IODataQueueWaitForAvailableData(
        data_queue: *mut IODataQueueMemory,
        notification_port: libc::mach_port_t,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Allocates and returns a new mach port able to receive data available notifications from an IODataQueue.
    ///
    /// This port is intended to be passed down into the kernel and into an IODataQueue to allow it to send the appropriate notification.  The returned mach port is allocated with a queue limit of one message.  This allows only one mach message to be queued up at a time.  The IODataQueue code is written with the restriction in mind and will only queue up a message if no messages alread have been sent.
    ///
    /// Returns: Returns a newly allocated mach port on success.  On failure, it returns MACH_PORT_NULL.
    #[cfg(feature = "libc")]
    pub fn IODataQueueAllocateNotificationPort() -> libc::mach_port_t;
}

extern "C-unwind" {
    /// Enqueues a new entry on the queue.
    ///
    /// This method adds a new data entry of dataSize to the queue.  It sets the size parameter of the entry pointed to by the tail value and copies the memory pointed to by the data parameter in place in the queue.  Once that is done, it moves the tail to the next available location.  When attempting to add a new entry towards the end of the queue and there isn't enough space at the end, it wraps back to the beginning.
    /// <br>
    /// If the queue is empty when a new entry is added, the port specified in IODataQueueSetNotificationPort will be used to send a message to the client process that data is now available.
    /// <br>
    /// <b>
    /// Please note that using this method without mapped memory create from an IOSharedDataQueue will result in undefined behavior.
    /// </b>
    ///
    /// Parameter `dataQueue`: The IODataQueueMemory region mapped from the kernel created from an IOSharedDataQueue.
    ///
    /// Parameter `data`: Pointer to the data to be added to the queue.
    ///
    /// Parameter `dataSize`: Size of the data pointed to by data.
    ///
    /// Returns: Returns kIOReturnSuccess on success.  Other return values possible are: kIOReturnOverrun - queue is full.
    pub fn IODataQueueEnqueue(
        data_queue: *mut IODataQueueMemory,
        data: *mut c_void,
        data_size: u32,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Creates a simple mach message targeting the mach port specified in port.
    ///
    /// This message is sent when data is added to an empty queue.  It is to notify another user process that new data has become available.
    /// <b>
    /// Please note that using this method without mapped memory create from an IOSharedDataQueue will result in undefined behavior.
    /// </b>
    ///
    /// Parameter `dataQueue`: The IODataQueueMemory region mapped from the kernel created from an IOSharedDataQueue.
    ///
    /// Parameter `notifyPort`: The mach port to target with the notification message.
    ///
    /// Returns: Returns kIOReturnSuccess on success.  Returns kIOReturnBadArgument if either dataQueue is 0 (NULL).
    #[cfg(feature = "libc")]
    pub fn IODataQueueSetNotificationPort(
        data_queue: *mut IODataQueueMemory,
        notify_port: libc::mach_port_t,
    ) -> IOReturn;
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iocfplugininterfacestruct?language=objc)
#[cfg(feature = "libc")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOCFPlugInInterfaceStruct {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub version: u16,
    pub revision: u16,
    pub Probe: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *const CFDictionary,
            io_service_t,
            *mut i32,
        ) -> IOReturn,
    >,
    pub Start: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *const CFDictionary, io_service_t) -> IOReturn,
    >,
    pub Stop: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOCFPlugInInterfaceStruct {
    const ENCODING: Encoding = Encoding::Struct("IOCFPlugInInterfaceStruct", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <u16>::ENCODING,
        <u16>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFDictionary,io_service_t,*mut i32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFDictionary,io_service_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOCFPlugInInterfaceStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iocfplugininterface?language=objc)
#[cfg(feature = "libc")]
pub type IOCFPlugInInterface = IOCFPlugInInterfaceStruct;

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IOCreatePlugInInterfaceForService(
        service: io_service_t,
        plugin_type: Option<&CFUUID>,
        interface_type: Option<&CFUUID>,
        the_interface: *mut *mut *mut IOCFPlugInInterface,
        the_score: *mut i32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    pub fn IODestroyPlugInInterface(
        interface: *mut *mut IOCFPlugInInterface,
    ) -> libc::kern_return_t;
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocfserializetobinary?language=objc)
pub const kIOCFSerializeToBinary: c_uint = 0x00000001;

#[inline]
pub unsafe extern "C-unwind" fn IOCFSerialize(
    object: Option<&CFType>,
    options: CFOptionFlags,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn IOCFSerialize(
            object: Option<&CFType>,
            options: CFOptionFlags,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { IOCFSerialize(object, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn IOURLCreatePropertyFromResource(
    alloc: Option<&CFAllocator>,
    url: Option<&CFURL>,
    property: Option<&CFString>,
    error_code: *mut i32,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOURLCreatePropertyFromResource(
            alloc: Option<&CFAllocator>,
            url: Option<&CFURL>,
            property: Option<&CFString>,
            error_code: *mut i32,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOURLCreatePropertyFromResource(alloc, url, property, error_code) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn IOURLCreateDataAndPropertiesFromResource(
    alloc: Option<&CFAllocator>,
    url: Option<&CFURL>,
    resource_data: *mut *const CFData,
    properties: *mut *const CFDictionary,
    desired_properties: Option<&CFArray>,
    error_code: *mut i32,
) -> bool {
    extern "C-unwind" {
        fn IOURLCreateDataAndPropertiesFromResource(
            alloc: Option<&CFAllocator>,
            url: Option<&CFURL>,
            resource_data: *mut *const CFData,
            properties: *mut *const CFDictionary,
            desired_properties: Option<&CFArray>,
            error_code: *mut i32,
        ) -> Boolean;
    }
    let ret = unsafe {
        IOURLCreateDataAndPropertiesFromResource(
            alloc,
            url,
            resource_data,
            properties,
            desired_properties,
            error_code,
        )
    };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn IOURLWriteDataAndPropertiesToResource(
    url: Option<&CFURL>,
    data_to_write: Option<&CFData>,
    properties_to_write: Option<&CFDictionary>,
    error_code: *mut i32,
) -> bool {
    extern "C-unwind" {
        fn IOURLWriteDataAndPropertiesToResource(
            url: Option<&CFURL>,
            data_to_write: Option<&CFData>,
            properties_to_write: Option<&CFDictionary>,
            error_code: *mut i32,
        ) -> Boolean;
    }
    let ret = unsafe {
        IOURLWriteDataAndPropertiesToResource(url, data_to_write, properties_to_write, error_code)
    };
    ret != 0
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iourlerror?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOURLError(pub c_int);
impl IOURLError {
    #[doc(alias = "kIOURLUnknownError")]
    pub const UnknownError: Self = Self(-10);
    #[doc(alias = "kIOURLUnknownSchemeError")]
    pub const UnknownSchemeError: Self = Self(-11);
    #[doc(alias = "kIOURLResourceNotFoundError")]
    pub const ResourceNotFoundError: Self = Self(-12);
    #[doc(alias = "kIOURLResourceAccessViolationError")]
    pub const ResourceAccessViolationError: Self = Self(-13);
    #[doc(alias = "kIOURLRemoteHostUnavailableError")]
    pub const RemoteHostUnavailableError: Self = Self(-14);
    #[doc(alias = "kIOURLImproperArgumentsError")]
    pub const ImproperArgumentsError: Self = Self(-15);
    #[doc(alias = "kIOURLUnknownPropertyKeyError")]
    pub const UnknownPropertyKeyError: Self = Self(-16);
    #[doc(alias = "kIOURLPropertyKeyUnavailableError")]
    pub const PropertyKeyUnavailableError: Self = Self(-17);
    #[doc(alias = "kIOURLTimeoutError")]
    pub const TimeoutError: Self = Self(-18);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOURLError {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOURLError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogadddrivers?language=objc)
pub const kIOCatalogAddDrivers: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogadddriversnomatch?language=objc)
pub const kIOCatalogAddDriversNoMatch: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogremovedrivers?language=objc)
pub const kIOCatalogRemoveDrivers: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogremovedriversnomatch?language=objc)
pub const kIOCatalogRemoveDriversNoMatch: c_uint = 4;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogstartmatching__removed?language=objc)
pub const kIOCatalogStartMatching__Removed: c_uint = 5;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogremovekernellinker__removed?language=objc)
pub const kIOCatalogRemoveKernelLinker__Removed: c_uint = 6;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogkextdactive?language=objc)
pub const kIOCatalogKextdActive: c_uint = 7;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogkextdfinishedlaunching?language=objc)
pub const kIOCatalogKextdFinishedLaunching: c_uint = 8;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogresetdrivers?language=objc)
pub const kIOCatalogResetDrivers: c_uint = 9;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogresetdriversnomatch?language=objc)
pub const kIOCatalogResetDriversNoMatch: c_uint = 10;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocataloggetcontents?language=objc)
pub const kIOCatalogGetContents: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocataloggetmoduledemandlist?language=objc)
pub const kIOCatalogGetModuleDemandList: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocataloggetcachemisslist?language=objc)
pub const kIOCatalogGetCacheMissList: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocataloggetrommkextlist?language=objc)
pub const kIOCatalogGetROMMkextList: c_uint = 4;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogresetdefault?language=objc)
pub const kIOCatalogResetDefault: c_uint = 1;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogmoduleunload?language=objc)
pub const kIOCatalogModuleUnload: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogmoduleterminate?language=objc)
pub const kIOCatalogModuleTerminate: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiocatalogserviceterminate?language=objc)
pub const kIOCatalogServiceTerminate: c_uint = 3;

#[inline]
pub unsafe extern "C-unwind" fn IOCFUnserialize(
    buffer: *const c_char,
    allocator: Option<&CFAllocator>,
    options: CFOptionFlags,
    error_string: *mut *const CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOCFUnserialize(
            buffer: *const c_char,
            allocator: Option<&CFAllocator>,
            options: CFOptionFlags,
            error_string: *mut *const CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOCFUnserialize(buffer, allocator, options, error_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn IOCFUnserializeBinary(
    buffer: *const c_char,
    buffer_size: usize,
    allocator: Option<&CFAllocator>,
    options: CFOptionFlags,
    error_string: *mut *const CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOCFUnserializeBinary(
            buffer: *const c_char,
            buffer_size: usize,
            allocator: Option<&CFAllocator>,
            options: CFOptionFlags,
            error_string: *mut *const CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret =
        unsafe { IOCFUnserializeBinary(buffer, buffer_size, allocator, options, error_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[inline]
pub unsafe extern "C-unwind" fn IOCFUnserializeWithSize(
    buffer: *const c_char,
    buffer_size: usize,
    allocator: Option<&CFAllocator>,
    options: CFOptionFlags,
    error_string: *mut *const CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOCFUnserializeWithSize(
            buffer: *const c_char,
            buffer_size: usize,
            allocator: Option<&CFAllocator>,
            options: CFOptionFlags,
            error_string: *mut *const CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret =
        unsafe { IOCFUnserializeWithSize(buffer, buffer_size, allocator, options, error_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// IOMessage.h
///
/// Defines message type constants for several IOKit messaging API's.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iomessage?language=objc)
pub type IOMessage = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/osobjectref?language=objc)
pub type OSObjectRef = u64;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcversion190615?language=objc)
pub const kIORPCVersion190615: c_uint = 0x4da2b68c;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcversion190615reply?language=objc)
pub const kIORPCVersion190615Reply: c_uint = 0x4da2b68d;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessageremote?language=objc)
pub const kIORPCMessageRemote: c_uint = 0x00000001;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessagelocalhost?language=objc)
pub const kIORPCMessageLocalHost: c_uint = 0x00000002;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessagekernel?language=objc)
pub const kIORPCMessageKernel: c_uint = 0x00000004;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessageoneway?language=objc)
pub const kIORPCMessageOneway: c_uint = 0x00000008;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessageobjectrefs?language=objc)
pub const kIORPCMessageObjectRefs: c_uint = 0x00000010;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessageonqueue?language=objc)
pub const kIORPCMessageOnqueue: c_uint = 0x00000020;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessageerror?language=objc)
pub const kIORPCMessageError: c_uint = 0x00000040;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiorpcmessagesimplereply?language=objc)
pub const kIORPCMessageSimpleReply: c_uint = 0x00000080;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iorpcmessage?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IORPCMessage {
    pub msgid: u64,
    pub flags: u64,
    pub objectRefs: u64,
    pub objects: [OSObjectRef; 0],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IORPCMessage {
    const ENCODING: Encoding = Encoding::Struct(
        "IORPCMessage",
        &[
            <u64>::ENCODING,
            <u64>::ENCODING,
            <u64>::ENCODING,
            <[OSObjectRef; 0]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IORPCMessage {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iorpcmessageerrorreturncontent?language=objc)
#[cfg(feature = "libc")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IORPCMessageErrorReturnContent {
    pub hdr: IORPCMessage,
    pub result: libc::kern_return_t,
    pub pad: u32,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IORPCMessageErrorReturnContent {
    const ENCODING: Encoding = Encoding::Struct(
        "IORPCMessageErrorReturnContent",
        &[
            <IORPCMessage>::ENCODING,
            <libc::kern_return_t>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IORPCMessageErrorReturnContent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kosclasscanremote?language=objc)
pub const kOSClassCanRemote: c_uint = 0x00000001;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/osclassdescription?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OSClassDescription {
    pub descriptionSize: u32,
    pub name: [c_char; 96],
    pub superName: [c_char; 96],
    pub methodOptionsSize: u32,
    pub methodOptionsOffset: u32,
    pub metaMethodOptionsSize: u32,
    pub metaMethodOptionsOffset: u32,
    pub queueNamesSize: u32,
    pub queueNamesOffset: u32,
    pub methodNamesSize: u32,
    pub methodNamesOffset: u32,
    pub metaMethodNamesSize: u32,
    pub metaMethodNamesOffset: u32,
    pub flags: u64,
    pub resv1: [u64; 8],
    pub methodOptions: [u64; 0],
    pub metaMethodOptions: [u64; 0],
    pub dispatchNames: [c_char; 0],
    pub methodNames: [c_char; 0],
    pub metaMethodNames: [c_char; 0],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OSClassDescription {
    const ENCODING: Encoding = Encoding::Struct(
        "OSClassDescription",
        &[
            <u32>::ENCODING,
            <[c_char; 96]>::ENCODING,
            <[c_char; 96]>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u64>::ENCODING,
            <[u64; 8]>::ENCODING,
            <[u64; 0]>::ENCODING,
            <[u64; 0]>::ENCODING,
            <[c_char; 0]>::ENCODING,
            <[c_char; 0]>::ENCODING,
            <[c_char; 0]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OSClassDescription {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
