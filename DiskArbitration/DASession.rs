//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

/// Type of a reference to DASession instances.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/dasession?language=objc)
#[repr(C)]
pub struct DASession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__DASession"]
    unsafe impl DASession {}
);

unsafe impl ConcreteType for DASession {
    /// Returns the type identifier of all DASession instances.
    #[doc(alias = "DASessionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn DASessionGetTypeID() -> CFTypeID;
        }
        unsafe { DASessionGetTypeID() }
    }
}

/// Creates a new session.
///
/// Returns: A reference to a new DASession.
///
/// The caller of this function receives a reference to the returned object.  The
/// caller also implicitly retains the object and is responsible for releasing it.
#[inline]
pub unsafe extern "C-unwind" fn DASessionCreate(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<DASession>> {
    extern "C-unwind" {
        fn DASessionCreate(allocator: Option<&CFAllocator>) -> *mut DASession;
    }
    let ret = unsafe { DASessionCreate(allocator) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Schedules the session on a run loop.
    ///
    /// Parameter `session`: The session which is being scheduled.
    ///
    /// Parameter `runLoop`: The run loop on which the session should be scheduled.
    ///
    /// Parameter `runLoopMode`: The run loop mode in which the session should be scheduled.
    pub fn DASessionScheduleWithRunLoop(
        session: &DASession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    /// Unschedules the session from a run loop.
    ///
    /// Parameter `session`: The session which is being unscheduled.
    ///
    /// Parameter `runLoop`: The run loop on which the session is scheduled.
    ///
    /// Parameter `runLoopMode`: The run loop mode in which the session is scheduled.
    pub fn DASessionUnscheduleFromRunLoop(
        session: &DASession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/daapprovalsession?language=objc)
#[repr(C)]
pub struct DAApprovalSession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__DASession"]
    unsafe impl DAApprovalSession {}
);

unsafe impl ConcreteType for DAApprovalSession {
    #[doc(alias = "DAApprovalSessionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn DAApprovalSessionGetTypeID() -> CFTypeID;
        }
        unsafe { DAApprovalSessionGetTypeID() }
    }
}

#[inline]
pub unsafe extern "C-unwind" fn DAApprovalSessionCreate(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<DAApprovalSession>> {
    extern "C-unwind" {
        fn DAApprovalSessionCreate(allocator: Option<&CFAllocator>) -> *mut DAApprovalSession;
    }
    let ret = unsafe { DAApprovalSessionCreate(allocator) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    pub fn DAApprovalSessionScheduleWithRunLoop(
        session: &DAApprovalSession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    pub fn DAApprovalSessionUnscheduleFromRunLoop(
        session: &DAApprovalSession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}
