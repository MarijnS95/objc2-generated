//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEOnDemandRuleAction(pub NSInteger);
impl NEOnDemandRuleAction {
    #[doc(alias = "NEOnDemandRuleActionConnect")]
    pub const Connect: Self = Self(1);
    #[doc(alias = "NEOnDemandRuleActionDisconnect")]
    pub const Disconnect: Self = Self(2);
    #[doc(alias = "NEOnDemandRuleActionEvaluateConnection")]
    pub const EvaluateConnection: Self = Self(3);
    #[doc(alias = "NEOnDemandRuleActionIgnore")]
    pub const Ignore: Self = Self(4);
}

unsafe impl Encode for NEOnDemandRuleAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEOnDemandRuleAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEOnDemandRuleInterfaceType(pub NSInteger);
impl NEOnDemandRuleInterfaceType {
    #[doc(alias = "NEOnDemandRuleInterfaceTypeAny")]
    pub const Any: Self = Self(0);
    #[doc(alias = "NEOnDemandRuleInterfaceTypeEthernet")]
    pub const Ethernet: Self = Self(1);
    #[doc(alias = "NEOnDemandRuleInterfaceTypeWiFi")]
    pub const WiFi: Self = Self(2);
    #[doc(alias = "NEOnDemandRuleInterfaceTypeCellular")]
    pub const Cellular: Self = Self(3);
}

unsafe impl Encode for NEOnDemandRuleInterfaceType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEOnDemandRuleInterfaceType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRule;

    unsafe impl ClassType for NEOnDemandRule {
        type Super = NSObject;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSCoding for NEOnDemandRule {}

unsafe impl NSCopying for NEOnDemandRule {}

unsafe impl NSObjectProtocol for NEOnDemandRule {}

unsafe impl NSSecureCoding for NEOnDemandRule {}

extern_methods!(
    unsafe impl NEOnDemandRule {
        #[method(action)]
        pub unsafe fn action(&self) -> NEOnDemandRuleAction;

        #[method_id(@__retain_semantics Other DNSSearchDomainMatch)]
        pub unsafe fn DNSSearchDomainMatch(&self) -> Option<Id<NSArray<NSString>>>;

        #[method(setDNSSearchDomainMatch:)]
        pub unsafe fn setDNSSearchDomainMatch(
            &self,
            dns_search_domain_match: Option<&NSArray<NSString>>,
        );

        #[method_id(@__retain_semantics Other DNSServerAddressMatch)]
        pub unsafe fn DNSServerAddressMatch(&self) -> Option<Id<NSArray<NSString>>>;

        #[method(setDNSServerAddressMatch:)]
        pub unsafe fn setDNSServerAddressMatch(
            &self,
            dns_server_address_match: Option<&NSArray<NSString>>,
        );

        #[method(interfaceTypeMatch)]
        pub unsafe fn interfaceTypeMatch(&self) -> NEOnDemandRuleInterfaceType;

        #[method(setInterfaceTypeMatch:)]
        pub unsafe fn setInterfaceTypeMatch(
            &self,
            interface_type_match: NEOnDemandRuleInterfaceType,
        );

        #[method_id(@__retain_semantics Other SSIDMatch)]
        pub unsafe fn SSIDMatch(&self) -> Option<Id<NSArray<NSString>>>;

        #[method(setSSIDMatch:)]
        pub unsafe fn setSSIDMatch(&self, ssid_match: Option<&NSArray<NSString>>);

        #[method_id(@__retain_semantics Other probeURL)]
        pub unsafe fn probeURL(&self) -> Option<Id<NSURL>>;

        #[method(setProbeURL:)]
        pub unsafe fn setProbeURL(&self, probe_url: Option<&NSURL>);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NEOnDemandRule {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Id<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleConnect;

    unsafe impl ClassType for NEOnDemandRuleConnect {
        #[inherits(NSObject)]
        type Super = NEOnDemandRule;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSCoding for NEOnDemandRuleConnect {}

unsafe impl NSCopying for NEOnDemandRuleConnect {}

unsafe impl NSObjectProtocol for NEOnDemandRuleConnect {}

unsafe impl NSSecureCoding for NEOnDemandRuleConnect {}

extern_methods!(
    unsafe impl NEOnDemandRuleConnect {}
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NEOnDemandRuleConnect {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Id<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleDisconnect;

    unsafe impl ClassType for NEOnDemandRuleDisconnect {
        #[inherits(NSObject)]
        type Super = NEOnDemandRule;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSCoding for NEOnDemandRuleDisconnect {}

unsafe impl NSCopying for NEOnDemandRuleDisconnect {}

unsafe impl NSObjectProtocol for NEOnDemandRuleDisconnect {}

unsafe impl NSSecureCoding for NEOnDemandRuleDisconnect {}

extern_methods!(
    unsafe impl NEOnDemandRuleDisconnect {}
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NEOnDemandRuleDisconnect {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Id<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleIgnore;

    unsafe impl ClassType for NEOnDemandRuleIgnore {
        #[inherits(NSObject)]
        type Super = NEOnDemandRule;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSCoding for NEOnDemandRuleIgnore {}

unsafe impl NSCopying for NEOnDemandRuleIgnore {}

unsafe impl NSObjectProtocol for NEOnDemandRuleIgnore {}

unsafe impl NSSecureCoding for NEOnDemandRuleIgnore {}

extern_methods!(
    unsafe impl NEOnDemandRuleIgnore {}
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NEOnDemandRuleIgnore {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Id<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleEvaluateConnection;

    unsafe impl ClassType for NEOnDemandRuleEvaluateConnection {
        #[inherits(NSObject)]
        type Super = NEOnDemandRule;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSCoding for NEOnDemandRuleEvaluateConnection {}

unsafe impl NSCopying for NEOnDemandRuleEvaluateConnection {}

unsafe impl NSObjectProtocol for NEOnDemandRuleEvaluateConnection {}

unsafe impl NSSecureCoding for NEOnDemandRuleEvaluateConnection {}

extern_methods!(
    unsafe impl NEOnDemandRuleEvaluateConnection {
        #[method_id(@__retain_semantics Other connectionRules)]
        pub unsafe fn connectionRules(&self) -> Option<Id<NSArray<NEEvaluateConnectionRule>>>;

        #[method(setConnectionRules:)]
        pub unsafe fn setConnectionRules(
            &self,
            connection_rules: Option<&NSArray<NEEvaluateConnectionRule>>,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NEOnDemandRuleEvaluateConnection {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Id<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;
    }
);

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEEvaluateConnectionRuleAction(pub NSInteger);
impl NEEvaluateConnectionRuleAction {
    #[doc(alias = "NEEvaluateConnectionRuleActionConnectIfNeeded")]
    pub const ConnectIfNeeded: Self = Self(1);
    #[doc(alias = "NEEvaluateConnectionRuleActionNeverConnect")]
    pub const NeverConnect: Self = Self(2);
}

unsafe impl Encode for NEEvaluateConnectionRuleAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEEvaluateConnectionRuleAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEEvaluateConnectionRule;

    unsafe impl ClassType for NEEvaluateConnectionRule {
        type Super = NSObject;
        type Mutability = InteriorMutable;
    }
);

unsafe impl NSCoding for NEEvaluateConnectionRule {}

unsafe impl NSCopying for NEEvaluateConnectionRule {}

unsafe impl NSObjectProtocol for NEEvaluateConnectionRule {}

unsafe impl NSSecureCoding for NEEvaluateConnectionRule {}

extern_methods!(
    unsafe impl NEEvaluateConnectionRule {
        #[method_id(@__retain_semantics Init initWithMatchDomains:andAction:)]
        pub unsafe fn initWithMatchDomains_andAction(
            this: Allocated<Self>,
            domains: &NSArray<NSString>,
            action: NEEvaluateConnectionRuleAction,
        ) -> Id<Self>;

        #[method(action)]
        pub unsafe fn action(&self) -> NEEvaluateConnectionRuleAction;

        #[method_id(@__retain_semantics Other matchDomains)]
        pub unsafe fn matchDomains(&self) -> Id<NSArray<NSString>>;

        #[method_id(@__retain_semantics Other useDNSServers)]
        pub unsafe fn useDNSServers(&self) -> Option<Id<NSArray<NSString>>>;

        #[method(setUseDNSServers:)]
        pub unsafe fn setUseDNSServers(&self, use_dns_servers: Option<&NSArray<NSString>>);

        #[method_id(@__retain_semantics Other probeURL)]
        pub unsafe fn probeURL(&self) -> Option<Id<NSURL>>;

        #[method(setProbeURL:)]
        pub unsafe fn setProbeURL(&self, probe_url: Option<&NSURL>);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl NEEvaluateConnectionRule {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Id<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;
    }
);
