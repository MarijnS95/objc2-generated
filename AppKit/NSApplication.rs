//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-cloud-kit")]
#[cfg(target_vendor = "apple")]
use objc2_cloud_kit::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversion?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSAppKitVersion = c_double;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber?language=objc)
    pub static NSAppKitVersionNumber: NSAppKitVersion;
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_0?language=objc)
pub static NSAppKitVersionNumber10_0: NSAppKitVersion = 577 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_1?language=objc)
pub static NSAppKitVersionNumber10_1: NSAppKitVersion = 620 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_2?language=objc)
pub static NSAppKitVersionNumber10_2: NSAppKitVersion = 663 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_2_3?language=objc)
pub static NSAppKitVersionNumber10_2_3: NSAppKitVersion = 663.6 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_3?language=objc)
pub static NSAppKitVersionNumber10_3: NSAppKitVersion = 743 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_3_2?language=objc)
pub static NSAppKitVersionNumber10_3_2: NSAppKitVersion = 743.14 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_3_3?language=objc)
pub static NSAppKitVersionNumber10_3_3: NSAppKitVersion = 743.2 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_3_5?language=objc)
pub static NSAppKitVersionNumber10_3_5: NSAppKitVersion = 743.24 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_3_7?language=objc)
pub static NSAppKitVersionNumber10_3_7: NSAppKitVersion = 743.33 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_3_9?language=objc)
pub static NSAppKitVersionNumber10_3_9: NSAppKitVersion = 743.36 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_4?language=objc)
pub static NSAppKitVersionNumber10_4: NSAppKitVersion = 824 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_4_1?language=objc)
pub static NSAppKitVersionNumber10_4_1: NSAppKitVersion = 824.1 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_4_3?language=objc)
pub static NSAppKitVersionNumber10_4_3: NSAppKitVersion = 824.23 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_4_4?language=objc)
pub static NSAppKitVersionNumber10_4_4: NSAppKitVersion = 824.33 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_4_7?language=objc)
pub static NSAppKitVersionNumber10_4_7: NSAppKitVersion = 824.41 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_5?language=objc)
pub static NSAppKitVersionNumber10_5: NSAppKitVersion = 949 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_5_2?language=objc)
pub static NSAppKitVersionNumber10_5_2: NSAppKitVersion = 949.27 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_5_3?language=objc)
pub static NSAppKitVersionNumber10_5_3: NSAppKitVersion = 949.33 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_6?language=objc)
pub static NSAppKitVersionNumber10_6: NSAppKitVersion = 1038 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_7?language=objc)
pub static NSAppKitVersionNumber10_7: NSAppKitVersion = 1138 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_7_2?language=objc)
pub static NSAppKitVersionNumber10_7_2: NSAppKitVersion = 1138.23 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_7_3?language=objc)
pub static NSAppKitVersionNumber10_7_3: NSAppKitVersion = 1138.32 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_7_4?language=objc)
pub static NSAppKitVersionNumber10_7_4: NSAppKitVersion = 1138.47 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_8?language=objc)
pub static NSAppKitVersionNumber10_8: NSAppKitVersion = 1187 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_9?language=objc)
pub static NSAppKitVersionNumber10_9: NSAppKitVersion = 1265 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_10?language=objc)
pub static NSAppKitVersionNumber10_10: NSAppKitVersion = 1343 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_10_2?language=objc)
pub static NSAppKitVersionNumber10_10_2: NSAppKitVersion = 1344 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_10_3?language=objc)
pub static NSAppKitVersionNumber10_10_3: NSAppKitVersion = 1347 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_10_4?language=objc)
pub static NSAppKitVersionNumber10_10_4: NSAppKitVersion = 1348 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_10_5?language=objc)
pub static NSAppKitVersionNumber10_10_5: NSAppKitVersion = 1348 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_10_max?language=objc)
pub static NSAppKitVersionNumber10_10_Max: NSAppKitVersion = 1349 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_11?language=objc)
pub static NSAppKitVersionNumber10_11: NSAppKitVersion = 1404 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_11_1?language=objc)
pub static NSAppKitVersionNumber10_11_1: NSAppKitVersion = 1404.13 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_11_2?language=objc)
pub static NSAppKitVersionNumber10_11_2: NSAppKitVersion = 1404.34 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_11_3?language=objc)
pub static NSAppKitVersionNumber10_11_3: NSAppKitVersion = 1404.34 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_12?language=objc)
pub static NSAppKitVersionNumber10_12: NSAppKitVersion = 1504 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_12_1?language=objc)
pub static NSAppKitVersionNumber10_12_1: NSAppKitVersion = 1504.6 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_12_2?language=objc)
pub static NSAppKitVersionNumber10_12_2: NSAppKitVersion = 1504.76 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_13?language=objc)
pub static NSAppKitVersionNumber10_13: NSAppKitVersion = 1561 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_13_1?language=objc)
pub static NSAppKitVersionNumber10_13_1: NSAppKitVersion = 1561.1 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_13_2?language=objc)
pub static NSAppKitVersionNumber10_13_2: NSAppKitVersion = 1561.2 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_13_4?language=objc)
pub static NSAppKitVersionNumber10_13_4: NSAppKitVersion = 1561.4 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_14?language=objc)
pub static NSAppKitVersionNumber10_14: NSAppKitVersion = 1671 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_14_1?language=objc)
pub static NSAppKitVersionNumber10_14_1: NSAppKitVersion = 1671.1 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_14_2?language=objc)
pub static NSAppKitVersionNumber10_14_2: NSAppKitVersion = 1671.2 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_14_3?language=objc)
pub static NSAppKitVersionNumber10_14_3: NSAppKitVersion = 1671.3 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_14_4?language=objc)
pub static NSAppKitVersionNumber10_14_4: NSAppKitVersion = 1671.4 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_14_5?language=objc)
pub static NSAppKitVersionNumber10_14_5: NSAppKitVersion = 1671.5 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_15?language=objc)
pub static NSAppKitVersionNumber10_15: NSAppKitVersion = 1894 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_15_1?language=objc)
pub static NSAppKitVersionNumber10_15_1: NSAppKitVersion = 1894.1 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_15_2?language=objc)
pub static NSAppKitVersionNumber10_15_2: NSAppKitVersion = 1894.2 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_15_3?language=objc)
pub static NSAppKitVersionNumber10_15_3: NSAppKitVersion = 1894.3 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_15_4?language=objc)
pub static NSAppKitVersionNumber10_15_4: NSAppKitVersion = 1894.4 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_15_5?language=objc)
pub static NSAppKitVersionNumber10_15_5: NSAppKitVersion = 1894.5 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber10_15_6?language=objc)
pub static NSAppKitVersionNumber10_15_6: NSAppKitVersion = 1894.6 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber11_0?language=objc)
pub static NSAppKitVersionNumber11_0: NSAppKitVersion = 2022 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber11_1?language=objc)
pub static NSAppKitVersionNumber11_1: NSAppKitVersion = 2022.2 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber11_2?language=objc)
pub static NSAppKitVersionNumber11_2: NSAppKitVersion = 2022.3 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber11_3?language=objc)
pub static NSAppKitVersionNumber11_3: NSAppKitVersion = 2022.4 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber11_4?language=objc)
pub static NSAppKitVersionNumber11_4: NSAppKitVersion = 2022.5 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber11_5?language=objc)
pub static NSAppKitVersionNumber11_5: NSAppKitVersion = 2022.6 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber12_0?language=objc)
pub static NSAppKitVersionNumber12_0: NSAppKitVersion = 2113 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber12_1?language=objc)
pub static NSAppKitVersionNumber12_1: NSAppKitVersion = 2113.2 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber12_2?language=objc)
pub static NSAppKitVersionNumber12_2: NSAppKitVersion = 2113.3 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber12_3?language=objc)
pub static NSAppKitVersionNumber12_3: NSAppKitVersion = 2113.4 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber12_4?language=objc)
pub static NSAppKitVersionNumber12_4: NSAppKitVersion = 2113.5 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber12_5?language=objc)
pub static NSAppKitVersionNumber12_5: NSAppKitVersion = 2113.6 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber13_0?language=objc)
pub static NSAppKitVersionNumber13_0: NSAppKitVersion = 2299 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber13_1?language=objc)
pub static NSAppKitVersionNumber13_1: NSAppKitVersion = 2299.3 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber13_2?language=objc)
pub static NSAppKitVersionNumber13_2: NSAppKitVersion = 2299.3 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber13_3?language=objc)
pub static NSAppKitVersionNumber13_3: NSAppKitVersion = 2299.4 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber13_4?language=objc)
pub static NSAppKitVersionNumber13_4: NSAppKitVersion = 2299.5 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber13_5?language=objc)
pub static NSAppKitVersionNumber13_5: NSAppKitVersion = 2299.6 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber13_6?language=objc)
pub static NSAppKitVersionNumber13_6: NSAppKitVersion = 2299.7 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber14_0?language=objc)
pub static NSAppKitVersionNumber14_0: NSAppKitVersion = 2487 as _;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsappkitversionnumber14_1?language=objc)
pub static NSAppKitVersionNumber14_1: NSAppKitVersion = 2487.2 as _;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsmodalpanelrunloopmode?language=objc)
    pub static NSModalPanelRunLoopMode: &'static NSRunLoopMode;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nseventtrackingrunloopmode?language=objc)
    pub static NSEventTrackingRunLoopMode: &'static NSRunLoopMode;
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsmodalresponse?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSModalResponse = NSInteger;

/// Also used as the default response for sheets
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsmodalresponsestop?language=objc)
pub static NSModalResponseStop: NSModalResponse = -1000;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsmodalresponseabort?language=objc)
pub static NSModalResponseAbort: NSModalResponse = -1001;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsmodalresponsecontinue?language=objc)
pub static NSModalResponseContinue: NSModalResponse = -1002;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsupdatewindowsrunloopordering?language=objc)
pub const NSUpdateWindowsRunLoopOrdering: c_uint = 500000;

/// Flags that comprise an application's
/// `presentationOptions.`
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationpresentationoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationPresentationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSApplicationPresentationOptions: NSUInteger {
        #[doc(alias = "NSApplicationPresentationDefault")]
        const Default = 0;
/// Dock appears when moused to.
        #[doc(alias = "NSApplicationPresentationAutoHideDock")]
        const AutoHideDock = 1<<0;
/// Dock is entirely unavailable.
        #[doc(alias = "NSApplicationPresentationHideDock")]
        const HideDock = 1<<1;
/// Menu Bar appears when moused to.
        #[doc(alias = "NSApplicationPresentationAutoHideMenuBar")]
        const AutoHideMenuBar = 1<<2;
/// Menu Bar is entirely unavailable.
        #[doc(alias = "NSApplicationPresentationHideMenuBar")]
        const HideMenuBar = 1<<3;
/// All Apple menu items are disabled.
        #[doc(alias = "NSApplicationPresentationDisableAppleMenu")]
        const DisableAppleMenu = 1<<4;
/// Cmd+Tab UI is disabled.
        #[doc(alias = "NSApplicationPresentationDisableProcessSwitching")]
        const DisableProcessSwitching = 1<<5;
/// Cmd+Opt+Esc panel is disabled.
        #[doc(alias = "NSApplicationPresentationDisableForceQuit")]
        const DisableForceQuit = 1<<6;
/// PowerKey panel and Restart/Shut Down/Log Out disabled.
        #[doc(alias = "NSApplicationPresentationDisableSessionTermination")]
        const DisableSessionTermination = 1<<7;
/// Application "Hide" menu item is disabled.
        #[doc(alias = "NSApplicationPresentationDisableHideApplication")]
        const DisableHideApplication = 1<<8;
/// Menu Bar's transparent appearance is disabled.
        #[doc(alias = "NSApplicationPresentationDisableMenuBarTransparency")]
        const DisableMenuBarTransparency = 1<<9;
/// Application is in fullscreen mode.
        #[doc(alias = "NSApplicationPresentationFullScreen")]
        const FullScreen = 1<<10;
/// Fullscreen window toolbar is detached from window and hides/shows on rollover.
/// May be used only when both
/// `NSApplicationPresentationFullScreen`is also set.
        #[doc(alias = "NSApplicationPresentationAutoHideToolbar")]
        const AutoHideToolbar = 1<<11;
/// "Shake mouse pointer to locate" is disabled for this application.
        #[doc(alias = "NSApplicationPresentationDisableCursorLocationAssistance")]
        const DisableCursorLocationAssistance = 1<<12;
    }
}

unsafe impl Encode for NSApplicationPresentationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationPresentationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationocclusionstate?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationOcclusionState(pub NSUInteger);
bitflags::bitflags! {
    impl NSApplicationOcclusionState: NSUInteger {
/// If set, at least part of any window owned by this application is visible. If not set, all parts of all windows owned by this application are completely occluded. The menu bar does not count as a window owned by this application, so if only the menu bar is showing then the application is considered not visible. Status items, however, have windows owned by your application. If the status item is present in the menu bar, your application will be considered visible as long as the menu bar is visible.
        #[doc(alias = "NSApplicationOcclusionStateVisible")]
        const Visible = 1<<1;
    }
}

unsafe impl Encode for NSApplicationOcclusionState {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationOcclusionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nswindowlistoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSWindowListOptions(pub NSInteger);
bitflags::bitflags! {
    impl NSWindowListOptions: NSInteger {
/// Onscreen application windows in front to back order. By default, -[NSApp windows] is used.
        #[doc(alias = "NSWindowListOrderedFrontToBack")]
        const OrderedFrontToBack = 1<<0;
    }
}

unsafe impl Encode for NSWindowListOptions {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSWindowListOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/_nsmodalsession?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct _NSModalSession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for _NSModalSession {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("_NSModalSession", &[]));
}

/// Information used by the system during modal sessions.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsmodalsession?language=objc)
pub type NSModalSession = *mut _NSModalSession;

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsrequestuserattentiontype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSRequestUserAttentionType(pub NSUInteger);
impl NSRequestUserAttentionType {
    #[doc(alias = "NSCriticalRequest")]
    pub const CriticalRequest: Self = Self(0);
    #[doc(alias = "NSInformationalRequest")]
    pub const InformationalRequest: Self = Self(10);
}

unsafe impl Encode for NSRequestUserAttentionType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSRequestUserAttentionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdelegatereply?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationDelegateReply(pub NSUInteger);
impl NSApplicationDelegateReply {
    #[doc(alias = "NSApplicationDelegateReplySuccess")]
    pub const Success: Self = Self(0);
    #[doc(alias = "NSApplicationDelegateReplyCancel")]
    pub const Cancel: Self = Self(1);
    #[doc(alias = "NSApplicationDelegateReplyFailure")]
    pub const Failure: Self = Self(2);
}

unsafe impl Encode for NSApplicationDelegateReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationDelegateReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplication?language=objc)
    #[unsafe(super(NSResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSResponder")]
    pub struct NSApplication;
);

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
unsafe impl NSAccessibility for NSApplication {}

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
unsafe impl NSAccessibilityElementProtocol for NSApplication {}

#[cfg(feature = "NSResponder")]
unsafe impl NSCoding for NSApplication {}

#[cfg(all(feature = "NSMenu", feature = "NSResponder"))]
unsafe impl NSMenuItemValidation for NSApplication {}

#[cfg(feature = "NSResponder")]
unsafe impl NSObjectProtocol for NSApplication {}

#[cfg(all(feature = "NSResponder", feature = "NSUserInterfaceValidation"))]
unsafe impl NSUserInterfaceValidations for NSApplication {}

extern_methods!(
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[unsafe(method_family(none))]
        #[method_id(sharedApplication)]
        pub fn sharedApplication(mtm: MainThreadMarker) -> Retained<NSApplication>;

        #[unsafe(method_family(none))]
        #[method_id(delegate)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSApplicationDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[method(setDelegate:)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSApplicationDelegate>>);

        #[method(hide:)]
        pub fn hide(&self, sender: Option<&AnyObject>);

        #[method(unhide:)]
        pub unsafe fn unhide(&self, sender: Option<&AnyObject>);

        #[method(unhideWithoutActivation)]
        pub unsafe fn unhideWithoutActivation(&self);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method_family(none))]
        #[method_id(windowWithWindowNumber:)]
        pub unsafe fn windowWithWindowNumber(
            &self,
            window_num: NSInteger,
        ) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[unsafe(method_family(none))]
        #[method_id(mainWindow)]
        pub unsafe fn mainWindow(&self) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[unsafe(method_family(none))]
        #[method_id(keyWindow)]
        pub fn keyWindow(&self) -> Option<Retained<NSWindow>>;

        #[method(isActive)]
        pub unsafe fn isActive(&self) -> bool;

        #[method(isHidden)]
        pub unsafe fn isHidden(&self) -> bool;

        #[method(isRunning)]
        pub unsafe fn isRunning(&self) -> bool;

        #[method(deactivate)]
        pub unsafe fn deactivate(&self);

        /// Makes the receiver the active app.
        /// - Parameter ignoreOtherApps: If `NO`, the app is activated only if no other app is currently active. If `YES`, the app activates regardless.
        #[deprecated = "This method will be deprecated in a future release. Use NSApp.activate instead."]
        #[method(activateIgnoringOtherApps:)]
        pub fn activateIgnoringOtherApps(&self, ignore_other_apps: bool);

        /// Makes the receiver the active app, if possible.
        ///
        /// You shouldn’t assume the app will be active immediately
        /// after sending this message. The framework also does not
        /// guarantee that the app will be activated at all.
        ///
        /// For cooperative activation, the other application should
        /// call `-yieldActivationToApplication:` or equivalent prior
        /// to the target application invoking `-activate`.
        ///
        /// Invoking `-activate` on an already-active application
        /// cancels any pending activation yields by the receiver.
        #[method(activate)]
        pub unsafe fn activate(&self);

        #[cfg(feature = "NSRunningApplication")]
        /// Explicitly allows another application to make itself active.
        ///
        /// Calling this method will not deactivate the current app, nor
        /// will it activate the other app. For cooperative or coordinated
        /// activation, the other app should request to be activated at
        /// some point in the future by calling `activate` or equivalent.
        #[method(yieldActivationToApplication:)]
        pub unsafe fn yieldActivationToApplication(&self, application: &NSRunningApplication);

        /// Same as `-yieldActivationToApplication:`, but the provided
        /// bundle identifier does not have to correspond to a currently
        /// running application.
        ///
        /// This method should be used to yield activation to apps that
        /// may not be running at the time of invoking it. If it is known
        /// that the target application is currently running, use
        /// `-yieldActivationToApplication:` instead.
        #[method(yieldActivationToApplicationWithBundleIdentifier:)]
        pub unsafe fn yieldActivationToApplicationWithBundleIdentifier(
            &self,
            bundle_identifier: &NSString,
        );

        #[method(hideOtherApplications:)]
        pub fn hideOtherApplications(&self, sender: Option<&AnyObject>);

        #[method(unhideAllApplications:)]
        pub unsafe fn unhideAllApplications(&self, sender: Option<&AnyObject>);

        #[method(finishLaunching)]
        pub unsafe fn finishLaunching(&self);

        #[method(run)]
        pub fn run(&self);

        #[cfg(feature = "NSWindow")]
        #[method(runModalForWindow:)]
        pub unsafe fn runModalForWindow(&self, window: &NSWindow) -> NSModalResponse;

        #[method(stop:)]
        pub fn stop(&self, sender: Option<&AnyObject>);

        #[method(stopModal)]
        pub unsafe fn stopModal(&self);

        #[method(stopModalWithCode:)]
        pub unsafe fn stopModalWithCode(&self, return_code: NSModalResponse);

        #[method(abortModal)]
        pub unsafe fn abortModal(&self);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method_family(none))]
        #[method_id(modalWindow)]
        pub unsafe fn modalWindow(&self) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[method(beginModalSessionForWindow:)]
        pub unsafe fn beginModalSessionForWindow(&self, window: &NSWindow) -> NSModalSession;

        #[method(runModalSession:)]
        pub unsafe fn runModalSession(&self, session: NSModalSession) -> NSModalResponse;

        #[method(endModalSession:)]
        pub unsafe fn endModalSession(&self, session: NSModalSession);

        #[method(terminate:)]
        pub unsafe fn terminate(&self, sender: Option<&AnyObject>);

        /// Inform the user that this application needs attention - call this method only if your application is not already active.
        #[method(requestUserAttention:)]
        pub fn requestUserAttention(&self, request_type: NSRequestUserAttentionType) -> NSInteger;

        #[method(cancelUserAttentionRequest:)]
        pub unsafe fn cancelUserAttentionRequest(&self, request: NSInteger);

        #[cfg(all(feature = "NSWindow", feature = "block2"))]
        /// Execute a block for each of the app's windows. Set `*stop = YES` if desired, to halt the enumeration early.
        #[method(enumerateWindowsWithOptions:usingBlock:)]
        pub unsafe fn enumerateWindowsWithOptions_usingBlock(
            &self,
            options: NSWindowListOptions,
            block: &block2::Block<dyn Fn(NonNull<NSWindow>, NonNull<Bool>) + '_>,
        );

        #[method(preventWindowOrdering)]
        pub unsafe fn preventWindowOrdering(&self);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method_family(none))]
        #[method_id(windows)]
        pub fn windows(&self) -> Retained<NSArray<NSWindow>>;

        #[method(setWindowsNeedUpdate:)]
        pub unsafe fn setWindowsNeedUpdate(&self, need_update: bool);

        #[method(updateWindows)]
        pub unsafe fn updateWindows(&self);

        #[cfg(feature = "NSMenu")]
        #[unsafe(method_family(none))]
        #[method_id(mainMenu)]
        pub unsafe fn mainMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`mainMenu`][Self::mainMenu].
        #[method(setMainMenu:)]
        pub fn setMainMenu(&self, main_menu: Option<&NSMenu>);

        #[cfg(feature = "NSMenu")]
        /// Set or get the Help menu for the app.  If a non-nil menu is set as the Help menu, Spotlight for Help will be installed in it; otherwise AppKit will install Spotlight for Help into a menu of its choosing (and that menu is not returned from `-helpMenu`).  If you wish to completely suppress Spotlight for Help, you can set a menu that does not appear in the menu bar.
        /// `NSApplication`retains its Help menu and releases it when a different menu is set.
        #[unsafe(method_family(none))]
        #[method_id(helpMenu)]
        pub unsafe fn helpMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`helpMenu`][Self::helpMenu].
        #[method(setHelpMenu:)]
        pub unsafe fn setHelpMenu(&self, help_menu: Option<&NSMenu>);

        #[cfg(feature = "NSImage")]
        #[unsafe(method_family(none))]
        #[method_id(applicationIconImage)]
        pub unsafe fn applicationIconImage(&self) -> Option<Retained<NSImage>>;

        #[cfg(feature = "NSImage")]
        /// Setter for [`applicationIconImage`][Self::applicationIconImage].
        #[method(setApplicationIconImage:)]
        pub unsafe fn setApplicationIconImage(&self, application_icon_image: Option<&NSImage>);

        #[cfg(feature = "NSRunningApplication")]
        /// Returns: The activation policy of the application.
        #[method(activationPolicy)]
        pub unsafe fn activationPolicy(&self) -> NSApplicationActivationPolicy;

        #[cfg(feature = "NSRunningApplication")]
        /// Attempts to modify the application's activation policy.  In OS X 10.9, any policy may be set; prior to 10.9, the activation policy may be changed to
        /// `NSApplicationActivationPolicyProhibited`or
        /// `NSApplicationActivationPolicyRegular,`but may not be changed to
        /// `NSApplicationActivationPolicyAccessory.`This returns
        /// `YES`if setting the activation policy is successful, and
        /// `NO`if not.
        #[method(setActivationPolicy:)]
        pub fn setActivationPolicy(&self, activation_policy: NSApplicationActivationPolicy)
            -> bool;

        #[cfg(feature = "NSDockTile")]
        #[unsafe(method_family(none))]
        #[method_id(dockTile)]
        pub unsafe fn dockTile(&self) -> Retained<NSDockTile>;

        #[method(reportException:)]
        pub unsafe fn reportException(&self, exception: &NSException);

        #[method(detachDrawingThread:toTarget:withObject:)]
        pub unsafe fn detachDrawingThread_toTarget_withObject(
            selector: Sel,
            target: &AnyObject,
            argument: Option<&AnyObject>,
            mtm: MainThreadMarker,
        );

        /// If an application delegate returns NSTerminateLater from -applicationShouldTerminate:, -replyToApplicationShouldTerminate: must be called with YES or NO once the application decides if it can terminate.
        #[method(replyToApplicationShouldTerminate:)]
        pub unsafe fn replyToApplicationShouldTerminate(&self, should_terminate: bool);

        /// If an application delegate encounters an error while handling `-application:openFiles:` or` -application:printFiles:`, `-replyToOpenOrPrint:` should be called with
        /// `NSApplicationDelegateReplyFailure.`If the user cancels the operation,
        /// `NSApplicationDelegateReplyCancel`should be used, and if the operation succeeds,
        /// `NSApplicationDelegateReplySuccess`should be used .
        #[method(replyToOpenOrPrint:)]
        pub unsafe fn replyToOpenOrPrint(&self, reply: NSApplicationDelegateReply);

        /// Opens the character palette.
        #[method(orderFrontCharacterPalette:)]
        pub fn orderFrontCharacterPalette(&self, sender: Option<&AnyObject>);

        /// Gets or sets the
        /// `presentationOptions`that should be in effect for the system when this application is the active application.  Only certain combinations of
        /// `NSApplicationPresentationOptions`flags are allowed, as detailed in the AppKit Release Notes and the reference documentation for `-setPresentationOptions:`.  When given an invalid combination of option flags, `-setPresentationOptions:` raises an exception.
        #[method(presentationOptions)]
        pub fn presentationOptions(&self) -> NSApplicationPresentationOptions;

        /// Setter for [`presentationOptions`][Self::presentationOptions].
        #[method(setPresentationOptions:)]
        pub fn setPresentationOptions(
            &self,
            presentation_options: NSApplicationPresentationOptions,
        );

        /// Returns: The set of application presentation options that are currently in effect for the system.
        /// These are the presentation options that have been put into effect by the currently active application.
        #[method(currentSystemPresentationOptions)]
        pub unsafe fn currentSystemPresentationOptions(&self) -> NSApplicationPresentationOptions;

        #[method(occlusionState)]
        pub unsafe fn occlusionState(&self) -> NSApplicationOcclusionState;

        #[method(isProtectedDataAvailable)]
        pub unsafe fn isProtectedDataAvailable(&self) -> bool;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSResponder`
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[unsafe(method_family(init))]
        #[method_id(init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method_family(init))]
        #[method_id(initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[unsafe(method_family(new))]
        #[method_id(new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    }
);

extern_methods!(
    /// NSAppearanceCustomization
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSAppearance")]
        #[unsafe(method_family(none))]
        #[method_id(appearance)]
        pub unsafe fn appearance(&self) -> Option<Retained<NSAppearance>>;

        #[cfg(feature = "NSAppearance")]
        /// Setter for [`appearance`][Self::appearance].
        #[method(setAppearance:)]
        pub fn setAppearance(&self, appearance: Option<&NSAppearance>);

        #[cfg(feature = "NSAppearance")]
        #[unsafe(method_family(none))]
        #[method_id(effectiveAppearance)]
        pub fn effectiveAppearance(&self) -> Retained<NSAppearance>;
    }
);

#[cfg(all(feature = "NSAppearance", feature = "NSResponder"))]
unsafe impl NSAppearanceCustomization for NSApplication {}

extern_methods!(
    /// NSEvent
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSEvent")]
        #[method(sendEvent:)]
        pub unsafe fn sendEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[method(postEvent:atStart:)]
        pub fn postEvent_atStart(&self, event: &NSEvent, at_start: bool);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method_family(none))]
        #[method_id(currentEvent)]
        pub fn currentEvent(&self) -> Option<Retained<NSEvent>>;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method_family(none))]
        #[method_id(nextEventMatchingMask:untilDate:inMode:dequeue:)]
        pub unsafe fn nextEventMatchingMask_untilDate_inMode_dequeue(
            &self,
            mask: NSEventMask,
            expiration: Option<&NSDate>,
            mode: &NSRunLoopMode,
            deq_flag: bool,
        ) -> Option<Retained<NSEvent>>;

        #[cfg(feature = "NSEvent")]
        #[method(discardEventsMatchingMask:beforeEvent:)]
        pub unsafe fn discardEventsMatchingMask_beforeEvent(
            &self,
            mask: NSEventMask,
            last_event: Option<&NSEvent>,
        );
    }
);

extern_methods!(
    /// NSResponder
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(sendAction:to:from:)]
        pub unsafe fn sendAction_to_from(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
        ) -> bool;

        #[unsafe(method_family(none))]
        #[method_id(targetForAction:)]
        pub unsafe fn targetForAction(&self, action: Sel) -> Option<Retained<AnyObject>>;

        #[unsafe(method_family(none))]
        #[method_id(targetForAction:to:from:)]
        pub unsafe fn targetForAction_to_from(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
        ) -> Option<Retained<AnyObject>>;

        #[method(tryToPerform:with:)]
        pub unsafe fn tryToPerform_with(&self, action: Sel, object: Option<&AnyObject>) -> bool;

        #[cfg(feature = "NSPasteboard")]
        #[unsafe(method_family(none))]
        #[method_id(validRequestorForSendType:returnType:)]
        pub unsafe fn validRequestorForSendType_returnType(
            &self,
            send_type: Option<&NSPasteboardType>,
            return_type: Option<&NSPasteboardType>,
        ) -> Option<Retained<AnyObject>>;
    }
);

extern_methods!(
    /// NSWindowsMenu
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSMenu")]
        #[unsafe(method_family(none))]
        #[method_id(windowsMenu)]
        pub unsafe fn windowsMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`windowsMenu`][Self::windowsMenu].
        #[method(setWindowsMenu:)]
        pub unsafe fn setWindowsMenu(&self, windows_menu: Option<&NSMenu>);

        #[method(arrangeInFront:)]
        pub unsafe fn arrangeInFront(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSWindow")]
        #[method(removeWindowsItem:)]
        pub unsafe fn removeWindowsItem(&self, win: &NSWindow);

        #[cfg(feature = "NSWindow")]
        #[method(addWindowsItem:title:filename:)]
        pub unsafe fn addWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(feature = "NSWindow")]
        #[method(changeWindowsItem:title:filename:)]
        pub unsafe fn changeWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(feature = "NSWindow")]
        #[method(updateWindowsItem:)]
        pub unsafe fn updateWindowsItem(&self, win: &NSWindow);

        #[method(miniaturizeAll:)]
        pub unsafe fn miniaturizeAll(&self, sender: Option<&AnyObject>);
    }
);

extern_methods!(
    /// NSFullKeyboardAccess
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        /// A Boolean value indicating whether keyboard navigation is enabled in System Settings > Keyboard.
        /// - Note: The value of this property is `YES` if keyboard navigation is enabled or `NO` if it’s not. You might use this value to implement your own key loop or to implement in-control tabbing behavior similar to `NSTableView`. Because of the nature of the preference storage, you won’t be notified of changes to this property if you attempt to observe it through key-value observing; however, accessing this property is fairly inexpensive, so you can access it directly rather than caching it.
        /// - Note: This property’s value isn’t necessarily reflective of the separate accessibility setting named “Full Keyboard Access” in System Settings > Accessibility > Keyboard.
        #[method(isFullKeyboardAccessEnabled)]
        pub unsafe fn isFullKeyboardAccessEnabled(&self) -> bool;
    }
);

/// Return values for `-applicationShouldTerminate:`.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationterminatereply?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationTerminateReply(pub NSUInteger);
impl NSApplicationTerminateReply {
    #[doc(alias = "NSTerminateCancel")]
    pub const TerminateCancel: Self = Self(0);
    #[doc(alias = "NSTerminateNow")]
    pub const TerminateNow: Self = Self(1);
    #[doc(alias = "NSTerminateLater")]
    pub const TerminateLater: Self = Self(2);
}

unsafe impl Encode for NSApplicationTerminateReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationTerminateReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Return values for `-application:printFiles:withSettings:showPrintPanels:`.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationprintreply?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSApplicationPrintReply(pub NSUInteger);
impl NSApplicationPrintReply {
    #[doc(alias = "NSPrintingCancelled")]
    pub const PrintingCancelled: Self = Self(0);
    #[doc(alias = "NSPrintingSuccess")]
    pub const PrintingSuccess: Self = Self(1);
    #[doc(alias = "NSPrintingReplyLater")]
    pub const PrintingReplyLater: Self = Self(2);
    #[doc(alias = "NSPrintingFailure")]
    pub const PrintingFailure: Self = Self(3);
}

unsafe impl Encode for NSApplicationPrintReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationPrintReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdelegate?language=objc)
    pub unsafe trait NSApplicationDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "NSResponder")]
        /// Allowable return values are:
        /// `NSTerminateNow`- it is ok to proceed with termination
        /// `NSTerminateCancel`- the application should not be terminated
        /// `NSTerminateLater`- it may be ok to proceed with termination later.  The application must call `-replyToApplicationShouldTerminate:` with
        /// `YES`or
        /// `NO`once the answer is known
        ///
        /// Note: This return value is for delegates who need to provide document modal alerts (sheets) in order to decide whether to quit.
        #[optional]
        #[method(applicationShouldTerminate:)]
        unsafe fn applicationShouldTerminate(
            &self,
            sender: &NSApplication,
        ) -> NSApplicationTerminateReply;

        #[cfg(feature = "NSResponder")]
        /// This will be called for any URLs your application is asked to open. This includes URL types (CFBundleURLTypes) defined in your Info.plist, and Document types (
        /// `CFBundleDocumentTypes)`that have no associated
        /// `NSDocument`class. Document URLs that have an associated
        /// `NSDocument`class will be opened through
        /// `NSDocumentController.`If this is implemented, `-application:openFiles:` and `-application:openFile:` will not be called.
        #[optional]
        #[method(application:openURLs:)]
        unsafe fn application_openURLs(&self, application: &NSApplication, urls: &NSArray<NSURL>);

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:openFile:)]
        unsafe fn application_openFile(&self, sender: &NSApplication, filename: &NSString) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:openFiles:)]
        unsafe fn application_openFiles(
            &self,
            sender: &NSApplication,
            filenames: &NSArray<NSString>,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:openTempFile:)]
        unsafe fn application_openTempFile(
            &self,
            sender: &NSApplication,
            filename: &NSString,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldOpenUntitledFile:)]
        unsafe fn applicationShouldOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationOpenUntitledFile:)]
        unsafe fn applicationOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        #[optional]
        #[method(application:openFileWithoutUI:)]
        unsafe fn application_openFileWithoutUI(
            &self,
            sender: &AnyObject,
            filename: &NSString,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:printFile:)]
        unsafe fn application_printFile(&self, sender: &NSApplication, filename: &NSString)
            -> bool;

        #[cfg(all(feature = "NSPrintInfo", feature = "NSResponder"))]
        #[optional]
        #[method(application:printFiles:withSettings:showPrintPanels:)]
        unsafe fn application_printFiles_withSettings_showPrintPanels(
            &self,
            application: &NSApplication,
            file_names: &NSArray<NSString>,
            print_settings: &NSDictionary<NSPrintInfoAttributeKey, AnyObject>,
            show_print_panels: bool,
        ) -> NSApplicationPrintReply;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldTerminateAfterLastWindowClosed:)]
        unsafe fn applicationShouldTerminateAfterLastWindowClosed(
            &self,
            sender: &NSApplication,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(applicationShouldHandleReopen:hasVisibleWindows:)]
        unsafe fn applicationShouldHandleReopen_hasVisibleWindows(
            &self,
            sender: &NSApplication,
            has_visible_windows: bool,
        ) -> bool;

        #[cfg(all(feature = "NSMenu", feature = "NSResponder"))]
        #[optional]
        #[unsafe(method_family(none))]
        #[method_id(applicationDockMenu:)]
        unsafe fn applicationDockMenu(&self, sender: &NSApplication) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method_family(none))]
        #[method_id(application:willPresentError:)]
        unsafe fn application_willPresentError(
            &self,
            application: &NSApplication,
            error: &NSError,
        ) -> Retained<NSError>;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didRegisterForRemoteNotificationsWithDeviceToken:)]
        unsafe fn application_didRegisterForRemoteNotificationsWithDeviceToken(
            &self,
            application: &NSApplication,
            device_token: &NSData,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didFailToRegisterForRemoteNotificationsWithError:)]
        unsafe fn application_didFailToRegisterForRemoteNotificationsWithError(
            &self,
            application: &NSApplication,
            error: &NSError,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[method(application:didReceiveRemoteNotification:)]
        unsafe fn application_didReceiveRemoteNotification(
            &self,
            application: &NSApplication,
            user_info: &NSDictionary<NSString, AnyObject>,
        );

        #[cfg(feature = "NSResponder")]
        /// Method to opt-in to secure restorable state.
        ///
        /// When this returns
        /// `YES:`NSCoders that are passed into the various
        /// `NSWindowRestoration`methods will
        /// `requiresSecureCoding`and have a
        /// `decodingFailurePolicy`of
        /// `NSDecodingFailurePolicySetErrorAndReturn.`Any
        /// `restorationClass`set on a window must explicitly conform to
        /// `NSWindowRestoration.`This method will be called prior to any state encoding or restoration.
        #[optional]
        #[method(applicationSupportsSecureRestorableState:)]
        unsafe fn applicationSupportsSecureRestorableState(&self, app: &NSApplication) -> bool;

        #[cfg(feature = "NSResponder")]
        /// Method called by `-[NSApplication encodeRestorableStateWithCoder:]` to give the delegate a chance to encode any additional state into the
        /// `NSCoder.`If the restorable state managed by the delegate changes, you must call `-[NSApplication invalidateRestorableState]` so that it will be re-encoded. See the header `NSWindowRestoration.h` for more information.
        #[optional]
        #[method(application:willEncodeRestorableState:)]
        unsafe fn application_willEncodeRestorableState(
            &self,
            app: &NSApplication,
            coder: &NSCoder,
        );

        #[cfg(feature = "NSResponder")]
        /// Method called by `-[NSApplication restoreStateWithCoder:]` to give the delegate a chance to restore its own state, which it may decode from the
        /// `NSCoder.`See the header `NSWindowRestoration.h` for more information.
        #[optional]
        #[method(application:didDecodeRestorableState:)]
        unsafe fn application_didDecodeRestorableState(&self, app: &NSApplication, coder: &NSCoder);

        #[cfg(feature = "NSResponder")]
        /// This will be called on the main thread as soon as the user indicates they want to continue an activity in your application. The
        /// `NSUserActivity`object may not be available instantly, so use this as an opportunity to show the user that an activity will be continued shortly. Return
        /// `YES`to indicate that you are doing so. Return
        /// `NO`(or leave it unimplemented) and AppKit/UIKit will put up a default UI.
        ///
        /// For each `-application:willContinueUserActivityWithType:` invocation, you are guaranteed to get exactly one invocation of `-application:continueUserActivity:restorationHandler:` on success, or `-application:didFailToContinueUserActivityWithType:error:` if an error was encountered.
        #[optional]
        #[method(application:willContinueUserActivityWithType:)]
        unsafe fn application_willContinueUserActivityWithType(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
        ) -> bool;

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSUserActivity",
            feature = "block2"
        ))]
        /// This will be called on the main thread after the
        /// `NSUserActivity`object is available. Use the data you stored in the NSUserActivity object to re-create what the user was doing.
        ///
        ///
        /// Returns: `YES`to indicate that the activity was handled. Return
        /// `NO`(or leave it unimplemented) and AppKit will attempt to continue the user activity.
        ///
        /// You should create/fetch any restorable objects associated with the user activity, and pass them to the restorationHandler. They will then get the above `-restoreUserActivityState:` method invoked with the user activity. Invoking the
        /// `restorationHandler`is optional. It may be copied and invoked later, but must be invoked on the main thread.
        ///
        /// If this user activity was created automatically by having
        /// `NSUbiquitousDocumentUserActivityType`in a
        /// `CFBundleDocumentTypes`entry, AppKit can automatically restore the NSUserActivity on OS X if NO is returned, or this method is unimplemented. It will do so by creating a document of the appropriate type using the URL stored in the userInfo under the
        /// `NSUserActivityDocumentURLKey.`The document will have `-restoreUserActivity:` called on it.
        #[optional]
        #[method(application:continueUserActivity:restorationHandler:)]
        unsafe fn application_continueUserActivity_restorationHandler(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
            restoration_handler: &block2::Block<
                dyn Fn(NonNull<NSArray<ProtocolObject<dyn NSUserActivityRestoring>>>),
            >,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        /// There are instances where continuing a
        /// `NSUserActivity`may fail. This will get called on the main thread if it does so. If it is unimplemented, AppKit will present the error.
        #[optional]
        #[method(application:didFailToContinueUserActivityWithType:error:)]
        unsafe fn application_didFailToContinueUserActivityWithType_error(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
            error: &NSError,
        );

        #[cfg(feature = "NSResponder")]
        /// This will be called on the main thread when a user activity managed by AppKit/UIKit has been updated. You should use this as a last chance to add additional data to the
        /// `userActivity.`
        #[optional]
        #[method(application:didUpdateUserActivity:)]
        unsafe fn application_didUpdateUserActivity(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
        );

        #[cfg(all(feature = "NSResponder", feature = "objc2-cloud-kit"))]
        #[cfg(target_vendor = "apple")]
        /// This will be called on the main thread after the user indicates they want to accept a CloudKit sharing invitation in your application.
        ///
        /// You should use the
        /// `CKShareMetadata`object's
        /// `shareURL`and containerIdentifier to schedule a
        /// `CKAcceptSharesOperation,`then start using the resulting
        /// `CKShare`and its associated record(s), which will appear in the
        /// `CKContainer's`shared database in a zone matching that of the record's owner.
        #[optional]
        #[method(application:userDidAcceptCloudKitShareWithMetadata:)]
        unsafe fn application_userDidAcceptCloudKitShareWithMetadata(
            &self,
            application: &NSApplication,
            metadata: &CKShareMetadata,
        );

        #[cfg(feature = "NSResponder")]
        /// Returns: `YES`if the receiving delegate object can respond to key value coding messages for a specific keyed attribute, to-one relationship, or to-many relationship.  Return
        /// `NO`otherwise.
        #[optional]
        #[method(application:delegateHandlesKey:)]
        unsafe fn application_delegateHandlesKey(
            &self,
            sender: &NSApplication,
            key: &NSString,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        /// This method will be called once during application launch at `-[NSApplication finishLaunching]`.
        ///
        ///
        /// Returns: `NO`if the receiving delegate object wishes to opt-out of system-wide keyboard shortcut localization for all application-supplied menus. Return
        /// `YES`by default for apps linked against 12.0 and later SDK.
        #[optional]
        #[method(applicationShouldAutomaticallyLocalizeKeyEquivalents:)]
        unsafe fn applicationShouldAutomaticallyLocalizeKeyEquivalents(
            &self,
            application: &NSApplication,
        ) -> bool;

        #[optional]
        #[method(applicationWillFinishLaunching:)]
        unsafe fn applicationWillFinishLaunching(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidFinishLaunching:)]
        unsafe fn applicationDidFinishLaunching(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillHide:)]
        unsafe fn applicationWillHide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidHide:)]
        unsafe fn applicationDidHide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillUnhide:)]
        unsafe fn applicationWillUnhide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidUnhide:)]
        unsafe fn applicationDidUnhide(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillBecomeActive:)]
        unsafe fn applicationWillBecomeActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidBecomeActive:)]
        unsafe fn applicationDidBecomeActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillResignActive:)]
        unsafe fn applicationWillResignActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidResignActive:)]
        unsafe fn applicationDidResignActive(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillUpdate:)]
        unsafe fn applicationWillUpdate(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidUpdate:)]
        unsafe fn applicationDidUpdate(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationWillTerminate:)]
        unsafe fn applicationWillTerminate(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidChangeScreenParameters:)]
        unsafe fn applicationDidChangeScreenParameters(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationDidChangeOcclusionState:)]
        unsafe fn applicationDidChangeOcclusionState(&self, notification: &NSNotification);

        #[optional]
        #[method(applicationProtectedDataWillBecomeUnavailable:)]
        unsafe fn applicationProtectedDataWillBecomeUnavailable(
            &self,
            notification: &NSNotification,
        );

        #[optional]
        #[method(applicationProtectedDataDidBecomeAvailable:)]
        unsafe fn applicationProtectedDataDidBecomeAvailable(&self, notification: &NSNotification);
    }
);

extern_methods!(
    /// NSServicesMenu
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSMenu")]
        #[unsafe(method_family(none))]
        #[method_id(servicesMenu)]
        pub unsafe fn servicesMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`servicesMenu`][Self::servicesMenu].
        #[method(setServicesMenu:)]
        pub unsafe fn setServicesMenu(&self, services_menu: Option<&NSMenu>);

        #[cfg(feature = "NSPasteboard")]
        #[method(registerServicesMenuSendTypes:returnTypes:)]
        pub unsafe fn registerServicesMenuSendTypes_returnTypes(
            &self,
            send_types: &NSArray<NSPasteboardType>,
            return_types: &NSArray<NSPasteboardType>,
        );
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsservicesmenurequestor?language=objc)
    pub unsafe trait NSServicesMenuRequestor: NSObjectProtocol {
        #[cfg(feature = "NSPasteboard")]
        #[optional]
        #[method(writeSelectionToPasteboard:types:)]
        unsafe fn writeSelectionToPasteboard_types(
            &self,
            pboard: &NSPasteboard,
            types: &NSArray<NSPasteboardType>,
        ) -> bool;

        #[cfg(feature = "NSPasteboard")]
        #[optional]
        #[method(readSelectionFromPasteboard:)]
        unsafe fn readSelectionFromPasteboard(&self, pboard: &NSPasteboard) -> bool;
    }
);

extern_methods!(
    /// NSServicesHandling
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[unsafe(method_family(none))]
        #[method_id(servicesProvider)]
        pub unsafe fn servicesProvider(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`servicesProvider`][Self::servicesProvider].
        #[method(setServicesProvider:)]
        pub unsafe fn setServicesProvider(&self, services_provider: Option<&AnyObject>);
    }
);

/// Optional keys in `-orderFrontStandardAboutPanelWithOptions:`
/// `optionsDictionary.`
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsaboutpaneloptionkey?language=objc)
// NS_TYPED_ENUM
pub type NSAboutPanelOptionKey = NSString;

extern "C" {
    /// NSAttributedString displayed in the info area of the panel. If not specified, contents obtained from "Credits.rtf" (.rtfd, .html) in [NSBundle mainBundle]; if not available, blank. Note that  in applications built against the 10.14 SDK or earlier, the credits are shown in light appearance even when the application is running in dark appearance, except when the credits are specified as an attributed string, or come from a file are the text is just pure black. In applications built against the 10.15 SDK or newer, credits will be shown in dark appearance, using the "adaptive color mapping" setting in NSTextView.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsaboutpaneloptioncredits?language=objc)
    pub static NSAboutPanelOptionCredits: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// NSString displayed in place of the default app name. If not specified, uses the value of CFBundleName (localizable). Fallback is [[NSProcessInfo processInfo] processName].
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsaboutpaneloptionapplicationname?language=objc)
    pub static NSAboutPanelOptionApplicationName: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// NSImage displayed in place of NSApplicationIcon. If not specified, use [NSImage imageNamed:
    /// "
    /// NSApplicationIcon"]; if not available, generic icon.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsaboutpaneloptionapplicationicon?language=objc)
    pub static NSAboutPanelOptionApplicationIcon: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// NSString containing the build version number of the application ("58.4", "1.2d3"); displayed as "Version 58.4" or "Version 1.0 (58.4) depending on the presence of ApplicationVersion. If not specified, obtain from the CFBundleVersion key in infoDictionary; if not specified or empty string, leave blank.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsaboutpaneloptionversion?language=objc)
    pub static NSAboutPanelOptionVersion: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// NSString displayed as the marketing version  ("1.0", "Mac OS X", "3", "WebObjects 3.5", ...), before the build version. If not specified, obtain from CFBundleShortVersionString key in infoDictionary. Prefixed with word "Version" if it looks like a number.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsaboutpaneloptionapplicationversion?language=objc)
    pub static NSAboutPanelOptionApplicationVersion: &'static NSAboutPanelOptionKey;
}

extern_methods!(
    /// NSStandardAboutPanel
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(orderFrontStandardAboutPanel:)]
        pub unsafe fn orderFrontStandardAboutPanel(&self, sender: Option<&AnyObject>);

        #[method(orderFrontStandardAboutPanelWithOptions:)]
        pub unsafe fn orderFrontStandardAboutPanelWithOptions(
            &self,
            options_dictionary: &NSDictionary<NSAboutPanelOptionKey, AnyObject>,
        );
    }
);

extern_methods!(
    /// NSApplicationLayoutDirection
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSUserInterfaceLayout")]
        #[method(userInterfaceLayoutDirection)]
        pub unsafe fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;
    }
);

extern_methods!(
    /// NSRestorableUserInterface
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        /// Disable or reenable relaunching this app on login, if the app was running at the time the user logged out.  These methods increment and decrement a counter respectively; if the counter is 0 at the time the user logs out, then the app may be relaunched when the user logs back in.  The counter is initially zero, so by default apps are relaunched.
        ///
        /// If your app should not be relaunched because it launches via some other mechanism (e.g. launchd), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` once, and never pair it with an -enable call.
        ///
        /// If your app should not be relaunched because it triggers a restart (e.g. an installer), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` immediately before you attempt to trigger a restart, and `-[NSApp enableRelaunchOnLogin]` immediately after.  This is because the user may cancel restarting; if the user later restarts for another reason, then your app should be brought back.
        ///
        /// These methods are thread safe.
        #[method(disableRelaunchOnLogin)]
        pub unsafe fn disableRelaunchOnLogin(&self);

        #[method(enableRelaunchOnLogin)]
        pub unsafe fn enableRelaunchOnLogin(&self);
    }
);

/// Soft deprecated.
/// Please use `NSApplication`'s `-registerForRemoteNotifications` along with `-requestAuthorizationWithOptions:` from the `UserNotifications.framework` to specify allowable notification types.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsremotenotificationtype?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSRemoteNotificationType(pub NSUInteger);
bitflags::bitflags! {
    impl NSRemoteNotificationType: NSUInteger {
        #[doc(alias = "NSRemoteNotificationTypeNone")]
        const None = 0;
        #[doc(alias = "NSRemoteNotificationTypeBadge")]
        const Badge = 1<<0;
        #[doc(alias = "NSRemoteNotificationTypeSound")]
        const Sound = 1<<1;
        #[doc(alias = "NSRemoteNotificationTypeAlert")]
        const Alert = 1<<2;
    }
}

unsafe impl Encode for NSRemoteNotificationType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSRemoteNotificationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_methods!(
    /// NSRemoteNotifications
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[method(registerForRemoteNotifications)]
        pub unsafe fn registerForRemoteNotifications(&self);

        #[method(unregisterForRemoteNotifications)]
        pub unsafe fn unregisterForRemoteNotifications(&self);

        /// Returns: `YES`if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn't relate to connectivity.
        #[method(isRegisteredForRemoteNotifications)]
        pub unsafe fn isRegisteredForRemoteNotifications(&self) -> bool;

        /// The following are soft deprecated.
        /// Please use the `-registerForRemoteNotifications` above and `-requestAuthorizationWithOptions:` from `UserNotifications.framework`.
        #[method(registerForRemoteNotificationTypes:)]
        pub unsafe fn registerForRemoteNotificationTypes(&self, types: NSRemoteNotificationType);

        #[method(enabledRemoteNotificationTypes)]
        pub unsafe fn enabledRemoteNotificationTypes(&self) -> NSRemoteNotificationType;
    }
);

extern "C-unwind" {
    /// An Application's startup function.
    pub fn NSApplicationMain(argc: c_int, argv: NonNull<NonNull<c_char>>) -> c_int;
}

/// `NSApplicationLoad`should be called when loading a Cocoa bundle in a Carbon app in order to initialize
/// `NSApplication`and other Cocoa objects.  Redundant calls are ignored.
#[inline]
pub unsafe extern "C-unwind" fn NSApplicationLoad() -> bool {
    extern "C-unwind" {
        fn NSApplicationLoad() -> Bool;
    }
    unsafe { NSApplicationLoad() }.as_bool()
}

/// `NSShowsServicesMenuItem()`always returns
/// `YES.`
#[inline]
pub unsafe extern "C-unwind" fn NSShowsServicesMenuItem(item_name: &NSString) -> bool {
    extern "C-unwind" {
        fn NSShowsServicesMenuItem(item_name: &NSString) -> Bool;
    }
    unsafe { NSShowsServicesMenuItem(item_name) }.as_bool()
}

/// `NSSetShowsServicesMenuItem()`has no effect, and always returns 0.
#[inline]
pub unsafe extern "C-unwind" fn NSSetShowsServicesMenuItem(
    item_name: &NSString,
    enabled: bool,
) -> NSInteger {
    extern "C-unwind" {
        fn NSSetShowsServicesMenuItem(item_name: &NSString, enabled: Bool) -> NSInteger;
    }
    unsafe { NSSetShowsServicesMenuItem(item_name, Bool::new(enabled)) }
}

extern "C-unwind" {
    /// `NSUpdateDynamicServices()`causes the services information for the system to be updated.
    /// This will only be necessary if your program adds dynamic services to the system (i.e. services not found in mach-o segments of executables).
    pub fn NSUpdateDynamicServices();
}

#[cfg(feature = "NSPasteboard")]
#[inline]
pub unsafe extern "C-unwind" fn NSPerformService(
    item_name: &NSString,
    pboard: Option<&NSPasteboard>,
) -> bool {
    extern "C-unwind" {
        fn NSPerformService(item_name: &NSString, pboard: Option<&NSPasteboard>) -> Bool;
    }
    unsafe { NSPerformService(item_name, pboard) }.as_bool()
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsserviceprovidername?language=objc)
pub type NSServiceProviderName = NSString;

extern "C-unwind" {
    /// Apps should use -setServicesProvider.
    pub fn NSRegisterServicesProvider(provider: Option<&AnyObject>, name: &NSServiceProviderName);
}

extern "C-unwind" {
    pub fn NSUnregisterServicesProvider(name: &NSServiceProviderName);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidbecomeactivenotification?language=objc)
    pub static NSApplicationDidBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidhidenotification?language=objc)
    pub static NSApplicationDidHideNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidfinishlaunchingnotification?language=objc)
    pub static NSApplicationDidFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidresignactivenotification?language=objc)
    pub static NSApplicationDidResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidunhidenotification?language=objc)
    pub static NSApplicationDidUnhideNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidupdatenotification?language=objc)
    pub static NSApplicationDidUpdateNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationwillbecomeactivenotification?language=objc)
    pub static NSApplicationWillBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationwillhidenotification?language=objc)
    pub static NSApplicationWillHideNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationwillfinishlaunchingnotification?language=objc)
    pub static NSApplicationWillFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationwillresignactivenotification?language=objc)
    pub static NSApplicationWillResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationwillunhidenotification?language=objc)
    pub static NSApplicationWillUnhideNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationwillupdatenotification?language=objc)
    pub static NSApplicationWillUpdateNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationwillterminatenotification?language=objc)
    pub static NSApplicationWillTerminateNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidchangescreenparametersnotification?language=objc)
    pub static NSApplicationDidChangeScreenParametersNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationprotecteddatawillbecomeunavailablenotification?language=objc)
    pub static NSApplicationProtectedDataWillBecomeUnavailableNotification:
        &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationprotecteddatadidbecomeavailablenotification?language=objc)
    pub static NSApplicationProtectedDataDidBecomeAvailableNotification:
        &'static NSNotificationName;
}

extern "C" {
    /// The following key is present in the userInfo of NSApplicationDidFinishLaunchingNotification.  Its value is an NSNumber containing a bool.  It will be NO if the app was launched to open or print a file, to perform a Service, if the app had saved state that will be restored, or if the app launch was in some other sense not a "default" launch.  Otherwise its value will be YES.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationlaunchisdefaultlaunchkey?language=objc)
    pub static NSApplicationLaunchIsDefaultLaunchKey: &'static NSString;
}

extern "C" {
    /// The following key is present in the userInfo of NSApplicationDidFinishLaunchingNotification. It will be present if your application was launched because a user activated a notification in the Notification Center. Its value is an NSUserNotification object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationlaunchusernotificationkey?language=objc)
    pub static NSApplicationLaunchUserNotificationKey: &'static NSString;
}

extern "C" {
    /// NSApplicationLaunchRemoteNotificationKey is unimplemented.  Please use NSApplicationLaunchUserNotificationKey to get the NSUserNotification object.  The NSUserNotification object has an isRemote property to indicate whether this application was launched as a result of a remote notification
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationlaunchremotenotificationkey?language=objc)
    pub static NSApplicationLaunchRemoteNotificationKey: &'static NSString;
}

extern "C" {
    /// Upon receiving this notification, you can query the NSApplication for its occlusion state. Note that this only notifies about changes in the state of the occlusion, not when the occlusion region changes. You can use this notification to increase responsiveness and save power, by halting any expensive calculations that the user can not see.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidchangeocclusionstatenotification?language=objc)
    pub static NSApplicationDidChangeOcclusionStateNotification: &'static NSNotificationName;
}

/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsrunstoppedresponse?language=objc)
#[deprecated = "Use NSModalResponseStop instead"]
pub const NSRunStoppedResponse: c_int = -1000;
/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsrunabortedresponse?language=objc)
#[deprecated = "Use NSModalResponseAbort instead"]
pub const NSRunAbortedResponse: c_int = -1001;
/// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsruncontinuesresponse?language=objc)
#[deprecated = "Use NSModalResponseContinue instead"]
pub const NSRunContinuesResponse: c_int = -1002;

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "NSResponder")]
    unsafe impl NSApplication {
        #[cfg(feature = "NSWindow")]
        /// `-runModalForWindow:relativeToWindow:` was deprecated in Mac OS X 10.0. Please use `-[NSWindow beginSheet:completionHandler:]` instead.
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(runModalForWindow:relativeToWindow:)]
        pub unsafe fn runModalForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSInteger;

        #[cfg(feature = "NSWindow")]
        /// `-beginModalSessionForWindow:relativeToWindow:` was deprecated in Mac OS X 10.0. Please use `-[NSWindow beginSheet:completionHandler:]` instead.
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(beginModalSessionForWindow:relativeToWindow:)]
        pub unsafe fn beginModalSessionForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSModalSession;

        /// `-application:printFiles:` was deprecated in Mac OS X 10.4.
        /// Implement `-application:printFiles:withSettings:showPrintPanels:` in your application delegate instead.
        #[deprecated]
        #[method(application:printFiles:)]
        pub unsafe fn application_printFiles(
            &self,
            sender: Option<&NSApplication>,
            filenames: Option<&NSArray<NSString>>,
        );

        #[cfg(feature = "NSWindow")]
        /// `NSWindow`'s `-beginSheet:completionHandler:` and `-endSheet:returnCode:` should be used instead.  `NSApplication`'s `-beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:` will continue to work as it previously did, leaking contextInfo and failing when there is already an existing sheet.
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:)]
        pub unsafe fn beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo(
            &self,
            sheet: &NSWindow,
            doc_window: &NSWindow,
            modal_delegate: Option<&AnyObject>,
            did_end_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:] instead"]
        #[method(endSheet:)]
        pub unsafe fn endSheet(&self, sheet: &NSWindow);

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:returnCode:] instead"]
        #[method(endSheet:returnCode:)]
        pub unsafe fn endSheet_returnCode(&self, sheet: &NSWindow, return_code: NSInteger);

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -enumerateWindowsWithOptions:usingBlock: instead"]
        #[unsafe(method_family(none))]
        #[method_id(makeWindowsPerform:inOrder:)]
        pub unsafe fn makeWindowsPerform_inOrder(
            &self,
            selector: Sel,
            in_order: bool,
        ) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSGraphicsContext")]
        /// This method is deprecated as of macOS 10.12. Beginning in OS X 10.11 it would always return nil. Prior to this it would return an undefined graphics context that was not generally suitable for drawing.
        #[deprecated = "This method always returns nil. If you need access to the current drawing context, use [NSGraphicsContext currentContext] inside of a draw operation."]
        #[unsafe(method_family(none))]
        #[method_id(context)]
        pub unsafe fn context(&self) -> Option<Retained<NSGraphicsContext>>;
    }
);
