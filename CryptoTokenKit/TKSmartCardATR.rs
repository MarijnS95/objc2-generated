//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Bitmask of available SmartCard protocols.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardprotocol?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TKSmartCardProtocol(pub NSUInteger);
bitflags::bitflags! {
    impl TKSmartCardProtocol: NSUInteger {
        #[doc(alias = "TKSmartCardProtocolNone")]
        const None = 0;
        #[doc(alias = "TKSmartCardProtocolT0")]
        const T0 = 1<<0;
        #[doc(alias = "TKSmartCardProtocolT1")]
        const T1 = 1<<1;
        #[doc(alias = "TKSmartCardProtocolT15")]
        const T15 = 1<<15;
        #[doc(alias = "TKSmartCardProtocolAny")]
        const Any = (1<<16)-1;
    }
}

unsafe impl Encode for TKSmartCardProtocol {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardProtocol {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Represents single interface-bytes group of ATR.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardatrinterfacegroup?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardATRInterfaceGroup;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardATRInterfaceGroup {}
);

impl TKSmartCardATRInterfaceGroup {
    extern_methods!(
        /// TA interface byte of ATR group, or nil if TA is not present.
        #[unsafe(method(TA))]
        #[unsafe(method_family = none)]
        pub unsafe fn TA(&self) -> Option<Retained<NSNumber>>;

        /// TB interface byte of ATR group, or nil if TB is not present.
        #[unsafe(method(TB))]
        #[unsafe(method_family = none)]
        pub unsafe fn TB(&self) -> Option<Retained<NSNumber>>;

        /// TC interface byte of ATR group, or nil if TC is not present.
        #[unsafe(method(TC))]
        #[unsafe(method_family = none)]
        pub unsafe fn TC(&self) -> Option<Retained<NSNumber>>;

        /// Protocol number for this group.  First group (global) has protocol unassigned, contains nil.
        #[unsafe(method(protocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocol(&self) -> Option<Retained<NSNumber>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardATRInterfaceGroup {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Represents parsed SmartCard ATR.  Provides routine for parsing byte stream or NSData with binary ATR and accessors to parsed ATR parts.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardatr?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardATR;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardATR {}
);

impl TKSmartCardATR {
    extern_methods!(
        /// Parses ATR from binary data block
        ///
        /// Parameter `bytes`: Data containing full valid ATR
        ///
        /// Returns: Parsed ATR instance, or nil when #bytes do not contain valid ATR.
        #[unsafe(method(initWithBytes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytes(
            this: Allocated<Self>,
            bytes: &NSData,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "block2")]
        /// Parses ATR from stream.
        ///
        /// Parameter `source`: Provides one byte of ATR from the stream or -1 in case of an error
        ///
        /// Returns: Parsed ATR instance, or nil when #source method failed or an invalid ATR is detected
        #[unsafe(method(initWithSource:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSource(
            this: Allocated<Self>,
            source: &block2::DynBlock<dyn Fn() -> c_int>,
        ) -> Option<Retained<Self>>;

        /// Full ATR as string of bytes
        #[unsafe(method(bytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn bytes(&self) -> Retained<NSData>;

        /// Array of NSNumber of protocols indicated in ATR, in the correct order (i.e. the default protocol comes first), duplicates sorted out.
        #[unsafe(method(protocols))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocols(&self) -> Retained<NSArray<NSNumber>>;

        /// Retrieves interface group with specified index.
        ///
        /// Parameter `index`: Index of the requested interface group.  Indexing conforms to ISO7816-3, i.e. starts from 1.
        ///
        /// Returns: Interface group with given index, or nil of no such group was present.
        #[unsafe(method(interfaceGroupAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn interfaceGroupAtIndex(
            &self,
            index: NSInteger,
        ) -> Option<Retained<TKSmartCardATRInterfaceGroup>>;

        /// Parameter `protocol`: Protocol number for which the interface group is requested.
        #[unsafe(method(interfaceGroupForProtocol:))]
        #[unsafe(method_family = none)]
        pub unsafe fn interfaceGroupForProtocol(
            &self,
            protocol: TKSmartCardProtocol,
        ) -> Option<Retained<TKSmartCardATRInterfaceGroup>>;

        /// Just historical bytes of ATR, without Tck and interface bytes.
        #[unsafe(method(historicalBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn historicalBytes(&self) -> Retained<NSData>;

        #[cfg(feature = "TKTLVRecord")]
        /// An array of TKCompactTLVRecord instances with TLV records parsed from historical bytes.  If historical bytes are
        /// not structured using Compact TLV encoding, nil is returned.
        ///
        /// Note: In case that ATR historical bytes begin with 0x00, the last three bytes (status indicator) are automatically
        /// appended into the returned records as if historical bytes would begin with 0x80 and 0x8 record is present
        /// in historical bytes.
        #[unsafe(method(historicalRecords))]
        #[unsafe(method_family = none)]
        pub unsafe fn historicalRecords(&self) -> Option<Retained<NSArray<TKCompactTLVRecord>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardATR {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
