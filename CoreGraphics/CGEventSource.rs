//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "CGEventTypes")]
unsafe impl ConcreteType for CGEventSource {
    #[doc(alias = "CGEventSourceGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGEventSourceGetTypeID() -> CFTypeID;
        }
        unsafe { CGEventSourceGetTypeID() }
    }
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventSourceCreate(
    state_id: CGEventSourceStateID,
) -> Option<CFRetained<CGEventSource>> {
    extern "C-unwind" {
        fn CGEventSourceCreate(state_id: CGEventSourceStateID) -> *mut CGEventSource;
    }
    let ret = unsafe { CGEventSourceCreate(state_id) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceGetKeyboardType(
        source: Option<&CGEventSource>,
    ) -> CGEventSourceKeyboardType;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceSetKeyboardType(
        source: Option<&CGEventSource>,
        keyboard_type: CGEventSourceKeyboardType,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceGetPixelsPerLine(source: Option<&CGEventSource>) -> c_double;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceSetPixelsPerLine(source: Option<&CGEventSource>, pixels_per_line: c_double);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceGetSourceStateID(source: Option<&CGEventSource>) -> CGEventSourceStateID;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceButtonState(state_id: CGEventSourceStateID, button: CGMouseButton) -> bool;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
    pub fn CGEventSourceKeyState(state_id: CGEventSourceStateID, key: CGKeyCode) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceFlagsState(state_id: CGEventSourceStateID) -> CGEventFlags;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceSecondsSinceLastEventType(
        state_id: CGEventSourceStateID,
        event_type: CGEventType,
    ) -> CFTimeInterval;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceCounterForEventType(
        state_id: CGEventSourceStateID,
        event_type: CGEventType,
    ) -> u32;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceSetUserData(source: Option<&CGEventSource>, user_data: i64);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceGetUserData(source: Option<&CGEventSource>) -> i64;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
    pub fn CGEventSourceSetLocalEventsFilterDuringSuppressionState(
        source: Option<&CGEventSource>,
        filter: CGEventFilterMask,
        state: CGEventSuppressionState,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
    pub fn CGEventSourceGetLocalEventsFilterDuringSuppressionState(
        source: Option<&CGEventSource>,
        state: CGEventSuppressionState,
    ) -> CGEventFilterMask;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceSetLocalEventsSuppressionInterval(
        source: Option<&CGEventSource>,
        seconds: CFTimeInterval,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSourceGetLocalEventsSuppressionInterval(
        source: Option<&CGEventSource>,
    ) -> CFTimeInterval;
}
