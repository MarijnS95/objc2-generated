//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpointzero?language=objc)
    pub static CGPointZero: CGPoint;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgsizezero?language=objc)
    pub static CGSizeZero: CGSize;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectzero?language=objc)
    pub static CGRectZero: CGRect;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectnull?language=objc)
    pub static CGRectNull: CGRect;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectinfinite?language=objc)
    pub static CGRectInfinite: CGRect;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

extern "C-unwind" {
    pub fn CGRectGetMinX(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMidX(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMaxX(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMinY(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMidY(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMaxY(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetWidth(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetHeight(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGPointEqualToPoint(point1: CGPoint, point2: CGPoint) -> bool;
}

extern "C-unwind" {
    pub fn CGSizeEqualToSize(size1: CGSize, size2: CGSize) -> bool;
}

extern "C-unwind" {
    pub fn CGRectEqualToRect(rect1: CGRect, rect2: CGRect) -> bool;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectStandardize(rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    pub fn CGRectIsEmpty(rect: CGRect) -> bool;
}

extern "C-unwind" {
    pub fn CGRectIsNull(rect: CGRect) -> bool;
}

extern "C-unwind" {
    pub fn CGRectIsInfinite(rect: CGRect) -> bool;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectInset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectIntegral(rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectUnion(r1: CGRect, r2: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectIntersection(r1: CGRect, r2: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectOffset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
}

extern "C-unwind" {
    pub fn CGRectDivide(
        rect: CGRect,
        slice: NonNull<CGRect>,
        remainder: NonNull<CGRect>,
        amount: CGFloat,
        edge: CGRectEdge,
    );
}

extern "C-unwind" {
    pub fn CGRectContainsPoint(rect: CGRect, point: CGPoint) -> bool;
}

extern "C-unwind" {
    pub fn CGRectContainsRect(rect1: CGRect, rect2: CGRect) -> bool;
}

extern "C-unwind" {
    pub fn CGRectIntersectsRect(rect1: CGRect, rect2: CGRect) -> bool;
}

extern "C-unwind" {
    /// * Persistent representations. **
    pub fn CGPointCreateDictionaryRepresentation(point: CGPoint) -> CFDictionaryRef;
}

extern "C-unwind" {
    pub fn CGPointMakeWithDictionaryRepresentation(
        dict: CFDictionaryRef,
        point: *mut CGPoint,
    ) -> bool;
}

extern "C-unwind" {
    pub fn CGSizeCreateDictionaryRepresentation(size: CGSize) -> CFDictionaryRef;
}

extern "C-unwind" {
    pub fn CGSizeMakeWithDictionaryRepresentation(dict: CFDictionaryRef, size: *mut CGSize)
        -> bool;
}

extern "C-unwind" {
    pub fn CGRectCreateDictionaryRepresentation(_: CGRect) -> CFDictionaryRef;
}

extern "C-unwind" {
    pub fn CGRectMakeWithDictionaryRepresentation(dict: CFDictionaryRef, rect: *mut CGRect)
        -> bool;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

// TODO: pub fn __CGPointEqualToPoint(point1: CGPoint,point2: CGPoint,) -> bool;

// TODO: pub fn __CGSizeEqualToSize(size1: CGSize,size2: CGSize,) -> bool;
