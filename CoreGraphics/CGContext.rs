//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcontextref?language=objc)
pub type CGContextRef = *mut c_void;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGPathDrawingMode(pub i32);
impl CGPathDrawingMode {
    pub const kCGPathFill: Self = Self(0);
    pub const kCGPathEOFill: Self = Self(1);
    pub const kCGPathStroke: Self = Self(2);
    pub const kCGPathFillStroke: Self = Self(3);
    pub const kCGPathEOFillStroke: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGTextDrawingMode(pub i32);
impl CGTextDrawingMode {
    pub const kCGTextFill: Self = Self(0);
    pub const kCGTextStroke: Self = Self(1);
    pub const kCGTextFillStroke: Self = Self(2);
    pub const kCGTextInvisible: Self = Self(3);
    pub const kCGTextFillClip: Self = Self(4);
    pub const kCGTextStrokeClip: Self = Self(5);
    pub const kCGTextFillStrokeClip: Self = Self(6);
    pub const kCGTextClip: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextencoding?language=objc)
// NS_ENUM
#[deprecated = "No longer supported"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGTextEncoding(pub i32);
impl CGTextEncoding {
    #[deprecated = "No longer supported"]
    pub const kCGEncodingFontSpecific: Self = Self(0);
    #[deprecated = "No longer supported"]
    pub const kCGEncodingMacRoman: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextEncoding {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextEncoding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cginterpolationquality?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGInterpolationQuality(pub i32);
impl CGInterpolationQuality {
    pub const kCGInterpolationDefault: Self = Self(0);
    pub const kCGInterpolationNone: Self = Self(1);
    pub const kCGInterpolationLow: Self = Self(2);
    pub const kCGInterpolationMedium: Self = Self(4);
    pub const kCGInterpolationHigh: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGInterpolationQuality {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGInterpolationQuality {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgblendmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGBlendMode(pub i32);
impl CGBlendMode {
    pub const kCGBlendModeNormal: Self = Self(0);
    pub const kCGBlendModeMultiply: Self = Self(1);
    pub const kCGBlendModeScreen: Self = Self(2);
    pub const kCGBlendModeOverlay: Self = Self(3);
    pub const kCGBlendModeDarken: Self = Self(4);
    pub const kCGBlendModeLighten: Self = Self(5);
    pub const kCGBlendModeColorDodge: Self = Self(6);
    pub const kCGBlendModeColorBurn: Self = Self(7);
    pub const kCGBlendModeSoftLight: Self = Self(8);
    pub const kCGBlendModeHardLight: Self = Self(9);
    pub const kCGBlendModeDifference: Self = Self(10);
    pub const kCGBlendModeExclusion: Self = Self(11);
    pub const kCGBlendModeHue: Self = Self(12);
    pub const kCGBlendModeSaturation: Self = Self(13);
    pub const kCGBlendModeColor: Self = Self(14);
    pub const kCGBlendModeLuminosity: Self = Self(15);
    pub const kCGBlendModeClear: Self = Self(16);
    pub const kCGBlendModeCopy: Self = Self(17);
    pub const kCGBlendModeSourceIn: Self = Self(18);
    pub const kCGBlendModeSourceOut: Self = Self(19);
    pub const kCGBlendModeSourceAtop: Self = Self(20);
    pub const kCGBlendModeDestinationOver: Self = Self(21);
    pub const kCGBlendModeDestinationIn: Self = Self(22);
    pub const kCGBlendModeDestinationOut: Self = Self(23);
    pub const kCGBlendModeDestinationAtop: Self = Self(24);
    pub const kCGBlendModeXOR: Self = Self(25);
    pub const kCGBlendModePlusDarker: Self = Self(26);
    pub const kCGBlendModePlusLighter: Self = Self(27);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGBlendMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGBlendMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    pub fn CGContextSaveGState(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextRestoreGState(c: CGContextRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextScaleCTM(c: CGContextRef, sx: CGFloat, sy: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextTranslateCTM(c: CGContextRef, tx: CGFloat, ty: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextRotateCTM(c: CGContextRef, angle: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextConcatCTM(c: CGContextRef, transform: CGAffineTransform);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetCTM(c: CGContextRef) -> CGAffineTransform;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetLineWidth(c: CGContextRef, width: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextSetLineCap(c: CGContextRef, cap: CGLineCap);
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextSetLineJoin(c: CGContextRef, join: CGLineJoin);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetMiterLimit(c: CGContextRef, limit: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetLineDash(
        c: CGContextRef,
        phase: CGFloat,
        lengths: *const CGFloat,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetFlatness(c: CGContextRef, flatness: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetAlpha(c: CGContextRef, alpha: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetBlendMode(c: CGContextRef, mode: CGBlendMode);
}

extern "C-unwind" {
    pub fn CGContextBeginPath(c: CGContextRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextMoveToPoint(c: CGContextRef, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddLineToPoint(c: CGContextRef, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddCurveToPoint(
        c: CGContextRef,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddQuadCurveToPoint(
        c: CGContextRef,
        cpx: CGFloat,
        cpy: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextClosePath(c: CGContextRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddRects(c: CGContextRef, rects: *const CGRect, count: usize);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddLines(c: CGContextRef, points: *const CGPoint, count: usize);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddEllipseInRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddArc(
        c: CGContextRef,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: c_int,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextAddArcToPoint(
        c: CGContextRef,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextAddPath(c: CGContextRef, path: CGPathRef);
}

extern "C-unwind" {
    pub fn CGContextReplacePathWithStrokedPath(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextIsPathEmpty(c: CGContextRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetPathCurrentPoint(c: CGContextRef) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetPathBoundingBox(c: CGContextRef) -> CGRect;
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextCopyPath(c: CGContextRef) -> CGPathRef;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextPathContainsPoint(
        c: CGContextRef,
        point: CGPoint,
        mode: CGPathDrawingMode,
    ) -> bool;
}

extern "C-unwind" {
    pub fn CGContextDrawPath(c: CGContextRef, mode: CGPathDrawingMode);
}

extern "C-unwind" {
    pub fn CGContextFillPath(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextEOFillPath(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextStrokePath(c: CGContextRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextFillRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextFillRects(c: CGContextRef, rects: *const CGRect, count: usize);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextStrokeRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextStrokeRectWithWidth(c: CGContextRef, rect: CGRect, width: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextClearRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextFillEllipseInRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextStrokeEllipseInRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextStrokeLineSegments(c: CGContextRef, points: *const CGPoint, count: usize);
}

extern "C-unwind" {
    pub fn CGContextClip(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextEOClip(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextResetClip(c: CGContextRef);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGImage", feature = "objc2-core-foundation"))]
    pub fn CGContextClipToMask(c: CGContextRef, rect: CGRect, mask: CGImageRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetClipBoundingBox(c: CGContextRef) -> CGRect;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextClipToRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextClipToRects(c: CGContextRef, rects: NonNull<CGRect>, count: usize);
}

extern "C-unwind" {
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetFillColorWithColor(c: CGContextRef, color: CGColorRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetStrokeColorWithColor(c: CGContextRef, color: CGColorRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetFillColorSpace(c: CGContextRef, space: CGColorSpaceRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetStrokeColorSpace(c: CGContextRef, space: CGColorSpaceRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetFillColor(c: CGContextRef, components: *const CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetStrokeColor(c: CGContextRef, components: *const CGFloat);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGPattern", feature = "objc2-core-foundation"))]
    pub fn CGContextSetFillPattern(
        c: CGContextRef,
        pattern: CGPatternRef,
        components: *const CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "CGPattern", feature = "objc2-core-foundation"))]
    pub fn CGContextSetStrokePattern(
        c: CGContextRef,
        pattern: CGPatternRef,
        components: *const CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetPatternPhase(c: CGContextRef, phase: CGSize);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetGrayFillColor(c: CGContextRef, gray: CGFloat, alpha: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetGrayStrokeColor(c: CGContextRef, gray: CGFloat, alpha: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetRGBFillColor(
        c: CGContextRef,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetRGBStrokeColor(
        c: CGContextRef,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetCMYKFillColor(
        c: CGContextRef,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetCMYKStrokeColor(
        c: CGContextRef,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetRenderingIntent(c: CGContextRef, intent: CGColorRenderingIntent);
}

extern "C-unwind" {
    pub fn CGContextSetEDRTargetHeadroom(c: CGContextRef, headroom: c_float) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetEDRTargetHeadroom(c: CGContextRef) -> c_float;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGImage", feature = "objc2-core-foundation"))]
    pub fn CGContextDrawImage(c: CGContextRef, rect: CGRect, image: CGImageRef);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGImage", feature = "objc2-core-foundation"))]
    pub fn CGContextDrawTiledImage(c: CGContextRef, rect: CGRect, image: CGImageRef);
}

extern "C-unwind" {
    #[cfg(all(
        feature = "CGImage",
        feature = "CGToneMapping",
        feature = "objc2-core-foundation"
    ))]
    pub fn CGContextDrawImageApplyingToneMapping(
        c: CGContextRef,
        r: CGRect,
        image: CGImageRef,
        method: CGToneMapping,
        options: CFDictionaryRef,
    ) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetInterpolationQuality(c: CGContextRef) -> CGInterpolationQuality;
}

extern "C-unwind" {
    pub fn CGContextSetInterpolationQuality(c: CGContextRef, quality: CGInterpolationQuality);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGColor", feature = "objc2-core-foundation"))]
    pub fn CGContextSetShadowWithColor(
        c: CGContextRef,
        offset: CGSize,
        blur: CGFloat,
        color: CGColorRef,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetShadow(c: CGContextRef, offset: CGSize, blur: CGFloat);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGGradient", feature = "objc2-core-foundation"))]
    pub fn CGContextDrawLinearGradient(
        c: CGContextRef,
        gradient: CGGradientRef,
        start_point: CGPoint,
        end_point: CGPoint,
        options: CGGradientDrawingOptions,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "CGGradient", feature = "objc2-core-foundation"))]
    pub fn CGContextDrawRadialGradient(
        c: CGContextRef,
        gradient: CGGradientRef,
        start_center: CGPoint,
        start_radius: CGFloat,
        end_center: CGPoint,
        end_radius: CGFloat,
        options: CGGradientDrawingOptions,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "CGGradient", feature = "objc2-core-foundation"))]
    pub fn CGContextDrawConicGradient(
        c: CGContextRef,
        gradient: CGGradientRef,
        center: CGPoint,
        angle: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGShading")]
    pub fn CGContextDrawShading(c: CGContextRef, shading: CGShadingRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetCharacterSpacing(c: CGContextRef, spacing: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetTextPosition(c: CGContextRef, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetTextPosition(c: CGContextRef) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetTextMatrix(c: CGContextRef, t: CGAffineTransform);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetTextMatrix(c: CGContextRef) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGContextSetTextDrawingMode(c: CGContextRef, mode: CGTextDrawingMode);
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    pub fn CGContextSetFont(c: CGContextRef, font: CGFontRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextSetFontSize(c: CGContextRef, size: CGFloat);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGFont", feature = "objc2-core-foundation"))]
    pub fn CGContextShowGlyphsAtPositions(
        c: CGContextRef,
        glyphs: *const CGGlyph,
        lpositions: *const CGPoint,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPDFPage")]
    pub fn CGContextDrawPDFPage(c: CGContextRef, page: CGPDFPageRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextBeginPage(c: CGContextRef, media_box: *const CGRect);
}

extern "C-unwind" {
    pub fn CGContextEndPage(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextRetain(c: CGContextRef) -> CGContextRef;
}

extern "C-unwind" {
    pub fn CGContextRelease(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextFlush(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextSynchronize(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextSetShouldAntialias(c: CGContextRef, should_antialias: bool);
}

extern "C-unwind" {
    pub fn CGContextSetAllowsAntialiasing(c: CGContextRef, allows_antialiasing: bool);
}

extern "C-unwind" {
    pub fn CGContextSetShouldSmoothFonts(c: CGContextRef, should_smooth_fonts: bool);
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSmoothing(c: CGContextRef, allows_font_smoothing: bool);
}

extern "C-unwind" {
    pub fn CGContextSetShouldSubpixelPositionFonts(
        c: CGContextRef,
        should_subpixel_position_fonts: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSubpixelPositioning(
        c: CGContextRef,
        allows_font_subpixel_positioning: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetShouldSubpixelQuantizeFonts(
        c: CGContextRef,
        should_subpixel_quantize_fonts: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSubpixelQuantization(
        c: CGContextRef,
        allows_font_subpixel_quantization: bool,
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextBeginTransparencyLayer(c: CGContextRef, auxiliary_info: CFDictionaryRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextBeginTransparencyLayerWithRect(
        c: CGContextRef,
        rect: CGRect,
        aux_info: CFDictionaryRef,
    );
}

extern "C-unwind" {
    pub fn CGContextEndTransparencyLayer(c: CGContextRef);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextGetUserSpaceToDeviceSpaceTransform(c: CGContextRef) -> CGAffineTransform;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextConvertPointToDeviceSpace(c: CGContextRef, point: CGPoint) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextConvertPointToUserSpace(c: CGContextRef, point: CGPoint) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextConvertSizeToDeviceSpace(c: CGContextRef, size: CGSize) -> CGSize;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextConvertSizeToUserSpace(c: CGContextRef, size: CGSize) -> CGSize;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextConvertRectToDeviceSpace(c: CGContextRef, rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    pub fn CGContextConvertRectToUserSpace(c: CGContextRef, rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "No longer supported"]
    pub fn CGContextSelectFont(
        c: CGContextRef,
        name: *const c_char,
        size: CGFloat,
        text_encoding: CGTextEncoding,
    );
}

extern "C-unwind" {
    #[deprecated = "No longer supported"]
    pub fn CGContextShowText(c: CGContextRef, string: *const c_char, length: usize);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowTextAtPoint(
        c: CGContextRef,
        x: CGFloat,
        y: CGFloat,
        string: *const c_char,
        length: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphs(c: CGContextRef, g: *const CGGlyph, count: usize);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGFont", feature = "objc2-core-foundation"))]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphsAtPoint(
        c: CGContextRef,
        x: CGFloat,
        y: CGFloat,
        glyphs: *const CGGlyph,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "CGFont", feature = "objc2-core-foundation"))]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphsWithAdvances(
        c: CGContextRef,
        glyphs: *const CGGlyph,
        advances: *const CGSize,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "CGPDFDocument", feature = "objc2-core-foundation"))]
    #[deprecated = "No longer supported"]
    pub fn CGContextDrawPDFDocument(
        c: CGContextRef,
        rect: CGRect,
        document: CGPDFDocumentRef,
        page: c_int,
    );
}
