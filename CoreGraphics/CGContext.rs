//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcontextref?language=objc)
#[repr(C)]
pub struct CGContextRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "CGContext"]
    unsafe impl CGContextRef {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGPathDrawingMode(pub i32);
impl CGPathDrawingMode {
    #[doc(alias = "kCGPathFill")]
    pub const Fill: Self = Self(0);
    #[doc(alias = "kCGPathEOFill")]
    pub const EOFill: Self = Self(1);
    #[doc(alias = "kCGPathStroke")]
    pub const Stroke: Self = Self(2);
    #[doc(alias = "kCGPathFillStroke")]
    pub const FillStroke: Self = Self(3);
    #[doc(alias = "kCGPathEOFillStroke")]
    pub const EOFillStroke: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGTextDrawingMode(pub i32);
impl CGTextDrawingMode {
    #[doc(alias = "kCGTextFill")]
    pub const Fill: Self = Self(0);
    #[doc(alias = "kCGTextStroke")]
    pub const Stroke: Self = Self(1);
    #[doc(alias = "kCGTextFillStroke")]
    pub const FillStroke: Self = Self(2);
    #[doc(alias = "kCGTextInvisible")]
    pub const Invisible: Self = Self(3);
    #[doc(alias = "kCGTextFillClip")]
    pub const FillClip: Self = Self(4);
    #[doc(alias = "kCGTextStrokeClip")]
    pub const StrokeClip: Self = Self(5);
    #[doc(alias = "kCGTextFillStrokeClip")]
    pub const FillStrokeClip: Self = Self(6);
    #[doc(alias = "kCGTextClip")]
    pub const Clip: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextencoding?language=objc)
// NS_ENUM
#[deprecated = "No longer supported"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGTextEncoding(pub i32);
impl CGTextEncoding {
    #[deprecated = "No longer supported"]
    #[doc(alias = "kCGEncodingFontSpecific")]
    pub const EncodingFontSpecific: Self = Self(0);
    #[deprecated = "No longer supported"]
    #[doc(alias = "kCGEncodingMacRoman")]
    pub const EncodingMacRoman: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextEncoding {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextEncoding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cginterpolationquality?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGInterpolationQuality(pub i32);
impl CGInterpolationQuality {
    #[doc(alias = "kCGInterpolationDefault")]
    pub const Default: Self = Self(0);
    #[doc(alias = "kCGInterpolationNone")]
    pub const None: Self = Self(1);
    #[doc(alias = "kCGInterpolationLow")]
    pub const Low: Self = Self(2);
    #[doc(alias = "kCGInterpolationMedium")]
    pub const Medium: Self = Self(4);
    #[doc(alias = "kCGInterpolationHigh")]
    pub const High: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGInterpolationQuality {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGInterpolationQuality {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgblendmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGBlendMode(pub i32);
impl CGBlendMode {
    #[doc(alias = "kCGBlendModeNormal")]
    pub const Normal: Self = Self(0);
    #[doc(alias = "kCGBlendModeMultiply")]
    pub const Multiply: Self = Self(1);
    #[doc(alias = "kCGBlendModeScreen")]
    pub const Screen: Self = Self(2);
    #[doc(alias = "kCGBlendModeOverlay")]
    pub const Overlay: Self = Self(3);
    #[doc(alias = "kCGBlendModeDarken")]
    pub const Darken: Self = Self(4);
    #[doc(alias = "kCGBlendModeLighten")]
    pub const Lighten: Self = Self(5);
    #[doc(alias = "kCGBlendModeColorDodge")]
    pub const ColorDodge: Self = Self(6);
    #[doc(alias = "kCGBlendModeColorBurn")]
    pub const ColorBurn: Self = Self(7);
    #[doc(alias = "kCGBlendModeSoftLight")]
    pub const SoftLight: Self = Self(8);
    #[doc(alias = "kCGBlendModeHardLight")]
    pub const HardLight: Self = Self(9);
    #[doc(alias = "kCGBlendModeDifference")]
    pub const Difference: Self = Self(10);
    #[doc(alias = "kCGBlendModeExclusion")]
    pub const Exclusion: Self = Self(11);
    #[doc(alias = "kCGBlendModeHue")]
    pub const Hue: Self = Self(12);
    #[doc(alias = "kCGBlendModeSaturation")]
    pub const Saturation: Self = Self(13);
    #[doc(alias = "kCGBlendModeColor")]
    pub const Color: Self = Self(14);
    #[doc(alias = "kCGBlendModeLuminosity")]
    pub const Luminosity: Self = Self(15);
    #[doc(alias = "kCGBlendModeClear")]
    pub const Clear: Self = Self(16);
    #[doc(alias = "kCGBlendModeCopy")]
    pub const Copy: Self = Self(17);
    #[doc(alias = "kCGBlendModeSourceIn")]
    pub const SourceIn: Self = Self(18);
    #[doc(alias = "kCGBlendModeSourceOut")]
    pub const SourceOut: Self = Self(19);
    #[doc(alias = "kCGBlendModeSourceAtop")]
    pub const SourceAtop: Self = Self(20);
    #[doc(alias = "kCGBlendModeDestinationOver")]
    pub const DestinationOver: Self = Self(21);
    #[doc(alias = "kCGBlendModeDestinationIn")]
    pub const DestinationIn: Self = Self(22);
    #[doc(alias = "kCGBlendModeDestinationOut")]
    pub const DestinationOut: Self = Self(23);
    #[doc(alias = "kCGBlendModeDestinationAtop")]
    pub const DestinationAtop: Self = Self(24);
    #[doc(alias = "kCGBlendModeXOR")]
    pub const XOR: Self = Self(25);
    #[doc(alias = "kCGBlendModePlusDarker")]
    pub const PlusDarker: Self = Self(26);
    #[doc(alias = "kCGBlendModePlusLighter")]
    pub const PlusLighter: Self = Self(27);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGBlendMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGBlendMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    pub fn CGContextGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    /// Graphics state functions. *
    pub fn CGContextSaveGState(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextRestoreGState(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    /// Coordinate space transformations. *
    pub fn CGContextScaleCTM(c: Option<&CGContextRef>, sx: CGFloat, sy: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextTranslateCTM(c: Option<&CGContextRef>, tx: CGFloat, ty: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextRotateCTM(c: Option<&CGContextRef>, angle: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextConcatCTM(c: Option<&CGContextRef>, transform: CGAffineTransform);
}

extern "C-unwind" {
    pub fn CGContextGetCTM(c: Option<&CGContextRef>) -> CGAffineTransform;
}

extern "C-unwind" {
    /// Drawing attribute functions. *
    pub fn CGContextSetLineWidth(c: Option<&CGContextRef>, width: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextSetLineCap(c: Option<&CGContextRef>, cap: CGLineCap);
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextSetLineJoin(c: Option<&CGContextRef>, join: CGLineJoin);
}

extern "C-unwind" {
    pub fn CGContextSetMiterLimit(c: Option<&CGContextRef>, limit: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetLineDash(
        c: Option<&CGContextRef>,
        phase: CGFloat,
        lengths: *const CGFloat,
        count: usize,
    );
}

extern "C-unwind" {
    pub fn CGContextSetFlatness(c: Option<&CGContextRef>, flatness: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetAlpha(c: Option<&CGContextRef>, alpha: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetBlendMode(c: Option<&CGContextRef>, mode: CGBlendMode);
}

extern "C-unwind" {
    /// Path construction functions. *
    pub fn CGContextBeginPath(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextMoveToPoint(c: Option<&CGContextRef>, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextAddLineToPoint(c: Option<&CGContextRef>, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextAddCurveToPoint(
        c: Option<&CGContextRef>,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextAddQuadCurveToPoint(
        c: Option<&CGContextRef>,
        cpx: CGFloat,
        cpy: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextClosePath(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    /// Path construction convenience functions. *
    pub fn CGContextAddRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextAddRects(c: Option<&CGContextRef>, rects: *const CGRect, count: usize);
}

extern "C-unwind" {
    pub fn CGContextAddLines(c: Option<&CGContextRef>, points: *const CGPoint, count: usize);
}

extern "C-unwind" {
    pub fn CGContextAddEllipseInRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextAddArc(
        c: Option<&CGContextRef>,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: c_int,
    );
}

extern "C-unwind" {
    pub fn CGContextAddArcToPoint(
        c: Option<&CGContextRef>,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextAddPath(c: Option<&CGContextRef>, path: Option<&CGPathRef>);
}

extern "C-unwind" {
    pub fn CGContextReplacePathWithStrokedPath(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    /// Path information functions. *
    pub fn CGContextIsPathEmpty(c: Option<&CGContextRef>) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetPathCurrentPoint(c: Option<&CGContextRef>) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextGetPathBoundingBox(c: Option<&CGContextRef>) -> CGRect;
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextCopyPath(c: Option<&CGContextRef>) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGContextPathContainsPoint(
        c: Option<&CGContextRef>,
        point: CGPoint,
        mode: CGPathDrawingMode,
    ) -> bool;
}

extern "C-unwind" {
    /// Path drawing functions. *
    pub fn CGContextDrawPath(c: Option<&CGContextRef>, mode: CGPathDrawingMode);
}

extern "C-unwind" {
    /// Path drawing convenience functions. *
    pub fn CGContextFillPath(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextEOFillPath(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextStrokePath(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextFillRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextFillRects(c: Option<&CGContextRef>, rects: *const CGRect, count: usize);
}

extern "C-unwind" {
    pub fn CGContextStrokeRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextStrokeRectWithWidth(c: Option<&CGContextRef>, rect: CGRect, width: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextClearRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextFillEllipseInRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextStrokeEllipseInRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextStrokeLineSegments(
        c: Option<&CGContextRef>,
        points: *const CGPoint,
        count: usize,
    );
}

extern "C-unwind" {
    /// Clipping functions. *
    pub fn CGContextClip(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextEOClip(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextResetClip(c: &CGContextRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGImage")]
    pub fn CGContextClipToMask(c: Option<&CGContextRef>, rect: CGRect, mask: Option<&CGImageRef>);
}

extern "C-unwind" {
    pub fn CGContextGetClipBoundingBox(c: Option<&CGContextRef>) -> CGRect;
}

extern "C-unwind" {
    /// Clipping convenience functions. *
    pub fn CGContextClipToRect(c: Option<&CGContextRef>, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextClipToRects(c: Option<&CGContextRef>, rects: NonNull<CGRect>, count: usize);
}

extern "C-unwind" {
    /// Primitive color functions. *
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetFillColorWithColor(c: Option<&CGContextRef>, color: Option<&CGColorRef>);
}

extern "C-unwind" {
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetStrokeColorWithColor(c: Option<&CGContextRef>, color: Option<&CGColorRef>);
}

extern "C-unwind" {
    /// Color space functions. *
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetFillColorSpace(c: Option<&CGContextRef>, space: Option<&CGColorSpaceRef>);
}

extern "C-unwind" {
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetStrokeColorSpace(c: Option<&CGContextRef>, space: Option<&CGColorSpaceRef>);
}

extern "C-unwind" {
    /// Color functions. *
    pub fn CGContextSetFillColor(c: Option<&CGContextRef>, components: *const CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetStrokeColor(c: Option<&CGContextRef>, components: *const CGFloat);
}

extern "C-unwind" {
    /// Pattern functions. *
    #[cfg(feature = "CGPattern")]
    pub fn CGContextSetFillPattern(
        c: Option<&CGContextRef>,
        pattern: Option<&CGPatternRef>,
        components: *const CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPattern")]
    pub fn CGContextSetStrokePattern(
        c: Option<&CGContextRef>,
        pattern: Option<&CGPatternRef>,
        components: *const CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetPatternPhase(c: Option<&CGContextRef>, phase: CGSize);
}

extern "C-unwind" {
    /// Color convenience functions. *
    pub fn CGContextSetGrayFillColor(c: Option<&CGContextRef>, gray: CGFloat, alpha: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetGrayStrokeColor(c: Option<&CGContextRef>, gray: CGFloat, alpha: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetRGBFillColor(
        c: Option<&CGContextRef>,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetRGBStrokeColor(
        c: Option<&CGContextRef>,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetCMYKFillColor(
        c: Option<&CGContextRef>,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetCMYKStrokeColor(
        c: Option<&CGContextRef>,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    /// Rendering intent. *
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetRenderingIntent(c: Option<&CGContextRef>, intent: CGColorRenderingIntent);
}

extern "C-unwind" {
    pub fn CGContextSetEDRTargetHeadroom(c: &CGContextRef, headroom: c_float) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetEDRTargetHeadroom(c: &CGContextRef) -> c_float;
}

extern "C-unwind" {
    /// Image functions. *
    #[cfg(feature = "CGImage")]
    pub fn CGContextDrawImage(c: Option<&CGContextRef>, rect: CGRect, image: Option<&CGImageRef>);
}

extern "C-unwind" {
    #[cfg(feature = "CGImage")]
    pub fn CGContextDrawTiledImage(
        c: Option<&CGContextRef>,
        rect: CGRect,
        image: Option<&CGImageRef>,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "CGImage", feature = "CGToneMapping"))]
    pub fn CGContextDrawImageApplyingToneMapping(
        c: &CGContextRef,
        r: CGRect,
        image: &CGImageRef,
        method: CGToneMapping,
        options: Option<&CFDictionaryRef>,
    ) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetInterpolationQuality(c: Option<&CGContextRef>) -> CGInterpolationQuality;
}

extern "C-unwind" {
    pub fn CGContextSetInterpolationQuality(
        c: Option<&CGContextRef>,
        quality: CGInterpolationQuality,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetShadowWithColor(
        c: Option<&CGContextRef>,
        offset: CGSize,
        blur: CGFloat,
        color: Option<&CGColorRef>,
    );
}

extern "C-unwind" {
    pub fn CGContextSetShadow(c: Option<&CGContextRef>, offset: CGSize, blur: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "CGGradient")]
    pub fn CGContextDrawLinearGradient(
        c: Option<&CGContextRef>,
        gradient: Option<&CGGradientRef>,
        start_point: CGPoint,
        end_point: CGPoint,
        options: CGGradientDrawingOptions,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGGradient")]
    pub fn CGContextDrawRadialGradient(
        c: Option<&CGContextRef>,
        gradient: Option<&CGGradientRef>,
        start_center: CGPoint,
        start_radius: CGFloat,
        end_center: CGPoint,
        end_radius: CGFloat,
        options: CGGradientDrawingOptions,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGGradient")]
    pub fn CGContextDrawConicGradient(
        c: &CGContextRef,
        gradient: Option<&CGGradientRef>,
        center: CGPoint,
        angle: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGShading")]
    pub fn CGContextDrawShading(c: Option<&CGContextRef>, shading: Option<&CGShadingRef>);
}

extern "C-unwind" {
    /// Text functions. *
    pub fn CGContextSetCharacterSpacing(c: Option<&CGContextRef>, spacing: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetTextPosition(c: Option<&CGContextRef>, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextGetTextPosition(c: Option<&CGContextRef>) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextSetTextMatrix(c: Option<&CGContextRef>, t: CGAffineTransform);
}

extern "C-unwind" {
    pub fn CGContextGetTextMatrix(c: Option<&CGContextRef>) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGContextSetTextDrawingMode(c: Option<&CGContextRef>, mode: CGTextDrawingMode);
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    pub fn CGContextSetFont(c: Option<&CGContextRef>, font: Option<&CGFontRef>);
}

extern "C-unwind" {
    pub fn CGContextSetFontSize(c: Option<&CGContextRef>, size: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    pub fn CGContextShowGlyphsAtPositions(
        c: Option<&CGContextRef>,
        glyphs: *const CGGlyph,
        lpositions: *const CGPoint,
        count: usize,
    );
}

extern "C-unwind" {
    /// PDF functions. *
    #[cfg(feature = "CGPDFPage")]
    pub fn CGContextDrawPDFPage(c: Option<&CGContextRef>, page: Option<&CGPDFPageRef>);
}

extern "C-unwind" {
    /// Output page functions. *
    pub fn CGContextBeginPage(c: Option<&CGContextRef>, media_box: *const CGRect);
}

extern "C-unwind" {
    pub fn CGContextEndPage(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    /// Context functions. *
    pub fn CGContextRetain(c: Option<&CGContextRef>) -> *mut CGContextRef;
}

extern "C-unwind" {
    pub fn CGContextRelease(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextFlush(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextSynchronize(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    pub fn CGContextSetShouldAntialias(c: Option<&CGContextRef>, should_antialias: bool);
}

extern "C-unwind" {
    pub fn CGContextSetAllowsAntialiasing(c: Option<&CGContextRef>, allows_antialiasing: bool);
}

extern "C-unwind" {
    pub fn CGContextSetShouldSmoothFonts(c: Option<&CGContextRef>, should_smooth_fonts: bool);
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSmoothing(c: Option<&CGContextRef>, allows_font_smoothing: bool);
}

extern "C-unwind" {
    pub fn CGContextSetShouldSubpixelPositionFonts(
        c: Option<&CGContextRef>,
        should_subpixel_position_fonts: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSubpixelPositioning(
        c: Option<&CGContextRef>,
        allows_font_subpixel_positioning: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetShouldSubpixelQuantizeFonts(
        c: Option<&CGContextRef>,
        should_subpixel_quantize_fonts: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSubpixelQuantization(
        c: Option<&CGContextRef>,
        allows_font_subpixel_quantization: bool,
    );
}

extern "C-unwind" {
    /// Transparency layer support. *
    pub fn CGContextBeginTransparencyLayer(
        c: Option<&CGContextRef>,
        auxiliary_info: Option<&CFDictionaryRef>,
    );
}

extern "C-unwind" {
    pub fn CGContextBeginTransparencyLayerWithRect(
        c: Option<&CGContextRef>,
        rect: CGRect,
        aux_info: Option<&CFDictionaryRef>,
    );
}

extern "C-unwind" {
    pub fn CGContextEndTransparencyLayer(c: Option<&CGContextRef>);
}

extern "C-unwind" {
    /// User space to device space tranformations. *
    pub fn CGContextGetUserSpaceToDeviceSpaceTransform(
        c: Option<&CGContextRef>,
    ) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGContextConvertPointToDeviceSpace(c: Option<&CGContextRef>, point: CGPoint) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextConvertPointToUserSpace(c: Option<&CGContextRef>, point: CGPoint) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextConvertSizeToDeviceSpace(c: Option<&CGContextRef>, size: CGSize) -> CGSize;
}

extern "C-unwind" {
    pub fn CGContextConvertSizeToUserSpace(c: Option<&CGContextRef>, size: CGSize) -> CGSize;
}

extern "C-unwind" {
    pub fn CGContextConvertRectToDeviceSpace(c: Option<&CGContextRef>, rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    pub fn CGContextConvertRectToUserSpace(c: Option<&CGContextRef>, rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[deprecated = "No longer supported"]
    pub fn CGContextSelectFont(
        c: Option<&CGContextRef>,
        name: *const c_char,
        size: CGFloat,
        text_encoding: CGTextEncoding,
    );
}

extern "C-unwind" {
    #[deprecated = "No longer supported"]
    pub fn CGContextShowText(c: Option<&CGContextRef>, string: *const c_char, length: usize);
}

extern "C-unwind" {
    #[deprecated = "No longer supported"]
    pub fn CGContextShowTextAtPoint(
        c: Option<&CGContextRef>,
        x: CGFloat,
        y: CGFloat,
        string: *const c_char,
        length: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphs(c: Option<&CGContextRef>, g: *const CGGlyph, count: usize);
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphsAtPoint(
        c: Option<&CGContextRef>,
        x: CGFloat,
        y: CGFloat,
        glyphs: *const CGGlyph,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphsWithAdvances(
        c: Option<&CGContextRef>,
        glyphs: *const CGGlyph,
        advances: *const CGSize,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPDFDocument")]
    #[deprecated = "No longer supported"]
    pub fn CGContextDrawPDFDocument(
        c: Option<&CGContextRef>,
        rect: CGRect,
        document: Option<&CGPDFDocumentRef>,
        page: c_int,
    );
}
