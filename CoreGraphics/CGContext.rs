//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcontextref?language=objc)
pub type CGContextRef = *mut c_void;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGPathDrawingMode(pub i32);
impl CGPathDrawingMode {
    #[doc(alias = "kCGPathFill")]
    pub const Fill: Self = Self(0);
    #[doc(alias = "kCGPathEOFill")]
    pub const EOFill: Self = Self(1);
    #[doc(alias = "kCGPathStroke")]
    pub const Stroke: Self = Self(2);
    #[doc(alias = "kCGPathFillStroke")]
    pub const FillStroke: Self = Self(3);
    #[doc(alias = "kCGPathEOFillStroke")]
    pub const EOFillStroke: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGTextDrawingMode(pub i32);
impl CGTextDrawingMode {
    #[doc(alias = "kCGTextFill")]
    pub const Fill: Self = Self(0);
    #[doc(alias = "kCGTextStroke")]
    pub const Stroke: Self = Self(1);
    #[doc(alias = "kCGTextFillStroke")]
    pub const FillStroke: Self = Self(2);
    #[doc(alias = "kCGTextInvisible")]
    pub const Invisible: Self = Self(3);
    #[doc(alias = "kCGTextFillClip")]
    pub const FillClip: Self = Self(4);
    #[doc(alias = "kCGTextStrokeClip")]
    pub const StrokeClip: Self = Self(5);
    #[doc(alias = "kCGTextFillStrokeClip")]
    pub const FillStrokeClip: Self = Self(6);
    #[doc(alias = "kCGTextClip")]
    pub const Clip: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextencoding?language=objc)
// NS_ENUM
#[deprecated = "No longer supported"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGTextEncoding(pub i32);
impl CGTextEncoding {
    #[deprecated = "No longer supported"]
    #[doc(alias = "kCGEncodingFontSpecific")]
    pub const EncodingFontSpecific: Self = Self(0);
    #[deprecated = "No longer supported"]
    #[doc(alias = "kCGEncodingMacRoman")]
    pub const EncodingMacRoman: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextEncoding {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextEncoding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cginterpolationquality?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGInterpolationQuality(pub i32);
impl CGInterpolationQuality {
    #[doc(alias = "kCGInterpolationDefault")]
    pub const Default: Self = Self(0);
    #[doc(alias = "kCGInterpolationNone")]
    pub const None: Self = Self(1);
    #[doc(alias = "kCGInterpolationLow")]
    pub const Low: Self = Self(2);
    #[doc(alias = "kCGInterpolationMedium")]
    pub const Medium: Self = Self(4);
    #[doc(alias = "kCGInterpolationHigh")]
    pub const High: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGInterpolationQuality {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGInterpolationQuality {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgblendmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGBlendMode(pub i32);
impl CGBlendMode {
    #[doc(alias = "kCGBlendModeNormal")]
    pub const Normal: Self = Self(0);
    #[doc(alias = "kCGBlendModeMultiply")]
    pub const Multiply: Self = Self(1);
    #[doc(alias = "kCGBlendModeScreen")]
    pub const Screen: Self = Self(2);
    #[doc(alias = "kCGBlendModeOverlay")]
    pub const Overlay: Self = Self(3);
    #[doc(alias = "kCGBlendModeDarken")]
    pub const Darken: Self = Self(4);
    #[doc(alias = "kCGBlendModeLighten")]
    pub const Lighten: Self = Self(5);
    #[doc(alias = "kCGBlendModeColorDodge")]
    pub const ColorDodge: Self = Self(6);
    #[doc(alias = "kCGBlendModeColorBurn")]
    pub const ColorBurn: Self = Self(7);
    #[doc(alias = "kCGBlendModeSoftLight")]
    pub const SoftLight: Self = Self(8);
    #[doc(alias = "kCGBlendModeHardLight")]
    pub const HardLight: Self = Self(9);
    #[doc(alias = "kCGBlendModeDifference")]
    pub const Difference: Self = Self(10);
    #[doc(alias = "kCGBlendModeExclusion")]
    pub const Exclusion: Self = Self(11);
    #[doc(alias = "kCGBlendModeHue")]
    pub const Hue: Self = Self(12);
    #[doc(alias = "kCGBlendModeSaturation")]
    pub const Saturation: Self = Self(13);
    #[doc(alias = "kCGBlendModeColor")]
    pub const Color: Self = Self(14);
    #[doc(alias = "kCGBlendModeLuminosity")]
    pub const Luminosity: Self = Self(15);
    #[doc(alias = "kCGBlendModeClear")]
    pub const Clear: Self = Self(16);
    #[doc(alias = "kCGBlendModeCopy")]
    pub const Copy: Self = Self(17);
    #[doc(alias = "kCGBlendModeSourceIn")]
    pub const SourceIn: Self = Self(18);
    #[doc(alias = "kCGBlendModeSourceOut")]
    pub const SourceOut: Self = Self(19);
    #[doc(alias = "kCGBlendModeSourceAtop")]
    pub const SourceAtop: Self = Self(20);
    #[doc(alias = "kCGBlendModeDestinationOver")]
    pub const DestinationOver: Self = Self(21);
    #[doc(alias = "kCGBlendModeDestinationIn")]
    pub const DestinationIn: Self = Self(22);
    #[doc(alias = "kCGBlendModeDestinationOut")]
    pub const DestinationOut: Self = Self(23);
    #[doc(alias = "kCGBlendModeDestinationAtop")]
    pub const DestinationAtop: Self = Self(24);
    #[doc(alias = "kCGBlendModeXOR")]
    pub const XOR: Self = Self(25);
    #[doc(alias = "kCGBlendModePlusDarker")]
    pub const PlusDarker: Self = Self(26);
    #[doc(alias = "kCGBlendModePlusLighter")]
    pub const PlusLighter: Self = Self(27);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGBlendMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGBlendMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    pub fn CGContextGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    /// Graphics state functions. *
    pub fn CGContextSaveGState(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextRestoreGState(c: CGContextRef);
}

extern "C-unwind" {
    /// Coordinate space transformations. *
    pub fn CGContextScaleCTM(c: CGContextRef, sx: CGFloat, sy: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextTranslateCTM(c: CGContextRef, tx: CGFloat, ty: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextRotateCTM(c: CGContextRef, angle: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextConcatCTM(c: CGContextRef, transform: CGAffineTransform);
}

extern "C-unwind" {
    pub fn CGContextGetCTM(c: CGContextRef) -> CGAffineTransform;
}

extern "C-unwind" {
    /// Drawing attribute functions. *
    pub fn CGContextSetLineWidth(c: CGContextRef, width: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextSetLineCap(c: CGContextRef, cap: CGLineCap);
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextSetLineJoin(c: CGContextRef, join: CGLineJoin);
}

extern "C-unwind" {
    pub fn CGContextSetMiterLimit(c: CGContextRef, limit: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetLineDash(
        c: CGContextRef,
        phase: CGFloat,
        lengths: *const CGFloat,
        count: usize,
    );
}

extern "C-unwind" {
    pub fn CGContextSetFlatness(c: CGContextRef, flatness: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetAlpha(c: CGContextRef, alpha: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetBlendMode(c: CGContextRef, mode: CGBlendMode);
}

extern "C-unwind" {
    /// Path construction functions. *
    pub fn CGContextBeginPath(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextMoveToPoint(c: CGContextRef, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextAddLineToPoint(c: CGContextRef, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextAddCurveToPoint(
        c: CGContextRef,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextAddQuadCurveToPoint(
        c: CGContextRef,
        cpx: CGFloat,
        cpy: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextClosePath(c: CGContextRef);
}

extern "C-unwind" {
    /// Path construction convenience functions. *
    pub fn CGContextAddRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextAddRects(c: CGContextRef, rects: *const CGRect, count: usize);
}

extern "C-unwind" {
    pub fn CGContextAddLines(c: CGContextRef, points: *const CGPoint, count: usize);
}

extern "C-unwind" {
    pub fn CGContextAddEllipseInRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextAddArc(
        c: CGContextRef,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: c_int,
    );
}

extern "C-unwind" {
    pub fn CGContextAddArcToPoint(
        c: CGContextRef,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextAddPath(c: CGContextRef, path: CGPathRef);
}

extern "C-unwind" {
    pub fn CGContextReplacePathWithStrokedPath(c: CGContextRef);
}

extern "C-unwind" {
    /// Path information functions. *
    pub fn CGContextIsPathEmpty(c: CGContextRef) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetPathCurrentPoint(c: CGContextRef) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextGetPathBoundingBox(c: CGContextRef) -> CGRect;
}

extern "C-unwind" {
    #[cfg(feature = "CGPath")]
    pub fn CGContextCopyPath(c: CGContextRef) -> CGPathRef;
}

extern "C-unwind" {
    pub fn CGContextPathContainsPoint(
        c: CGContextRef,
        point: CGPoint,
        mode: CGPathDrawingMode,
    ) -> bool;
}

extern "C-unwind" {
    /// Path drawing functions. *
    pub fn CGContextDrawPath(c: CGContextRef, mode: CGPathDrawingMode);
}

extern "C-unwind" {
    /// Path drawing convenience functions. *
    pub fn CGContextFillPath(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextEOFillPath(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextStrokePath(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextFillRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextFillRects(c: CGContextRef, rects: *const CGRect, count: usize);
}

extern "C-unwind" {
    pub fn CGContextStrokeRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextStrokeRectWithWidth(c: CGContextRef, rect: CGRect, width: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextClearRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextFillEllipseInRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextStrokeEllipseInRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextStrokeLineSegments(c: CGContextRef, points: *const CGPoint, count: usize);
}

extern "C-unwind" {
    /// Clipping functions. *
    pub fn CGContextClip(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextEOClip(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextResetClip(c: CGContextRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGImage")]
    pub fn CGContextClipToMask(c: CGContextRef, rect: CGRect, mask: CGImageRef);
}

extern "C-unwind" {
    pub fn CGContextGetClipBoundingBox(c: CGContextRef) -> CGRect;
}

extern "C-unwind" {
    /// Clipping convenience functions. *
    pub fn CGContextClipToRect(c: CGContextRef, rect: CGRect);
}

extern "C-unwind" {
    pub fn CGContextClipToRects(c: CGContextRef, rects: NonNull<CGRect>, count: usize);
}

extern "C-unwind" {
    /// Primitive color functions. *
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetFillColorWithColor(c: CGContextRef, color: CGColorRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetStrokeColorWithColor(c: CGContextRef, color: CGColorRef);
}

extern "C-unwind" {
    /// Color space functions. *
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetFillColorSpace(c: CGContextRef, space: CGColorSpaceRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetStrokeColorSpace(c: CGContextRef, space: CGColorSpaceRef);
}

extern "C-unwind" {
    /// Color functions. *
    pub fn CGContextSetFillColor(c: CGContextRef, components: *const CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetStrokeColor(c: CGContextRef, components: *const CGFloat);
}

extern "C-unwind" {
    /// Pattern functions. *
    #[cfg(feature = "CGPattern")]
    pub fn CGContextSetFillPattern(
        c: CGContextRef,
        pattern: CGPatternRef,
        components: *const CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPattern")]
    pub fn CGContextSetStrokePattern(
        c: CGContextRef,
        pattern: CGPatternRef,
        components: *const CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetPatternPhase(c: CGContextRef, phase: CGSize);
}

extern "C-unwind" {
    /// Color convenience functions. *
    pub fn CGContextSetGrayFillColor(c: CGContextRef, gray: CGFloat, alpha: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetGrayStrokeColor(c: CGContextRef, gray: CGFloat, alpha: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetRGBFillColor(
        c: CGContextRef,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetRGBStrokeColor(
        c: CGContextRef,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetCMYKFillColor(
        c: CGContextRef,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGContextSetCMYKStrokeColor(
        c: CGContextRef,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    );
}

extern "C-unwind" {
    /// Rendering intent. *
    #[cfg(feature = "CGColorSpace")]
    pub fn CGContextSetRenderingIntent(c: CGContextRef, intent: CGColorRenderingIntent);
}

extern "C-unwind" {
    pub fn CGContextSetEDRTargetHeadroom(c: CGContextRef, headroom: c_float) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetEDRTargetHeadroom(c: CGContextRef) -> c_float;
}

extern "C-unwind" {
    /// Image functions. *
    #[cfg(feature = "CGImage")]
    pub fn CGContextDrawImage(c: CGContextRef, rect: CGRect, image: CGImageRef);
}

extern "C-unwind" {
    #[cfg(feature = "CGImage")]
    pub fn CGContextDrawTiledImage(c: CGContextRef, rect: CGRect, image: CGImageRef);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGImage", feature = "CGToneMapping"))]
    pub fn CGContextDrawImageApplyingToneMapping(
        c: CGContextRef,
        r: CGRect,
        image: CGImageRef,
        method: CGToneMapping,
        options: CFDictionaryRef,
    ) -> bool;
}

extern "C-unwind" {
    pub fn CGContextGetInterpolationQuality(c: CGContextRef) -> CGInterpolationQuality;
}

extern "C-unwind" {
    pub fn CGContextSetInterpolationQuality(c: CGContextRef, quality: CGInterpolationQuality);
}

extern "C-unwind" {
    #[cfg(feature = "CGColor")]
    pub fn CGContextSetShadowWithColor(
        c: CGContextRef,
        offset: CGSize,
        blur: CGFloat,
        color: CGColorRef,
    );
}

extern "C-unwind" {
    pub fn CGContextSetShadow(c: CGContextRef, offset: CGSize, blur: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "CGGradient")]
    pub fn CGContextDrawLinearGradient(
        c: CGContextRef,
        gradient: CGGradientRef,
        start_point: CGPoint,
        end_point: CGPoint,
        options: CGGradientDrawingOptions,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGGradient")]
    pub fn CGContextDrawRadialGradient(
        c: CGContextRef,
        gradient: CGGradientRef,
        start_center: CGPoint,
        start_radius: CGFloat,
        end_center: CGPoint,
        end_radius: CGFloat,
        options: CGGradientDrawingOptions,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGGradient")]
    pub fn CGContextDrawConicGradient(
        c: CGContextRef,
        gradient: CGGradientRef,
        center: CGPoint,
        angle: CGFloat,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGShading")]
    pub fn CGContextDrawShading(c: CGContextRef, shading: CGShadingRef);
}

extern "C-unwind" {
    /// Text functions. *
    pub fn CGContextSetCharacterSpacing(c: CGContextRef, spacing: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextSetTextPosition(c: CGContextRef, x: CGFloat, y: CGFloat);
}

extern "C-unwind" {
    pub fn CGContextGetTextPosition(c: CGContextRef) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextSetTextMatrix(c: CGContextRef, t: CGAffineTransform);
}

extern "C-unwind" {
    pub fn CGContextGetTextMatrix(c: CGContextRef) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGContextSetTextDrawingMode(c: CGContextRef, mode: CGTextDrawingMode);
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    pub fn CGContextSetFont(c: CGContextRef, font: CGFontRef);
}

extern "C-unwind" {
    pub fn CGContextSetFontSize(c: CGContextRef, size: CGFloat);
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    pub fn CGContextShowGlyphsAtPositions(
        c: CGContextRef,
        glyphs: *const CGGlyph,
        lpositions: *const CGPoint,
        count: usize,
    );
}

extern "C-unwind" {
    /// PDF functions. *
    #[cfg(feature = "CGPDFPage")]
    pub fn CGContextDrawPDFPage(c: CGContextRef, page: CGPDFPageRef);
}

extern "C-unwind" {
    /// Output page functions. *
    pub fn CGContextBeginPage(c: CGContextRef, media_box: *const CGRect);
}

extern "C-unwind" {
    pub fn CGContextEndPage(c: CGContextRef);
}

extern "C-unwind" {
    /// Context functions. *
    pub fn CGContextRetain(c: CGContextRef) -> CGContextRef;
}

extern "C-unwind" {
    pub fn CGContextRelease(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextFlush(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextSynchronize(c: CGContextRef);
}

extern "C-unwind" {
    pub fn CGContextSetShouldAntialias(c: CGContextRef, should_antialias: bool);
}

extern "C-unwind" {
    pub fn CGContextSetAllowsAntialiasing(c: CGContextRef, allows_antialiasing: bool);
}

extern "C-unwind" {
    pub fn CGContextSetShouldSmoothFonts(c: CGContextRef, should_smooth_fonts: bool);
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSmoothing(c: CGContextRef, allows_font_smoothing: bool);
}

extern "C-unwind" {
    pub fn CGContextSetShouldSubpixelPositionFonts(
        c: CGContextRef,
        should_subpixel_position_fonts: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSubpixelPositioning(
        c: CGContextRef,
        allows_font_subpixel_positioning: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetShouldSubpixelQuantizeFonts(
        c: CGContextRef,
        should_subpixel_quantize_fonts: bool,
    );
}

extern "C-unwind" {
    pub fn CGContextSetAllowsFontSubpixelQuantization(
        c: CGContextRef,
        allows_font_subpixel_quantization: bool,
    );
}

extern "C-unwind" {
    /// Transparency layer support. *
    pub fn CGContextBeginTransparencyLayer(c: CGContextRef, auxiliary_info: CFDictionaryRef);
}

extern "C-unwind" {
    pub fn CGContextBeginTransparencyLayerWithRect(
        c: CGContextRef,
        rect: CGRect,
        aux_info: CFDictionaryRef,
    );
}

extern "C-unwind" {
    pub fn CGContextEndTransparencyLayer(c: CGContextRef);
}

extern "C-unwind" {
    /// User space to device space tranformations. *
    pub fn CGContextGetUserSpaceToDeviceSpaceTransform(c: CGContextRef) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGContextConvertPointToDeviceSpace(c: CGContextRef, point: CGPoint) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextConvertPointToUserSpace(c: CGContextRef, point: CGPoint) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGContextConvertSizeToDeviceSpace(c: CGContextRef, size: CGSize) -> CGSize;
}

extern "C-unwind" {
    pub fn CGContextConvertSizeToUserSpace(c: CGContextRef, size: CGSize) -> CGSize;
}

extern "C-unwind" {
    pub fn CGContextConvertRectToDeviceSpace(c: CGContextRef, rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    pub fn CGContextConvertRectToUserSpace(c: CGContextRef, rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[deprecated = "No longer supported"]
    pub fn CGContextSelectFont(
        c: CGContextRef,
        name: *const c_char,
        size: CGFloat,
        text_encoding: CGTextEncoding,
    );
}

extern "C-unwind" {
    #[deprecated = "No longer supported"]
    pub fn CGContextShowText(c: CGContextRef, string: *const c_char, length: usize);
}

extern "C-unwind" {
    #[deprecated = "No longer supported"]
    pub fn CGContextShowTextAtPoint(
        c: CGContextRef,
        x: CGFloat,
        y: CGFloat,
        string: *const c_char,
        length: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphs(c: CGContextRef, g: *const CGGlyph, count: usize);
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphsAtPoint(
        c: CGContextRef,
        x: CGFloat,
        y: CGFloat,
        glyphs: *const CGGlyph,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    pub fn CGContextShowGlyphsWithAdvances(
        c: CGContextRef,
        glyphs: *const CGGlyph,
        advances: *const CGSize,
        count: usize,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGPDFDocument")]
    #[deprecated = "No longer supported"]
    pub fn CGContextDrawPDFDocument(
        c: CGContextRef,
        rect: CGRect,
        document: CGPDFDocumentRef,
        page: c_int,
    );
}
