//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgmutablepathref?language=objc)
#[repr(C)]
pub struct CGMutablePathRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "CGPath"]
    unsafe impl CGMutablePathRef: CGPathRef {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathref?language=objc)
#[repr(C)]
pub struct CGPathRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "CGPath"]
    unsafe impl CGPathRef {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cglinejoin?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGLineJoin(pub i32);
impl CGLineJoin {
    #[doc(alias = "kCGLineJoinMiter")]
    pub const Miter: Self = Self(0);
    #[doc(alias = "kCGLineJoinRound")]
    pub const Round: Self = Self(1);
    #[doc(alias = "kCGLineJoinBevel")]
    pub const Bevel: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGLineJoin {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGLineJoin {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cglinecap?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGLineCap(pub i32);
impl CGLineCap {
    #[doc(alias = "kCGLineCapButt")]
    pub const Butt: Self = Self(0);
    #[doc(alias = "kCGLineCapRound")]
    pub const Round: Self = Self(1);
    #[doc(alias = "kCGLineCapSquare")]
    pub const Square: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGLineCap {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGLineCap {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    pub fn CGPathGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    pub fn CGPathCreateMutable() -> NonNull<CGMutablePathRef>;
}

extern "C-unwind" {
    pub fn CGPathCreateCopy(path: Option<&CGPathRef>) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyByTransformingPath(
        path: Option<&CGPathRef>,
        transform: *const CGAffineTransform,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateMutableCopy(path: Option<&CGPathRef>) -> *mut CGMutablePathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateMutableCopyByTransformingPath(
        path: Option<&CGPathRef>,
        transform: *const CGAffineTransform,
    ) -> *mut CGMutablePathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateWithRect(
        rect: CGRect,
        transform: *const CGAffineTransform,
    ) -> NonNull<CGPathRef>;
}

extern "C-unwind" {
    pub fn CGPathCreateWithEllipseInRect(
        rect: CGRect,
        transform: *const CGAffineTransform,
    ) -> NonNull<CGPathRef>;
}

extern "C-unwind" {
    pub fn CGPathCreateWithRoundedRect(
        rect: CGRect,
        corner_width: CGFloat,
        corner_height: CGFloat,
        transform: *const CGAffineTransform,
    ) -> NonNull<CGPathRef>;
}

extern "C-unwind" {
    pub fn CGPathAddRoundedRect(
        path: Option<&CGMutablePathRef>,
        transform: *const CGAffineTransform,
        rect: CGRect,
        corner_width: CGFloat,
        corner_height: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGPathCreateCopyByDashingPath(
        path: Option<&CGPathRef>,
        transform: *const CGAffineTransform,
        phase: CGFloat,
        lengths: *const CGFloat,
        count: usize,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyByStrokingPath(
        path: Option<&CGPathRef>,
        transform: *const CGAffineTransform,
        line_width: CGFloat,
        line_cap: CGLineCap,
        line_join: CGLineJoin,
        miter_limit: CGFloat,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathRetain(path: Option<&CGPathRef>) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathRelease(path: Option<&CGPathRef>);
}

extern "C-unwind" {
    pub fn CGPathEqualToPath(path1: Option<&CGPathRef>, path2: Option<&CGPathRef>) -> bool;
}

extern "C-unwind" {
    /// * Path construction functions. **
    pub fn CGPathMoveToPoint(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGPathAddLineToPoint(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGPathAddQuadCurveToPoint(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        cpx: CGFloat,
        cpy: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGPathAddCurveToPoint(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGPathCloseSubpath(path: Option<&CGMutablePathRef>);
}

extern "C-unwind" {
    /// * Path construction convenience functions. **
    pub fn CGPathAddRect(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        rect: CGRect,
    );
}

extern "C-unwind" {
    pub fn CGPathAddRects(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        rects: *const CGRect,
        count: usize,
    );
}

extern "C-unwind" {
    pub fn CGPathAddLines(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        points: *const CGPoint,
        count: usize,
    );
}

extern "C-unwind" {
    pub fn CGPathAddEllipseInRect(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        rect: CGRect,
    );
}

extern "C-unwind" {
    pub fn CGPathAddRelativeArc(
        path: Option<&CGMutablePathRef>,
        matrix: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        delta: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGPathAddArc(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: bool,
    );
}

extern "C-unwind" {
    pub fn CGPathAddArcToPoint(
        path: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    );
}

extern "C-unwind" {
    pub fn CGPathAddPath(
        path1: Option<&CGMutablePathRef>,
        m: *const CGAffineTransform,
        path2: Option<&CGPathRef>,
    );
}

extern "C-unwind" {
    /// * Path information functions. **
    pub fn CGPathIsEmpty(path: Option<&CGPathRef>) -> bool;
}

extern "C-unwind" {
    pub fn CGPathIsRect(path: Option<&CGPathRef>, rect: *mut CGRect) -> bool;
}

extern "C-unwind" {
    pub fn CGPathGetCurrentPoint(path: Option<&CGPathRef>) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGPathGetBoundingBox(path: Option<&CGPathRef>) -> CGRect;
}

extern "C-unwind" {
    pub fn CGPathGetPathBoundingBox(path: Option<&CGPathRef>) -> CGRect;
}

extern "C-unwind" {
    pub fn CGPathContainsPoint(
        path: Option<&CGPathRef>,
        m: *const CGAffineTransform,
        point: CGPoint,
        eo_fill: bool,
    ) -> bool;
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathelementtype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGPathElementType(pub i32);
impl CGPathElementType {
    #[doc(alias = "kCGPathElementMoveToPoint")]
    pub const MoveToPoint: Self = Self(0);
    #[doc(alias = "kCGPathElementAddLineToPoint")]
    pub const AddLineToPoint: Self = Self(1);
    #[doc(alias = "kCGPathElementAddQuadCurveToPoint")]
    pub const AddQuadCurveToPoint: Self = Self(2);
    #[doc(alias = "kCGPathElementAddCurveToPoint")]
    pub const AddCurveToPoint: Self = Self(3);
    #[doc(alias = "kCGPathElementCloseSubpath")]
    pub const CloseSubpath: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathElementType {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathElementType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathelement?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CGPathElement {
    pub r#type: CGPathElementType,
    pub points: NonNull<CGPoint>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathElement {
    const ENCODING: Encoding = Encoding::Struct(
        "CGPathElement",
        &[<CGPathElementType>::ENCODING, <NonNull<CGPoint>>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathElement {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathapplierfunction?language=objc)
pub type CGPathApplierFunction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, NonNull<CGPathElement>)>;

extern "C-unwind" {
    pub fn CGPathApply(
        path: Option<&CGPathRef>,
        info: *mut c_void,
        function: CGPathApplierFunction,
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathapplyblock?language=objc)
#[cfg(feature = "block2")]
pub type CGPathApplyBlock = *mut block2::Block<dyn Fn(NonNull<CGPathElement>)>;

extern "C-unwind" {
    #[cfg(feature = "block2")]
    pub fn CGPathApplyWithBlock(path: &CGPathRef, block: CGPathApplyBlock);
}

extern "C-unwind" {
    pub fn CGPathCreateCopyByNormalizing(
        path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyByUnioningPath(
        path: Option<&CGPathRef>,
        mask_path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyByIntersectingPath(
        path: Option<&CGPathRef>,
        mask_path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyBySubtractingPath(
        path: Option<&CGPathRef>,
        mask_path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyBySymmetricDifferenceOfPath(
        path: Option<&CGPathRef>,
        mask_path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyOfLineBySubtractingPath(
        path: Option<&CGPathRef>,
        mask_path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyOfLineByIntersectingPath(
        path: Option<&CGPathRef>,
        mask_path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathCreateSeparateComponents(
        path: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> *mut CFArrayRef;
}

extern "C-unwind" {
    pub fn CGPathCreateCopyByFlattening(
        path: Option<&CGPathRef>,
        flattening_threshold: CGFloat,
    ) -> *mut CGPathRef;
}

extern "C-unwind" {
    pub fn CGPathIntersectsPath(
        path1: Option<&CGPathRef>,
        path2: Option<&CGPathRef>,
        even_odd_fill_rule: bool,
    ) -> bool;
}
