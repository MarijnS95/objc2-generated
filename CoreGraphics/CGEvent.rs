//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C-unwind" {
    pub fn CGEventGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreate(source: Option<&CGEventSourceRef>) -> *mut CGEventRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateData(
        allocator: Option<&CFAllocatorRef>,
        event: Option<&CGEventRef>,
    ) -> *mut CFDataRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateFromData(
        allocator: Option<&CFAllocatorRef>,
        data: Option<&CFDataRef>,
    ) -> *mut CGEventRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateMouseEvent(
        source: Option<&CGEventSourceRef>,
        mouse_type: CGEventType,
        mouse_cursor_position: CGPoint,
        mouse_button: CGMouseButton,
    ) -> *mut CGEventRef;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
    pub fn CGEventCreateKeyboardEvent(
        source: Option<&CGEventSourceRef>,
        virtual_key: CGKeyCode,
        key_down: bool,
    ) -> *mut CGEventRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateScrollWheelEvent2(
        source: Option<&CGEventSourceRef>,
        units: CGScrollEventUnit,
        wheel_count: u32,
        wheel1: i32,
        wheel2: i32,
        wheel3: i32,
    ) -> *mut CGEventRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateCopy(event: Option<&CGEventRef>) -> *mut CGEventRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateSourceFromEvent(event: Option<&CGEventRef>) -> *mut CGEventSourceRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetSource(event: Option<&CGEventRef>, source: Option<&CGEventSourceRef>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetType(event: Option<&CGEventRef>) -> CGEventType;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetType(event: Option<&CGEventRef>, r#type: CGEventType);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetTimestamp(event: Option<&CGEventRef>) -> CGEventTimestamp;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetTimestamp(event: Option<&CGEventRef>, timestamp: CGEventTimestamp);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetLocation(event: Option<&CGEventRef>) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetUnflippedLocation(event: Option<&CGEventRef>) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetLocation(event: Option<&CGEventRef>, location: CGPoint);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetFlags(event: Option<&CGEventRef>) -> CGEventFlags;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetFlags(event: Option<&CGEventRef>, flags: CGEventFlags);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventKeyboardGetUnicodeString(
        event: Option<&CGEventRef>,
        max_string_length: UniCharCount,
        actual_string_length: *mut UniCharCount,
        unicode_string: *mut UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventKeyboardSetUnicodeString(
        event: Option<&CGEventRef>,
        string_length: UniCharCount,
        unicode_string: *const UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetIntegerValueField(event: Option<&CGEventRef>, field: CGEventField) -> i64;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetIntegerValueField(event: Option<&CGEventRef>, field: CGEventField, value: i64);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetDoubleValueField(event: Option<&CGEventRef>, field: CGEventField) -> c_double;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetDoubleValueField(
        event: Option<&CGEventRef>,
        field: CGEventField,
        value: c_double,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventTapCreate(
        tap: CGEventTapLocation,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> *mut CFMachPortRef;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventTapCreateForPSN(
        process_serial_number: NonNull<c_void>,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> *mut CFMachPortRef;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    pub fn CGEventTapCreateForPid(
        pid: libc::pid_t,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> *mut CFMachPortRef;
}

extern "C-unwind" {
    pub fn CGEventTapEnable(tap: &CFMachPortRef, enable: bool);
}

extern "C-unwind" {
    pub fn CGEventTapIsEnabled(tap: &CFMachPortRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventTapPostEvent(proxy: CGEventTapProxy, event: Option<&CGEventRef>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEventRef>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventPostToPSN(process_serial_number: *mut c_void, event: Option<&CGEventRef>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    pub fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEventRef>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGError", feature = "CGEventTypes", feature = "libc"))]
    pub fn CGGetEventTapList(
        max_number_of_taps: u32,
        tap_list: *mut CGEventTapInformation,
        event_tap_count: *mut u32,
    ) -> CGError;
}

extern "C-unwind" {
    pub fn CGPreflightListenEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGRequestListenEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGPreflightPostEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGRequestPostEventAccess() -> bool;
}
