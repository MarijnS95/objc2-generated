//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C-unwind" {
    pub fn CGEventGetTypeID() -> CFTypeID;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreate(source: Option<&CGEventSource>) -> *mut CGEvent;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateData(
        allocator: Option<&CFAllocator>,
        event: Option<&CGEvent>,
    ) -> *mut CFData;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateFromData(
        allocator: Option<&CFAllocator>,
        data: Option<&CFData>,
    ) -> *mut CGEvent;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateMouseEvent(
        source: Option<&CGEventSource>,
        mouse_type: CGEventType,
        mouse_cursor_position: CGPoint,
        mouse_button: CGMouseButton,
    ) -> *mut CGEvent;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
    pub fn CGEventCreateKeyboardEvent(
        source: Option<&CGEventSource>,
        virtual_key: CGKeyCode,
        key_down: bool,
    ) -> *mut CGEvent;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateScrollWheelEvent2(
        source: Option<&CGEventSource>,
        units: CGScrollEventUnit,
        wheel_count: u32,
        wheel1: i32,
        wheel2: i32,
        wheel3: i32,
    ) -> *mut CGEvent;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateCopy(event: Option<&CGEvent>) -> *mut CGEvent;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventCreateSourceFromEvent(event: Option<&CGEvent>) -> *mut CGEventSource;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventKeyboardGetUnicodeString(
        event: Option<&CGEvent>,
        max_string_length: UniCharCount,
        actual_string_length: *mut UniCharCount,
        unicode_string: *mut UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventKeyboardSetUnicodeString(
        event: Option<&CGEvent>,
        string_length: UniCharCount,
        unicode_string: *const UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetIntegerValueField(event: Option<&CGEvent>, field: CGEventField) -> i64;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetIntegerValueField(event: Option<&CGEvent>, field: CGEventField, value: i64);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetDoubleValueField(event: Option<&CGEvent>, field: CGEventField) -> c_double;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetDoubleValueField(
        event: Option<&CGEvent>,
        field: CGEventField,
        value: c_double,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventTapCreate(
        tap: CGEventTapLocation,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> *mut CFMachPort;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventTapCreateForPSN(
        process_serial_number: NonNull<c_void>,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> *mut CFMachPort;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    pub fn CGEventTapCreateForPid(
        pid: libc::pid_t,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> *mut CFMachPort;
}

extern "C-unwind" {
    pub fn CGEventTapEnable(tap: &CFMachPort, enable: bool);
}

extern "C-unwind" {
    pub fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventTapPostEvent(proxy: CGEventTapProxy, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventPostToPSN(process_serial_number: *mut c_void, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    pub fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGError", feature = "CGEventTypes", feature = "libc"))]
    pub fn CGGetEventTapList(
        max_number_of_taps: u32,
        tap_list: *mut CGEventTapInformation,
        event_tap_count: *mut u32,
    ) -> CGError;
}

extern "C-unwind" {
    pub fn CGPreflightListenEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGRequestListenEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGPreflightPostEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGRequestPostEventAccess() -> bool;
}
