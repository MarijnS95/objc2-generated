//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "CGEventTypes")]
unsafe impl ConcreteType for CGEvent {
    #[doc(alias = "CGEventGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGEventGetTypeID() -> CFTypeID;
        }
        unsafe { CGEventGetTypeID() }
    }
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreate(
    source: Option<&CGEventSource>,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreate(source: Option<&CGEventSource>) -> *mut CGEvent;
    }
    let ret = unsafe { CGEventCreate(source) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreateData(
    allocator: Option<&CFAllocator>,
    event: Option<&CGEvent>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CGEventCreateData(
            allocator: Option<&CFAllocator>,
            event: Option<&CGEvent>,
        ) -> *mut CFData;
    }
    let ret = unsafe { CGEventCreateData(allocator, event) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreateFromData(
    allocator: Option<&CFAllocator>,
    data: Option<&CFData>,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateFromData(
            allocator: Option<&CFAllocator>,
            data: Option<&CFData>,
        ) -> *mut CGEvent;
    }
    let ret = unsafe { CGEventCreateFromData(allocator, data) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreateMouseEvent(
    source: Option<&CGEventSource>,
    mouse_type: CGEventType,
    mouse_cursor_position: CGPoint,
    mouse_button: CGMouseButton,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateMouseEvent(
            source: Option<&CGEventSource>,
            mouse_type: CGEventType,
            mouse_cursor_position: CGPoint,
            mouse_button: CGMouseButton,
        ) -> *mut CGEvent;
    }
    let ret =
        unsafe { CGEventCreateMouseEvent(source, mouse_type, mouse_cursor_position, mouse_button) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreateKeyboardEvent(
    source: Option<&CGEventSource>,
    virtual_key: CGKeyCode,
    key_down: bool,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateKeyboardEvent(
            source: Option<&CGEventSource>,
            virtual_key: CGKeyCode,
            key_down: bool,
        ) -> *mut CGEvent;
    }
    let ret = unsafe { CGEventCreateKeyboardEvent(source, virtual_key, key_down) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreateScrollWheelEvent2(
    source: Option<&CGEventSource>,
    units: CGScrollEventUnit,
    wheel_count: u32,
    wheel1: i32,
    wheel2: i32,
    wheel3: i32,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateScrollWheelEvent2(
            source: Option<&CGEventSource>,
            units: CGScrollEventUnit,
            wheel_count: u32,
            wheel1: i32,
            wheel2: i32,
            wheel3: i32,
        ) -> *mut CGEvent;
    }
    let ret = unsafe {
        CGEventCreateScrollWheelEvent2(source, units, wheel_count, wheel1, wheel2, wheel3)
    };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreateCopy(
    event: Option<&CGEvent>,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateCopy(event: Option<&CGEvent>) -> *mut CGEvent;
    }
    let ret = unsafe { CGEventCreateCopy(event) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventCreateSourceFromEvent(
    event: Option<&CGEvent>,
) -> Option<CFRetained<CGEventSource>> {
    extern "C-unwind" {
        fn CGEventCreateSourceFromEvent(event: Option<&CGEvent>) -> *mut CGEventSource;
    }
    let ret = unsafe { CGEventCreateSourceFromEvent(event) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventKeyboardGetUnicodeString(
        event: Option<&CGEvent>,
        max_string_length: UniCharCount,
        actual_string_length: *mut UniCharCount,
        unicode_string: *mut UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventKeyboardSetUnicodeString(
        event: Option<&CGEvent>,
        string_length: UniCharCount,
        unicode_string: *const UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetIntegerValueField(event: Option<&CGEvent>, field: CGEventField) -> i64;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetIntegerValueField(event: Option<&CGEvent>, field: CGEventField, value: i64);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventGetDoubleValueField(event: Option<&CGEvent>, field: CGEventField) -> c_double;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventSetDoubleValueField(
        event: Option<&CGEvent>,
        field: CGEventField,
        value: c_double,
    );
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreate(
    tap: CGEventTapLocation,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreate(
            tap: CGEventTapLocation,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> *mut CFMachPort;
    }
    let ret =
        unsafe { CGEventTapCreate(tap, place, options, events_of_interest, callback, user_info) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreateForPSN(
    process_serial_number: NonNull<c_void>,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreateForPSN(
            process_serial_number: NonNull<c_void>,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> *mut CFMachPort;
    }
    let ret = unsafe {
        CGEventTapCreateForPSN(
            process_serial_number,
            place,
            options,
            events_of_interest,
            callback,
            user_info,
        )
    };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGEventTypes", feature = "libc"))]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreateForPid(
    pid: libc::pid_t,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreateForPid(
            pid: libc::pid_t,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> *mut CFMachPort;
    }
    let ret = unsafe {
        CGEventTapCreateForPid(pid, place, options, events_of_interest, callback, user_info)
    };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    pub fn CGEventTapEnable(tap: &CFMachPort, enable: bool);
}

extern "C-unwind" {
    pub fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventTapPostEvent(proxy: CGEventTapProxy, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    pub fn CGEventPostToPSN(process_serial_number: *mut c_void, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    pub fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>);
}

extern "C-unwind" {
    #[cfg(all(feature = "CGError", feature = "CGEventTypes", feature = "libc"))]
    pub fn CGGetEventTapList(
        max_number_of_taps: u32,
        tap_list: *mut CGEventTapInformation,
        event_tap_count: *mut u32,
    ) -> CGError;
}

extern "C-unwind" {
    pub fn CGPreflightListenEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGRequestListenEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGPreflightPostEventAccess() -> bool;
}

extern "C-unwind" {
    pub fn CGRequestPostEventAccess() -> bool;
}
